class e{constructor(e){this._array=new Float32Array,this.n=0,this.length=0,this.readPointer=0,this.writePointer=0,this.n=Math.floor(e),this.init()}init(){this._array=new Float32Array(2*this.n),this.length=this._array.length,this.readPointer=0,this.writePointer=this.n-1,this._array.fill(0)}read(){const e=this._array[this.readPointer%this.length];return this.readPointer=(this.readPointer+1)%this.length,e}push(e){this._array[this.writePointer%this.length]=e,this.writePointer=(this.writePointer+1)%this.length}reset(){this.init()}clear(){this._array=new Float32Array,this.length=0,this.readPointer=0,this.writePointer=0}sum(){return this._array.reduce((e,t)=>e+t,0)}}class t extends AudioWorkletProcessor{constructor(){super(),this.delayBuffer=[],this.envelopeSamples=[],this.stopped=!1,this.disabled=!1,this.port.onmessage=e=>{switch(e.data){case"reset":this.reset();break;case"stop":this.stop();break;case"disable":this.disabled=!0;break;case"enable":this.disabled=!1}}}static get parameterDescriptors(){return[{name:"preGain",defaultValue:0},{name:"postGain",defaultValue:0},{name:"attackTime",defaultValue:0},{name:"releaseTime",defaultValue:3},{name:"threshold",defaultValue:-.05},{name:"lookAheadTime",defaultValue:0}]}get defaultParameterDescriptors(){return t.parameterDescriptors}process(e,t,s){if(this.stopped)return!1;const a=e[0],r=t[0],i=this.applyPreGainAndComputeEnvelope(a,r,s);return this.applyLimiter(a,r,s,i),!0}getEnvelope(e,t,s,a,r){const i=Math.exp(-1/(a*t)),l=Math.exp(-1/(a*s)),h=new Float32Array(e.length);null==this.envelopeSamples[r]&&(this.envelopeSamples[r]=0);for(let t=0;t<e.length;t++){const s=Math.abs(e[t]);this.envelopeSamples[r]<s?this.envelopeSamples[r]=s+i*(this.envelopeSamples[r]-s):this.envelopeSamples[r]=s+l*(this.envelopeSamples[r]-s),h[t]=this.envelopeSamples[r]}return h}getMaxEnvelope(e,t,s){let a=e[0][s];for(let r=0;r<t;r++)e[r][s]>a&&(a=e[r][s]);return a}ampToDB(e){return 20*Math.log10(e)}dBToAmp(e){return Math.pow(10,e/20)}applyPreGainAndComputeEnvelope(t,s,a){const r=this.dBToAmp(a.preGain[0]),i=[];for(let l=0;l<s.length;l++){const h=t[l],n=s[l];null==this.delayBuffer[l]&&(this.delayBuffer[l]=new e(a.lookAheadTime[0]*sampleRate)),h&&n&&this.applyPreGain(h,n,r),!this.disabled&&n&&(i[l]=this.getEnvelope(n,a.attackTime[0],a.releaseTime[0],sampleRate,l))}return i}applyPreGain(e,t,s){for(let a=0;a<e.length;++a)this.disabled?t[a]=e[a]:t[a]=s*e[a]}applyLimiter(e,t,s,a){const r=this.dBToAmp(s.postGain[0]);for(let i=0;i<t.length;i++){const l=e[i],h=t[i];if(s.lookAheadTime[0]>0&&h&&this.applyLookAheadDelay(h,i),this.disabled)continue;const n=1;if(l&&h)for(let e=0;e<l.length;e++){let i=n*(s.threshold[0]-this.ampToDB(this.getMaxEnvelope(a,t.length,e)));i=Math.min(0,i);const l=this.dBToAmp(i);h[e]*=l*r}}}applyLookAheadDelay(e,t){for(let s=0;s<e.length;s++)this.delayBuffer[t].push(e[s]),e[s]=this.delayBuffer[t].read()}clearBuffers(){for(let e=0;e<this.delayBuffer.length;e++)null!=this.delayBuffer[e]&&this.delayBuffer[e].clear();this.delayBuffer=[],this.envelopeSamples=[]}reset(){this.clearBuffers()}stop(){this.clearBuffers(),this.stopped=!0}}registerProcessor("limiter-processor",t);
