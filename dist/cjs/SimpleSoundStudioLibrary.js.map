{"version":3,"file":"SimpleSoundStudioLibrary.js","sources":["../../node_modules/tslib/tslib.es6.js","../../lib/filters/interfaces/AbstractAudioElement.ts","../../lib/filters/interfaces/AbstractAudioFilter.ts","../../lib/model/Constants.ts","../../lib/utils/Functions.ts","../../lib/filters/BassBoosterFilter.ts","../../lib/workletPolyfill/AudioParamPolyfill.ts","../../lib/workletPolyfill/WorkletScriptProcessorNodeAdapter.ts","../../lib/workletPolyfill/RegisterProcessorPolyfill.ts","../../lib/workletPolyfill/SimpleAudioWorkletProcessor.ts","../../lib/workletPolyfill/AudioWorkletProcessorPolyfill.ts","../../lib/filters/interfaces/AbstractAudioFilterWorklet.ts","../../lib/filters/worklets/BitCrusher.worklet.ts","../../lib/filters/BitCrusherFilter.ts","../../lib/filters/EchoFilter.ts","../../lib/filters/HighPassFilter.ts","../../lib/utils/DelayBuffer.ts","../../lib/filters/worklets/Limiter.worklet.ts","../../lib/filters/LimiterFilter.ts","../../lib/filters/LowPassFilter.ts","../../lib/filters/interfaces/AbstractAudioRenderer.ts","../../lib/filters/ReturnAudioRenderer.ts","../../lib/filters/ReverbFilter.ts","../../node_modules/soundtouchjs/dist/soundtouch.js","../../lib/filters/worklets/SoundtouchWrapperFilterWorkletNode.ts","../../lib/model/EventTypeEnum.ts","../../lib/filters/SountouchWrapperFilter.ts","../../lib/filters/TelephonizerFilter.ts","../../lib/utils/EventEmitter.ts","../../lib/BufferPlayer.ts","../../lib/services/BufferFetcherService.ts","../../lib/utils/Vocoder.ts","../../lib/filters/VocoderFilter.ts","../../lib/utils/GenericConfigService.ts","../../node_modules/inline-worker/index.js","../../lib/recorder/RecorderWorker.ts","../../lib/recorder/Recorder.ts","../../lib/utils/TimerSaveTime.ts","../../lib/AudioEditor.ts","../../lib/VoiceRecorder.ts"],"sourcesContent":["/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.unshift(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.unshift(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\n\r\nexport function __runInitializers(thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\n\r\nexport function __propKey(x) {\r\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nexport function __setFunctionName(f, name, prefix) {\r\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n\r\nexport function __addDisposableResource(env, value, async) {\r\n    if (value !== null && value !== void 0) {\r\n        if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\r\n        var dispose;\r\n        if (async) {\r\n            if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\r\n            dispose = value[Symbol.asyncDispose];\r\n        }\r\n        if (dispose === void 0) {\r\n            if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\r\n            dispose = value[Symbol.dispose];\r\n        }\r\n        if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\r\n        env.stack.push({ value: value, dispose: dispose, async: async });\r\n    }\r\n    else if (async) {\r\n        env.stack.push({ async: true });\r\n    }\r\n    return value;\r\n}\r\n\r\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\r\n\r\nexport function __disposeResources(env) {\r\n    function fail(e) {\r\n        env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\r\n        env.hasError = true;\r\n    }\r\n    function next() {\r\n        while (env.stack.length) {\r\n            var rec = env.stack.pop();\r\n            try {\r\n                var result = rec.dispose && rec.dispose.call(rec.value);\r\n                if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\r\n            }\r\n            catch (e) {\r\n                fail(e);\r\n            }\r\n        }\r\n        if (env.hasError) throw env.error;\r\n    }\r\n    return next();\r\n}\r\n\r\nexport default {\r\n    __extends: __extends,\r\n    __assign: __assign,\r\n    __rest: __rest,\r\n    __decorate: __decorate,\r\n    __param: __param,\r\n    __metadata: __metadata,\r\n    __awaiter: __awaiter,\r\n    __generator: __generator,\r\n    __createBinding: __createBinding,\r\n    __exportStar: __exportStar,\r\n    __values: __values,\r\n    __read: __read,\r\n    __spread: __spread,\r\n    __spreadArrays: __spreadArrays,\r\n    __spreadArray: __spreadArray,\r\n    __await: __await,\r\n    __asyncGenerator: __asyncGenerator,\r\n    __asyncDelegator: __asyncDelegator,\r\n    __asyncValues: __asyncValues,\r\n    __makeTemplateObject: __makeTemplateObject,\r\n    __importStar: __importStar,\r\n    __importDefault: __importDefault,\r\n    __classPrivateFieldGet: __classPrivateFieldGet,\r\n    __classPrivateFieldSet: __classPrivateFieldSet,\r\n    __classPrivateFieldIn: __classPrivateFieldIn,\r\n    __addDisposableResource: __addDisposableResource,\r\n    __disposeResources: __disposeResources,\r\n};\r\n","import BufferFetcherService from \"../../services/BufferFetcherService\";\nimport { ConfigService } from \"../../services/ConfigService\";\n\nexport default abstract class AbstractAudioElement {\n\n    private enabled = false;\n    private defaultEnabled = false;\n    bufferFetcherService: BufferFetcherService | null = null;\n    configService: ConfigService | null = null;\n\n    /** Returns the order in which the filter/renderer needs to be applied */\n    abstract get order(): number;\n\n    /** Returns the id of this filter/renderer */\n    abstract get id(): string;\n\n    /** Is this filter/renderer enabled? */\n    isEnabled(): boolean {\n        return this.enabled;\n    }\n\n    /** Is this filter/renderer enabled by default? */\n    isDefaultEnabled(): boolean {\n        return this.defaultEnabled;\n    }\n\n    /** Set to true if this filter/renderer needs to be enabled by default */\n    setDefaultEnabled(state: boolean) {\n        this.defaultEnabled = state;\n    }\n\n    setEnabled(state: boolean) {\n        this.enabled = state;\n    }\n\n    /** Enable this filter/renderer */\n    enable() {\n        this.setEnabled(true);\n    }\n\n    /** Disable this filter/renderer */\n    disable() {\n        this.setEnabled(false);\n    }\n\n    /** Toggle to enabled/disabled this filter */\n    toggle() {\n        this.setEnabled(!this.isEnabled());\n    }\n}\n","import AbstractAudioElement from \"./AbstractAudioElement\";\nimport { AudioFilterNodes } from \"../../model/AudioNodes\";\nimport { FilterSettingValue, FilterSettings } from \"../../model/filtersSettings/FilterSettings\";\n\nexport default abstract class AbstractAudioFilter extends AbstractAudioElement {\n\n    private defaultSettings: FilterSettings | null = null;\n\n    /** Return a input and output AudioNode of the filter */\n    abstract getNode(context: BaseAudioContext): AudioFilterNodes;\n    /** Return an object with current settings of this filter */\n    abstract getSettings(): FilterSettings;\n    /** Set a filter setting */\n    abstract setSetting(settingId: string, value: FilterSettingValue): Promise<void>;\n    \n    /** Get the amount of time this filter add to the audio */\n    getAddingTime(): number {\n        return 0;\n    }\n\n    /** Store the default settings */\n    public initializeDefaultSettings() {\n        this.defaultSettings = this.getSettings();\n    }\n\n    /** Returns the default settings of this filter */\n    public getDefaultSettings() {\n        return this.defaultSettings;\n    }\n\n    /** Reset the default settings of this filter */\n    public resetSettings() {\n        if(this.defaultSettings) {\n            Object.keys(this.defaultSettings).forEach(key => {\n                if(this.defaultSettings && typeof(this.defaultSettings[key]) !== \"undefined\") {\n                    this.setSetting(key, this.defaultSettings[key]);\n                }\n            });\n        }\n    }\n\n    /** Return if the current filter use an audio worklet */\n    public isWorklet() {\n        return false;\n    }\n}\n","const Constants = {\n    AUDIO_EDITOR: \"audioEditor\",\n    VOICE_RECORDER: \"voiceRecorder\",\n    BUFFER_PLAYER: \"bufferPlayer\",\n    EXPORT_WAV_COMMAND: \"exportWAV\",\n    AUDIO_WAV: \"audio/wav\",\n    RECORD_COMMAND: \"record\",\n    INIT_COMMAND: \"init\",\n    FILTERS_NAMES: {\n        REVERB: \"reverb\",\n        ECHO: \"echo\",\n        BASS_BOOST: \"bassboost\",\n        BITCRUSHER: \"bitcrusher\",\n        HIGH_PASS: \"highpass\",\n        LIMITER: \"limiter\",\n        LOW_PASS: \"lowpass\",\n        PASS_THROUGH: \"passthroughfilter\",\n        RETURN_AUDIO: \"returnAudio\",\n        SOUNDTOUCH: \"soundtouch\",\n        TELEPHONIZER: \"telephonizer\",\n        VOCODER: \"vocoder\"\n    },\n    WORKLET_PATHS: {\n        BITCRUSHER: \"worklets/BitCrusher.worklet.js\",\n        LIMITER: \"worklets/Limiter.worklet.js\",\n        SOUNDTOUCH: \"worklets/Soundtouch.worklet.js\",\n        RECORDER_WORKLET: \"worklets/RecorderWorklet.js\"\n    },\n    WORKLET_NAMES: {\n        BITCRUSHER: \"bitcrusher-processor\",\n        LIMITER: \"limiter-processor\",\n        SOUNDTOUCH: \"soundtouch-worklet\",\n        RECORDER_WORKLET: \"recorder-worklet\"\n    },\n    PREFERENCES_KEYS: {\n        COMPATIBILITY_MODE_ENABLED: \"compatibility-mode-enabled\",\n        COMPATIBILITY_MODE_CHECKED: \"compatibility-mode-checked\",\n        ENABLE_AUDIO_WORKLET: \"enable-audio-worklet\",\n        ENABLE_SOUNDTOUCH_AUDIO_WORKLET: \"enable-soundtouch-audio-worklet\",\n        BUFFER_SIZE: \"buffer-size\",\n        SAMPLE_RATE: \"sample-rate\"\n    },\n    // Enable or disable the use of Audio Worklet version of Soundtouch\n    // If disabled, the ScriptProcessorNode version is used\n    ENABLE_SOUNDTOUCH_AUDIO_WORKLET: true,\n    ENABLE_AUDIO_WORKLET: true,\n    ENABLE_RECORDER_AUDIO_WORKLET: true,\n    SOUNDTOUCH_PITCH_SHIFTER_BUFFER_SIZE: 16384,\n    DEFAULT_REVERB_ENVIRONMENT: {\n        name: \"Medium Damping Cave E002 M2S\",\n        url: \"static/sounds/impulse_response.wav\",\n        size: 1350278,\n        addDuration: 4,\n        link: \"http://www.cksde.com/p_6_250.htm\"\n    },\n    VOCODER_MODULATOR: \"modulator.mp3\",\n    DEFAULT_BUFFER_SIZE: 0,\n    VALID_BUFFER_SIZE: [0, 256, 512, 1024, 2048, 4096, 8192, 16384],\n    DEFAULT_SAMPLE_RATE: 0, // 0 = AUTO\n    VALID_SAMPLE_RATES: [0, 8000, 11025, 16000, 22050, 32000, 44100, 48000, 88200, 96000, 176400, 192000]\n};\n\nexport default Constants;\n","import { FilterSettingValue } from \"../model/filtersSettings/FilterSettings\";\n\nconst utilFunctions = {\n    calcAudioDuration: (audio: AudioBuffer, speed: number) => {\n        if (audio) {\n            let duration = audio.duration + 1;\n\n            if (speed) {\n                duration = duration / speed;\n            }\n\n            return duration;\n        }\n\n        return 0;\n    },\n    loadAudioBuffer: async (context: AudioContext, file: File) => {\n        const arrayBuffer = await utilFunctions.readAsArrayBufferPromisified(file);\n        const audioBuffer = await context.decodeAudioData(arrayBuffer);\n        return utilFunctions.decodeBuffer(context, audioBuffer);\n    },\n    readAsArrayBufferPromisified: (file: File): Promise<ArrayBuffer> => {\n        return new Promise((resolve, reject) => {\n            const reader = new FileReader();\n\n            reader.onload = ev => {\n                const result = ev?.target?.result;\n\n                if (result instanceof ArrayBuffer) {\n                    resolve(result);\n                } else {\n                    reject();\n                }\n            };\n\n            if (file) {\n                reader.readAsArrayBuffer(file); // Read the file\n            }\n        });\n    },\n    decodeBuffer: (context: AudioContext, buffer: AudioBuffer) => {\n        if (buffer.numberOfChannels == 1) { // convert to stereo buffer\n            context.resume();\n\n            const duration = buffer.duration;\n            const sampleRate = context.sampleRate;\n\n            const newBuffer = context.createBuffer(2, sampleRate * duration + sampleRate * 2, sampleRate);\n\n            // Original buffer data\n            const sourceChannelData = buffer.getChannelData(0);\n\n            // Destination buffers\n            const channel0Data = newBuffer.getChannelData(0);\n            const channel1Data = newBuffer.getChannelData(1);\n\n            for (let i = 0; i < sourceChannelData.length; i++) {\n                channel0Data[i] = sourceChannelData[i];\n                channel1Data[i] = sourceChannelData[i];\n            }\n\n            return newBuffer;\n        }\n\n        return buffer;\n    },\n    convertAudioBufferToFloat32Array: (buffer: AudioBuffer) => {\n        const array: Float32Array[] = [];\n\n        for (let channel = 0; channel < buffer.numberOfChannels; channel++) {\n            array.push(buffer.getChannelData(channel));\n        }\n\n        return array;\n    },\n    convertAudioParamToFloat32Array: (param: AudioParam, length: number) => {\n        const array = new Float32Array(length);\n\n        for (let i = 0; i < length; i++) {\n            array.set([param.value], i);\n        }\n\n        return array;\n    },\n    sumAudioBufferChannel(buffer: AudioBuffer, channel: number) {\n        return buffer.getChannelData(channel).reduce((a, b) => a + b, 0);\n    },\n    sumAudioBuffer(buffer: AudioBuffer) {\n        let sum = 0;\n\n        for(let channel = 0; channel < buffer.numberOfChannels; channel++) {\n            sum += this.sumAudioBufferChannel(buffer, channel);\n        }\n\n        return sum;\n    },\n    /**\n    * This method checks if the browser is compatible with audio worklets\n    * @param audioContext \n    */\n    isAudioWorkletCompatible(audioContext: BaseAudioContext) {\n        if (typeof (audioContext) !== \"undefined\" && typeof (audioContext.audioWorklet) !== \"undefined\") {\n            return true;\n        }\n\n        return false;\n    },\n    /**\n     * Check that the setting value is correct\n     * @param value FilterSettingValue\n     */\n    isSettingValueValid(value: FilterSettingValue) {\n        return typeof(value) !== \"undefined\" && !isNaN(Number(value)) && !(typeof(value) === \"string\" && value.trim() === \"\");\n    }\n};\n\nexport default utilFunctions;\n","import AbstractAudioFilter from \"./interfaces/AbstractAudioFilter\";\nimport Constants from \"../model/Constants\";\nimport BassBoosterSettings from \"../model/filtersSettings/BassBoosterSettings\";\nimport { FilterSettingValue } from \"../model/filtersSettings/FilterSettings\";\nimport utilFunctions from \"../utils/Functions\";\n\nexport default class BassBoosterFilter extends AbstractAudioFilter {\n    private frequencyBooster = 200;\n    private frequencyReduce = 200;\n    private dbBooster = 15;\n    private dbReduce = -2;\n\n    constructor(frequencyBooster: number, dbBooster: number, frequencyReduce: number, dbReduce: number) {\n        super();\n        this.frequencyBooster = frequencyBooster;\n        this.dbBooster = dbBooster;\n        this.frequencyReduce = frequencyReduce;\n        this.dbReduce = dbReduce;\n    }\n\n    getNode(context: BaseAudioContext) {\n        const bassBoostFilter = context.createBiquadFilter();\n        bassBoostFilter.type = \"lowshelf\";\n        bassBoostFilter.frequency.value = this.frequencyBooster;\n        bassBoostFilter.gain.value = this.dbBooster;\n\n        const bassBoostFilterHighFreq = context.createBiquadFilter();\n        bassBoostFilterHighFreq.type = \"highshelf\";\n        bassBoostFilterHighFreq.frequency.value = this.frequencyReduce;\n        bassBoostFilterHighFreq.gain.value = this.dbReduce;\n        bassBoostFilterHighFreq.connect(bassBoostFilter);\n\n        return {\n            input: bassBoostFilterHighFreq,\n            output: bassBoostFilter\n        };\n    }\n    \n    get order(): number {\n        return 3;\n    }\n\n    get id(): string {\n        return Constants.FILTERS_NAMES.BASS_BOOST;\n    }\n\n    getSettings(): BassBoosterSettings {\n        return {\n            frequencyBooster: this.frequencyBooster,\n            frequencyReduce: this.frequencyReduce,\n            dbBooster: this.dbBooster,\n            dbReduce: this.dbReduce,\n        };\n    }\n\n    async setSetting(settingId: string, value: FilterSettingValue) {\n        if(!utilFunctions.isSettingValueValid(value)) {\n            return;\n        }\n\n        switch(settingId) {\n        case \"frequencyBooster\":\n            this.frequencyBooster = parseInt(value as string);\n            break;\n        case \"frequencyReduce\":\n            this.frequencyReduce = parseInt(value as string);\n            break;\n        case \"dbBooster\":\n            this.dbBooster = parseInt(value as string);\n            break;\n        case \"dbReduce\":\n            this.dbReduce = parseInt(value as string);\n            break;\n        }\n    }\n}\n","/* eslint-disable @typescript-eslint/no-unused-vars */\n/**\n * This class is a polyfill for the standard web AudioParam class used by worklets\n */\nexport default class AudioParamPolyfill implements AudioParam {\n    private _value: number = 0;\n    private _minValue: number = 0;\n    private _maxValue: number = Number.MAX_SAFE_INTEGER;\n    private _defaultValue: number = 0;\n    private context: BaseAudioContext | null = null;\n    automationRate: AutomationRate = \"a-rate\";\n\n    constructor(context: BaseAudioContext, defaultValue?: number) {\n        this._defaultValue = defaultValue !== undefined ? defaultValue : 0;\n        this._value = this._defaultValue;\n        this.context = context;\n    }\n\n    get value(): number {\n        return this._value;\n    }\n\n    set value(newValue: number) {\n        this._value = Math.max(this._minValue, Math.min(this._maxValue, newValue));\n    }\n\n    get minValue(): number {\n        return this._minValue;\n    }\n\n    get maxValue(): number {\n        return this._maxValue;\n    }\n\n    get defaultValue(): number {\n        return this._defaultValue;\n    }\n\n    setValueAtTime(value: number, startTime: number): AudioParam {\n        console.warn(\"setValueAtTime used with AudioParamPolyfill, is not fully compatible with standard AudioParam\");\n        this.value = value;\n        return new AudioParamPolyfill(this.context!, value);\n    }\n\n    linearRampToValueAtTime(value: number, endTime: number): AudioParam {\n        console.warn(\"linearRampToValueAtTime used with AudioParamPolyfill, is not fully compatible with standard AudioParam\");\n        this.value = value;\n        return new AudioParamPolyfill(this.context!, value);\n    }\n\n    exponentialRampToValueAtTime(value: number, endTime: number): AudioParam {\n        console.warn(\"exponentialRampToValueAtTime used with AudioParamPolyfill, is not fully compatible with standard AudioParam\");\n        this.value = value;\n        return new AudioParamPolyfill(this.context!, value);\n    }\n\n    cancelAndHoldAtTime(cancelTime: number): AudioParam {\n        throw new Error(\"Method not implemented.\");\n    }\n\n    cancelScheduledValues(cancelTime: number): AudioParam {\n        throw new Error(\"Method not implemented.\");\n    }\n\n    setTargetAtTime(target: number, startTime: number, timeConstant: number): AudioParam {\n        throw new Error(\"Method not implemented.\");\n    }\n\n    setValueCurveAtTime(values: unknown, startTime: unknown, duration: unknown): AudioParam {\n        throw new Error(\"Method not implemented.\");\n    }\n}\n","import SimpleAudioWorkletProcessor from \"./SimpleAudioWorkletProcessor\";\nimport AudioParamPolyfill from \"./AudioParamPolyfill\";\nimport Functions from \"../utils/Functions\";\n\n/**\n * This class convert an audio worklet processor node to a script processor node\n * automagically. Highly experimental, and might not work with some WorkletProcessor\n */\nexport default class WorkletScriptProcessorNodeAdapter {\n\n    private workletProcessor: SimpleAudioWorkletProcessor;\n    private _parameters = new Map<string, AudioParamPolyfill>();\n    private _port: MessagePort | null = null;\n    private _scriptProcessorNode: ScriptProcessorNode | null;\n    private currentContext: BaseAudioContext | null = null;\n\n    constructor(context: BaseAudioContext, node: SimpleAudioWorkletProcessor, bufferSize?: number) {\n        this.workletProcessor = node;\n        this.currentContext = context;\n\n        // Create a ScriptProcessorNode with the same number of input and output channels\n        this._scriptProcessorNode = context.createScriptProcessor(\n            bufferSize,\n            2,\n            2\n        );\n\n        this.setupPort();\n        this.setupProcessor();\n        this.setupWorkletScope(context);\n    }\n\n    private setupPort(): void {\n        const messageChannel = new MessageChannel();\n\n        messageChannel.port1.onmessage = (ev) => {\n            if(this.workletProcessor && this.workletProcessor.port2) {\n                this.workletProcessor.port2.postMessage(ev.data);\n            }\n        };\n\n        this._port = messageChannel.port2;\n    }\n\n    private setupProcessor() {\n        if(!this._scriptProcessorNode) {\n            return;\n        }\n\n        this._scriptProcessorNode.onaudioprocess = (ev: AudioProcessingEvent) => {\n            if(this.workletProcessor) {\n                const inputArray = [Functions.convertAudioBufferToFloat32Array(ev.inputBuffer)];\n                const ouputArray = [Functions.convertAudioBufferToFloat32Array(ev.outputBuffer)];\n\n                const records: [string, Float32Array][] = [];\n\n                for (const [key, value] of this._parameters.entries()) {\n                    records.push([key, Functions.convertAudioParamToFloat32Array(value, 1)]);\n                }\n\n                const recordsMap: Record<string, Float32Array> = Object.fromEntries(records);\n                \n                this.workletProcessor.process(inputArray, ouputArray, recordsMap);\n            }\n        };\n\n        const descriptors = this.workletProcessor.defaultParameterDescriptors;\n\n        if(descriptors) {\n            descriptors.forEach(descriptor => {\n                if(this.currentContext) {\n                    this._parameters.set(descriptor.name, new AudioParamPolyfill(this.currentContext, descriptor.defaultValue));\n                }\n            });\n        }\n    }\n\n    private setupWorkletScope(context: BaseAudioContext) {\n        if(typeof(window) !== \"undefined\") {\n            window.sampleRate = context.sampleRate;\n        }\n    }\n\n    get port() {\n        return this._port;\n    }\n\n    get parameters(): AudioParamMap {\n        return this._parameters;\n    }\n\n    get node() {\n        return this._scriptProcessorNode;\n    }\n\n    get context() {\n        return this._scriptProcessorNode?.context;\n    }\n}\n","import SimpleAudioWorkletProcessor from \"./SimpleAudioWorkletProcessor\";\n\n/**\n * Polyfill for registerProcessor method used in AudioWorklets\n */\nexport default class RegisterProcessorPolyfill {\n\n    private static processorsMap = new Map<string, typeof SimpleAudioWorkletProcessor>();\n\n    static registerProcessor(processorName: string, processorClass: typeof SimpleAudioWorkletProcessor) {\n        RegisterProcessorPolyfill.processorsMap.set(processorName, processorClass);\n    }\n\n    static getProcessor(processorName: string): SimpleAudioWorkletProcessor | null {\n        const processor = RegisterProcessorPolyfill.processorsMap.get(processorName);\n\n        if(processor) {\n            return new processor();\n        }\n\n        return null;\n    }\n};\n","/**\n * This class is the standard AudioWorkletProcessor interface\n */\nexport interface AudioWorkletProcessorInterface {\n\n    process(inputs: Float32Array[][], outputs: Float32Array[][], parameters: Record<string, Float32Array>): boolean;\n    get parameters(): AudioParamMap;\n    get parameterDescriptors(): AudioParamMap;\n    messageProcessor?: (event: MessageEvent) => void;\n}\n\ntype ParameterDescriptors = {\n    name: string;\n    defaultValue: number;\n}[];\n\n/**\n * This class is a polyfill for the AudioWorkletProcessor interface\n */\nexport default class SimpleAudioWorkletProcessor implements AudioWorkletProcessorInterface {\n    private messageChannel: MessageChannel | null = null;\n    messageProcessor?: ((event: MessageEvent) => void) | undefined;\n\n    constructor() {\n        this.messageChannel = new MessageChannel();\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    process(inputs: Float32Array[][], outputs: Float32Array[][], parameters: Record<string, Float32Array>): boolean {\n        return true;\n    }\n\n    get port(): MessagePort | null {\n        return this.messageChannel && this.messageChannel.port1;\n    }\n\n    get port2(): MessagePort | null {\n        return this.messageChannel && this.messageChannel.port2;\n    }\n\n    get parameters(): AudioParamMap {\n        throw new Error(\"Method not implemented.\");\n    }\n\n    get parameterDescriptors(): AudioParamMap {\n        throw new Error(\"Method not implemented.\");\n    }\n\n    get defaultParameterDescriptors(): ParameterDescriptors {\n        return [];\n    }\n};\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport RegisterProcessorPolyfill from \"./RegisterProcessorPolyfill\";\nimport SimpleAudioWorkletProcessor from \"./SimpleAudioWorkletProcessor\";\n\nif(typeof(window) !== \"undefined\" && !(\"AudioWorkletProcessor\" in window)) {\n    (window as any).AudioWorkletProcessor = SimpleAudioWorkletProcessor;\n    (window as any).registerProcessor = RegisterProcessorPolyfill.registerProcessor;\n}\n\nif(typeof(global) !== \"undefined\" && !(\"AudioWorkletProcessor\" in global)) {\n    (global as any).AudioWorkletProcessor = SimpleAudioWorkletProcessor;\n    (global as any).registerProcessor = RegisterProcessorPolyfill.registerProcessor;\n}\n","import WorkletScriptProcessorNodeAdapter from \"../../workletPolyfill/WorkletScriptProcessorNodeAdapter\";\nimport AbstractAudioFilter from \"./AbstractAudioFilter\";\nimport Constants from \"../../model/Constants\";\nimport \"../../workletPolyfill/AudioWorkletProcessorPolyfill\";\nimport RegisterProcessorPolyfill from \"../../workletPolyfill/RegisterProcessorPolyfill\";\nimport utilFunctions from \"../../utils/Functions\";\n\nexport default abstract class AbstractAudioFilterWorklet extends AbstractAudioFilter {\n\n    protected currentWorkletNode: AudioWorkletNode | WorkletScriptProcessorNodeAdapter | null = null;\n    protected fallbackToScriptProcessor = false;\n    protected keepCurrentNodeIfPossible = false;\n\n    /**\n     * Return the worklet name (as registered with method registerProcessor)\n     */\n    abstract get workletName(): string;\n\n    /**\n     * Return the path to worklet file\n     */\n    abstract get workletPath(): string;\n\n    /**\n     * Initialize the audio worklet by loading the module\n     * @param audioContext The audio context\n     */\n    async initializeWorklet(audioContext: BaseAudioContext): Promise<void> {\n        this.stop();\n\n        if(!utilFunctions.isAudioWorkletCompatible(audioContext)) {\n            console.error(\"Audio Worklets not supported on this browser. Fallback to ScriptProcessor\");\n            this.fallbackToScriptProcessor = true;\n            return;\n        }\n\n        await audioContext.audioWorklet.addModule(this.workletPath)\n            .catch(e => {\n                console.error(`Error when loading Worklet (${this.workletPath}) for filter ${this.id}. Fallback to ScriptProcessor. Exception:`, e);\n                this.fallbackToScriptProcessor = true;\n            });\n    }\n\n    /**\n     * This method checks if audio worklet are enabled\n     * @param audioContext \n     */\n    protected isAudioWorkletEnabled() {\n        if(this.configService) {\n            return this.configService.isAudioWorkletEnabled();\n        }\n\n        return Constants.ENABLE_AUDIO_WORKLET;\n    }\n\n    /**\n     * Initialize the AudioWorkletNode or fallback to ScriptProcessorNode\n     * @param context The audio context\n     * @param workletName The worklet name\n     */\n    private initializeNode(context: BaseAudioContext, workletName: string) {\n        if (this.isAudioWorkletEnabled() && !this.fallbackToScriptProcessor) {\n            this.currentWorkletNode = new AudioWorkletNode(context, workletName);\n        } else {\n            const processor = RegisterProcessorPolyfill.getProcessor(workletName);\n\n            if(processor) {\n                this.currentWorkletNode = new WorkletScriptProcessorNodeAdapter(context, processor, this.configService!.getBufferSize());\n            } else {\n                throw new Error(`No processor registered with name ${workletName} for filter ${this.id} to use the fallback/polyfill for AudioWorklet. Make sure you have created the class.`);\n            }\n        }\n    }\n\n    /**\n     * Apply current settings to the audio worklet node.\n     * Uses the getSettings method to extract the settings.\n     */\n    protected applyCurrentSettingsToWorklet() {\n        if (this.currentWorkletNode && this.currentWorkletNode.parameters) {\n            const currentSettings = this.getSettings();\n\n            for (const settingKey of Object.keys(currentSettings)) {\n                const settingFromWorklet = this.currentWorkletNode.parameters.get(settingKey);\n\n                if (settingFromWorklet) {\n                    settingFromWorklet.value = currentSettings[settingKey] as number;\n                    settingFromWorklet.setValueAtTime(currentSettings[settingKey] as number, 0);\n                }\n            }\n        }\n    }\n\n    /** Default implementation for GetNode - AbstractAudioFilterWorklet */\n    getNode(context: BaseAudioContext) {\n        if(!this.keepCurrentNodeIfPossible || !this.currentWorkletNode\n            || this.currentWorkletNode.context != context) {\n            this.stop();\n            this.initializeNode(context, this.workletName);\n        }\n\n        this.applyCurrentSettingsToWorklet();\n        this.setEnabled(this.isEnabled());\n\n        if (this.currentWorkletNode) {\n            if (this.currentWorkletNode instanceof WorkletScriptProcessorNodeAdapter) {\n                return {\n                    input: this.currentWorkletNode.node!,\n                    output: this.currentWorkletNode.node!,\n                };\n            } else {\n                return {\n                    input: this.currentWorkletNode,\n                    output: this.currentWorkletNode,\n                };\n            }\n        }\n\n        throw new Error(\"Worklet node has not yet been created\");\n    }\n\n    /**\n     * Stop the current worklet node. The worklet need to respond to \"stop\" events.\n     */\n    stop() {\n        if (this.currentWorkletNode && this.currentWorkletNode.port) {\n            this.currentWorkletNode.port.postMessage(\"stop\");\n        }\n\n        this.currentWorkletNode = null;\n    }\n\n    /**\n     * Pass the current disabled/enabled state to the worklet.\n     * The worklet need to respond to \"enable\"/\"disable\" events.\n     * @param state The current disabled/enabled state\n     */\n    setEnabled(state: boolean): void {\n        if (this.currentWorkletNode && this.currentWorkletNode.port) {\n            this.currentWorkletNode.port.postMessage(state ? \"enable\" : \"disable\");\n        }\n\n        super.setEnabled(state);\n    }\n\n    public isWorklet(): boolean {\n        return true;\n    }\n}\n","import Constants from \"../../model/Constants\";\n\nclass BitCrusherProcessor extends AudioWorkletProcessor {\n    private stopped = false;\n    private phaser: number[] | null = null;\n    private last: number[] | null = null;\n\n    constructor() {\n        super();\n        this.port.onmessage = (event) => {\n            if (event.data == \"stop\") {\n                this.stop();\n            }\n        };\n    }\n\n    static get parameterDescriptors() {\n        return [\n            { name: \"bits\", defaultValue: 16 },\n            { name: \"normFreq\", defaultValue: 0.9 },\n        ];\n    }\n\n    get defaultParameterDescriptors() {\n        return BitCrusherProcessor.parameterDescriptors;\n    }\n\n    process(inputs: Float32Array[][], outputs: Float32Array[][], parameters: Record<string, Float32Array>): boolean {\n        if (this.stopped) return false;\n\n        const input = inputs[0];\n        const output = outputs[0];\n\n        const step = 2 * Math.pow(1 / 2, parameters.bits[0]);\n        const currentNormFreq = (1 - parameters.normFreq[0]) / (sampleRate / 48000);\n\n        if (this.last == null) {\n            this.last = new Array(input.length).fill(0);\n        }\n\n        if (this.phaser == null) {\n            this.phaser = new Array(input.length).fill(0);\n        }\n\n        if (input && input[0]) {\n            const blockSize = input[0].length;\n\n            for (let channel = 0; channel < input.length; channel++) {\n                const inp = input[channel];\n                const out = output[channel];\n\n                if (inp) {\n                    for (let i = 0; i < blockSize; i++) {\n                        this.phaser[channel] += currentNormFreq;\n\n                        if (this.phaser[channel] >= 1.0) {\n                            this.phaser[channel] -= 1.0;\n                            this.last[channel] = step * Math.floor((inp[i] * (1 / step)) + 0.5);\n                        }\n\n                        out[i] = this.last[channel];\n                    }\n                }\n            }\n        }\n\n        return true;\n    }\n\n    stop() {\n        this.stopped = true;\n        this.phaser = null;\n        this.last = null;\n    }\n}\n\nregisterProcessor(Constants.WORKLET_NAMES.BITCRUSHER, BitCrusherProcessor);\n","import AbstractAudioFilterWorklet from \"./interfaces/AbstractAudioFilterWorklet\";\nimport Constants from \"../model/Constants\";\nimport BitCrusherSettings from \"../model/filtersSettings/BitCrusherSettings\";\nimport { FilterSettingValue } from \"../model/filtersSettings/FilterSettings\";\nimport \"./worklets/BitCrusher.worklet\";\nimport utilFunctions from \"../utils/Functions\";\n\nexport default class BitCrusherFilter extends AbstractAudioFilterWorklet {\n    private bits = 16;\n    private normFreq = 0.9;\n\n    constructor(bits: number, normFreq: number) {\n        super();\n        this.bits = bits;\n        this.normFreq = normFreq;\n    }\n\n    get workletPath(): string {\n        return Constants.WORKLET_PATHS.BITCRUSHER;\n    }\n    \n    get workletName(): string {\n        return Constants.WORKLET_NAMES.BITCRUSHER;\n    }\n\n    get order(): number {\n        return 6;\n    }\n\n    get id(): string {\n        return Constants.FILTERS_NAMES.BITCRUSHER;\n    }\n\n    getSettings(): BitCrusherSettings {\n        return {\n            bits: this.bits,\n            normFreq: this.normFreq,\n        };\n    }\n\n    async setSetting(settingId: string, value: FilterSettingValue) {\n        if(!utilFunctions.isSettingValueValid(value)) {\n            return;\n        }\n\n        switch (settingId) {\n        case \"bits\":\n            this.bits = parseInt(value as string);\n            break;\n        case \"normFreq\":\n            this.normFreq = parseFloat(value as string);\n            break;\n        }\n\n        this.applyCurrentSettingsToWorklet();\n    }\n}\n","import AbstractAudioFilter from \"./interfaces/AbstractAudioFilter\";\nimport Constants from \"../model/Constants\";\nimport EchoSettings from \"../model/filtersSettings/EchoSettings\";\nimport { FilterSettingValue } from \"../model/filtersSettings/FilterSettings\";\nimport utilFunctions from \"../utils/Functions\";\n\nexport default class EchoFilter extends AbstractAudioFilter {\n    private delay = 0.2;\n    private gain = 0.75;\n\n    constructor(delay: number, gain: number) {\n        super();\n        this.delay = delay;\n        this.gain = gain;\n    }\n\n    getNode(context: BaseAudioContext) {\n        const delayNode = context.createDelay(179);\n        delayNode.delayTime.value = this.delay;\n\n        const gainNode = context.createGain();\n        gainNode.gain.value = this.gain;\n\n        gainNode.connect(delayNode);\n        delayNode.connect(gainNode);\n\n        return {\n            input: gainNode,\n            output: delayNode\n        };\n    }\n    \n    get order(): number {\n        return 7;\n    }\n\n    get id(): string {\n        return Constants.FILTERS_NAMES.ECHO;\n    }\n\n    getAddingTime() {\n        return 5;\n    }\n\n    getSettings(): EchoSettings {\n        return {\n            delay: this.delay,\n            gain: this.gain\n        };\n    }\n\n    async setSetting(settingId: string, value: FilterSettingValue) {\n        if(!utilFunctions.isSettingValueValid(value)) {\n            return;\n        }\n        \n        switch(settingId) {\n        case \"delay\":\n            this.delay = parseFloat(value as string);\n            break;\n        case \"gain\":\n            this.gain = parseFloat(value as string);\n            break;\n        }\n    }\n}\n","import AbstractAudioFilter from \"./interfaces/AbstractAudioFilter\";\nimport Constants from \"../model/Constants\";\nimport HighPassSettings from \"../model/filtersSettings/HighPassSettings\";\nimport { FilterSettingValue } from \"../model/filtersSettings/FilterSettings\";\nimport utilFunctions from \"../utils/Functions\";\n\nexport default class HighPassFilter extends AbstractAudioFilter {\n    private highFrequency = 3500;\n\n    constructor(highFrequency: number) {\n        super();\n        this.highFrequency = highFrequency;\n    }\n\n    getNode(context: BaseAudioContext) {\n        const highPassFilter = context.createBiquadFilter();\n        highPassFilter.type = \"highpass\";\n        highPassFilter.frequency.value = this.highFrequency;\n\n        return {\n            input: highPassFilter,\n            output: highPassFilter\n        };\n    }\n    \n    get order(): number {\n        return 4;\n    }\n\n    get id(): string {\n        return Constants.FILTERS_NAMES.HIGH_PASS;\n    }\n\n    getSettings(): HighPassSettings {\n        return {\n            highFrequency: this.highFrequency\n        };\n    }\n\n    async setSetting(settingId: string, value: FilterSettingValue) {\n        if(!utilFunctions.isSettingValueValid(value)) {\n            return;\n        }\n        \n        switch(settingId) {\n        case \"highFrequency\":\n            this.highFrequency = parseInt(value as string);\n            break;\n        }\n    }\n}\n","export default class DelayBuffer {\n    private _array: Float32Array = new Float32Array();\n    private n: number = 0;\n    private length: number = 0;\n    private readPointer: number = 0;\n    private writePointer: number = 0;\n\n    constructor(n: number) {\n        this.n = Math.floor(n);\n        this.init();\n    }\n\n    init() {\n        this._array = new Float32Array(2 * this.n);\n        this.length = this._array.length;\n        this.readPointer = 0;\n        this.writePointer = this.n - 1;\n\n        for (let i = 0; i < this.length; i++) {\n            this._array[i] = 0;\n        }\n    }\n\n    read() {\n        const value = this._array[this.readPointer % this.length];\n        this.readPointer++;\n        return value;\n    }\n\n    push(v: number) {\n        this._array[this.writePointer % this.length] = v;\n        this.writePointer++;\n    }\n\n    reset() {\n        this.init();\n    }\n\n    clear() {\n        this._array = new Float32Array();\n        this.length = 0;\n        this.readPointer = 0;\n        this.writePointer = 0;\n    }\n}\n","/*\n * Copyright (C) 2019-2023 Eliastik (eliastiksofts.com)\n *\n * This file is part of \"Simple Voice Changer\".\n *\n * \"Simple Voice Changer\" is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * \"Simple Voice Changer\" is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with \"Simple Voice Changer\".  If not, see <http://www.gnu.org/licenses/>.\n */\n// Source: https://webaudiotech.com/2016/01/21/should-your-web-audio-app-have-a-limiter/\n// Original code: https://webaudiotech.com/sites/limiter_comparison/limiter.js\n// Additions by Eliastik (eliastiksofts.com): Stereo and multi-channel support, code simplified in one object class (Limiter), converted into AudioWorklet\nimport Constants from \"../../model/Constants\";\nimport DelayBuffer from \"../../utils/DelayBuffer\";\n\nclass LimiterProcessor extends AudioWorkletProcessor {\n    private delayBuffer: DelayBuffer[] = [];\n    private envelopeSample = 0;\n    private stopped = false;\n    private disabled = false;\n\n    constructor() {\n        super();\n        this.port.onmessage = (event) => {\n            if (event.data == \"reset\") {\n                this.reset();\n            } else if (event.data == \"stop\") {\n                this.stop();\n            } else if (event.data == \"disable\") {\n                this.disabled = true;\n            } else if (event.data == \"enable\") {\n                this.disabled = false;\n            }\n        };\n    }\n\n    static get parameterDescriptors() {\n        return [\n            { name: \"preGain\", defaultValue: 0 },\n            { name: \"postGain\", defaultValue: 0 },\n            { name: \"attackTime\", defaultValue: 0 },\n            { name: \"releaseTime\", defaultValue: 3 },\n            { name: \"threshold\", defaultValue: -0.05 },\n            { name: \"lookAheadTime\", defaultValue: 0 }\n        ];\n    }\n\n    get defaultParameterDescriptors() {\n        return LimiterProcessor.parameterDescriptors;\n    }\n\n    getEnvelope(data: Float32Array, attackTime: number, releaseTime: number, sampleRate: number) {\n        const attackGain = Math.exp(-1 / (sampleRate * attackTime));\n        const releaseGain = Math.exp(-1 / (sampleRate * releaseTime));\n\n        const envelope = new Float32Array(data.length);\n\n        for (let i = 0; i < data.length; i++) {\n            const envIn = Math.abs(data[i]);\n\n            if (this.envelopeSample < envIn) {\n                this.envelopeSample = envIn + attackGain * (this.envelopeSample - envIn);\n            } else {\n                this.envelopeSample = envIn + releaseGain * (this.envelopeSample - envIn);\n            }\n\n            envelope[i] = this.envelopeSample;\n        }\n\n        return envelope;\n    }\n\n    getMaxEnvelope(envelope: Float32Array[], channels: number, index: number) {\n        let max = envelope[0][index];\n\n        for (let channel = 0; channel < channels; channel++) {\n            if (envelope[channel][index] > max) {\n                max = envelope[channel][index];\n            }\n        }\n\n        return max;\n    }\n\n    ampToDB(value: number) {\n        return 20 * Math.log10(value);\n    }\n\n    dBToAmp(db: number) {\n        return Math.pow(10, db / 20);\n    }\n\n    process(inputs: Float32Array[][], outputs: Float32Array[][], parameters: Record<string, Float32Array>): boolean {\n        if (this.stopped) return false;\n\n        const inputBuffer = inputs[0];\n        const outputBuffer = outputs[0];\n        const envelopeData = [];\n\n        // transform db to amplitude value\n        const postGainAmp = this.dBToAmp(parameters.postGain[0]);\n        const preGainAmp = this.dBToAmp(parameters.preGain[0]);\n\n        // apply pre gain to signal\n        // compute the envelope for each channel\n        for (let channel = 0; channel < outputBuffer.length; channel++) {\n            const inp = inputBuffer[channel];\n            const out = outputBuffer[channel];\n\n            // create a delay buffer\n            if (this.delayBuffer[channel] == null) {\n                this.delayBuffer[channel] = new DelayBuffer(parameters.lookAheadTime[0] * sampleRate);\n            }\n\n            // apply pre gain to signal\n            if (inp) {\n                for (let k = 0; k < inp.length; ++k) {\n                    out[k] = preGainAmp * inp[k];\n                }\n            }\n\n            // compute the envelope\n            if (!this.disabled) {\n                envelopeData[channel] = this.getEnvelope(out, parameters.attackTime[0], parameters.releaseTime[0], sampleRate);\n            }\n        }\n\n        for (let channel = 0; channel < outputBuffer.length; channel++) {\n            const inp = inputBuffer[channel];\n            const out = outputBuffer[channel];\n\n            if (parameters.lookAheadTime[0] > 0) {\n                // write signal into buffer and read delayed signal\n                for (let i = 0; i < out.length; i++) {\n                    this.delayBuffer[channel].push(out[i]);\n                    out[i] = this.delayBuffer[channel].read();\n                }\n            }\n\n            // If disabled we don't apply the limitation to the audio\n            if (this.disabled) {\n                continue;\n            }\n\n            // limiter mode: slope is 1\n            const slope = 1;\n\n            if (inp) {\n                for (let i = 0; i < inp.length; i++) {\n                    let gainDB = slope * (parameters.threshold[0] - this.ampToDB(this.getMaxEnvelope(envelopeData, outputBuffer.length, i))); // max gain\n\n                    // is gain below zero?\n                    gainDB = Math.min(0, gainDB);\n                    const gain = this.dBToAmp(gainDB);\n                    out[i] *= (gain * postGainAmp);\n                }\n            }\n        }\n\n        return true;\n    }\n\n    reset() {\n        for (let i = 0; i < this.delayBuffer.length; i++) {\n            if (this.delayBuffer[i] != null) {\n                this.delayBuffer[i].reset();\n            }\n        }\n\n        this.envelopeSample = 0;\n    }\n\n    stop() {\n        for (let i = 0; i < this.delayBuffer.length; i++) {\n            if (this.delayBuffer[i] != null) {\n                this.delayBuffer[i].clear();\n            }\n        }\n\n        this.delayBuffer = [];\n        this.envelopeSample = 0;\n        this.stopped = true;\n    }\n}\n\nregisterProcessor(Constants.WORKLET_NAMES.LIMITER, LimiterProcessor);\n","import AbstractAudioFilterWorklet from \"./interfaces/AbstractAudioFilterWorklet\";\nimport Constants from \"../model/Constants\";\nimport LimiterSettings from \"../model/filtersSettings/LimiterSettings\";\nimport { FilterSettingValue } from \"../model/filtersSettings/FilterSettings\";\nimport \"./worklets/Limiter.worklet\";\nimport utilFunctions from \"../utils/Functions\";\n\nexport default class LimiterFilter extends AbstractAudioFilterWorklet {\n    private preGain = 0; // dB\n    private postGain = 0; // dB\n    private attackTime = 0; // s\n    private releaseTime = 3; // s\n    private threshold = -0.05; // dB\n    private lookAheadTime = 0.1; // s\n\n    constructor(preGain: number, postGain: number, attackTime: number, releaseTime: number, threshold: number, lookAheadTime: number) {\n        super();\n        this.preGain = preGain || this.preGain;\n        this.postGain = postGain || this.postGain;\n        this.attackTime = attackTime || this.attackTime;\n        this.releaseTime = releaseTime || this.releaseTime;\n        this.threshold = threshold || this.threshold;\n        this.lookAheadTime = lookAheadTime || this.lookAheadTime;\n        this.keepCurrentNodeIfPossible = true;\n        this.enable();\n        this.setDefaultEnabled(true);\n    }\n\n    get workletPath(): string {\n        return Constants.WORKLET_PATHS.LIMITER;\n    }\n    \n    get workletName(): string {\n        return Constants.WORKLET_NAMES.LIMITER;\n    }\n\n    get order(): number {\n        return 10;\n    }\n\n    get id(): string {\n        return Constants.FILTERS_NAMES.LIMITER;\n    }\n\n    getAddingTime() {\n        return this.lookAheadTime;\n    }\n\n    getSettings(): LimiterSettings {\n        return {\n            preGain: this.preGain,\n            postGain: this.postGain,\n            attackTime: this.attackTime,\n            releaseTime: this.releaseTime,\n            threshold: this.threshold,\n            lookAheadTime: this.lookAheadTime\n        };\n    }\n\n    async setSetting(settingId: string, value: FilterSettingValue) {\n        if(!utilFunctions.isSettingValueValid(value)) {\n            return;\n        }\n        \n        switch (settingId) {\n        case \"preGain\":\n            this.preGain = parseFloat(value as string);\n            break;\n        case \"postGain\":\n            this.postGain = parseFloat(value as string);\n            break;\n        case \"attackTime\":\n            this.attackTime = parseFloat(value as string);\n            break;\n        case \"releaseTime\":\n            this.releaseTime = parseFloat(value as string);\n            break;\n        case \"threshold\":\n            this.threshold = parseFloat(value as string);\n            break;\n        case \"lookAheadTime\":\n            this.lookAheadTime = parseFloat(value as string);\n            break;\n        }\n\n        this.applyCurrentSettingsToWorklet();\n    }\n}\n","import AbstractAudioFilter from \"./interfaces/AbstractAudioFilter\";\nimport Constants from \"../model/Constants\";\nimport LowPassSettings from \"../model/filtersSettings/LowPassSettings\";\nimport { FilterSettingValue } from \"../model/filtersSettings/FilterSettings\";\nimport utilFunctions from \"../utils/Functions\";\n\nexport default class LowPassFilter extends AbstractAudioFilter {\n    private lowFrequency = 3500;\n\n    constructor(lowFrequency: number) {\n        super();\n        this.lowFrequency = lowFrequency;\n    }\n    \n    getNode(context: BaseAudioContext) {\n        const lowPassFilter = context.createBiquadFilter();\n        lowPassFilter.type = \"lowpass\";\n        lowPassFilter.frequency.value = this.lowFrequency;\n\n        return {\n            input: lowPassFilter,\n            output: lowPassFilter\n        };\n    }\n    \n    get order(): number {\n        return 5;\n    }\n\n    get id(): string {\n        return Constants.FILTERS_NAMES.LOW_PASS;\n    }\n\n    getSettings(): LowPassSettings {\n        return {\n            lowFrequency: this.lowFrequency\n        };\n    }\n\n    async setSetting(settingId: string, value: FilterSettingValue) {\n        if(!utilFunctions.isSettingValueValid(value)) {\n            return;\n        }\n        \n        switch (settingId) {\n        case \"lowFrequency\":\n            this.lowFrequency = parseInt(value as string);\n            break;\n        }\n    }\n}\n","import AbstractAudioElement from \"./AbstractAudioElement\";\n\nexport default abstract class AbstractAudioRenderer extends AbstractAudioElement {\n    /** Render an AudioBuffer based on another input AudioBuffer */\n    abstract renderAudio(context: BaseAudioContext, buffer: AudioBuffer): Promise<AudioBuffer>;\n}","import AbstractAudioRenderer from \"./interfaces/AbstractAudioRenderer\";\nimport Constants from \"../model/Constants\";\n\nexport default class ReturnAudioRenderer extends AbstractAudioRenderer {\n    renderAudio(context: BaseAudioContext, buffer: AudioBuffer): Promise<AudioBuffer> {\n        return new Promise(resolve => {\n            const numChannels = buffer.numberOfChannels;\n            const totalFrames = context.sampleRate * buffer.duration + context.sampleRate * 2;\n            const bufferReturned = context.createBuffer(numChannels, totalFrames, context.sampleRate);\n\n            for (let channel = 0; channel < numChannels; channel++) {\n                const nowBuffering = bufferReturned.getChannelData(channel);\n                const sourceChannelData = buffer.getChannelData(channel);\n\n                for (let i = 0; i < totalFrames; i++) {\n                    if (i < sourceChannelData.length) {\n                        nowBuffering[i] = sourceChannelData[sourceChannelData.length - 1 - i];\n                    } else {\n                        nowBuffering[i] = 0;\n                    }\n                }\n            }\n\n            resolve(bufferReturned);\n        });\n    }\n\n    get order(): number {\n        return 0;\n    }\n\n    get id(): string {\n        return Constants.FILTERS_NAMES.RETURN_AUDIO;\n    }\n}\n","import AbstractAudioFilter from \"./interfaces/AbstractAudioFilter\";\nimport Constants from \"../model/Constants\";\nimport { ReverbEnvironment } from \"../model/ReverbEnvironment\";\nimport ReverbSettings from \"../model/filtersSettings/ReverbSettings\";\nimport GenericSettingValue from \"../model/filtersSettings/GenericSettingValue\";\nimport { FilterSettingValue } from \"../model/filtersSettings/FilterSettings\";\n\nexport default class ReverbFilter extends AbstractAudioFilter {\n    private reverbEnvironment: ReverbEnvironment = Constants.DEFAULT_REVERB_ENVIRONMENT;\n\n    getNode(context: BaseAudioContext) {\n        const convolver = context.createConvolver();\n\n        if(this.bufferFetcherService) {\n            convolver.buffer = this.bufferFetcherService.getAudioBuffer(this.reverbEnvironment.url)!;\n        }\n\n        return {\n            input: convolver,\n            output: convolver\n        };\n    }\n    \n    get order(): number {\n        return 9;\n    }\n\n    get id(): string {\n        return Constants.FILTERS_NAMES.REVERB;\n    }\n\n    getAddingTime() {\n        const settings = this.getSettings();\n\n        if(settings && settings.reverbEnvironment && settings.reverbEnvironment.additionalData) {\n            return settings.reverbEnvironment.additionalData.addDuration as number;\n        }\n\n        return 0;\n    }\n\n    getSettings(): ReverbSettings {\n        if(!this.reverbEnvironment) {\n            return {};\n        }\n\n        return {\n            reverbEnvironment: {\n                name: this.reverbEnvironment.name,\n                value: this.reverbEnvironment.url,\n                additionalData: {\n                    size: this.reverbEnvironment.size,\n                    link: this.reverbEnvironment.link,\n                    addDuration: this.reverbEnvironment.addDuration\n                }\n            },\n            downloadedBuffers: this.bufferFetcherService?.getDownloadedBuffersList()\n        };\n    }\n\n    async setSetting(settingId: string, value: FilterSettingValue) {\n        if(settingId == \"reverbEnvironment\") {\n            const reverbEnvironment = value as GenericSettingValue;\n\n            if(reverbEnvironment) {\n                const url = reverbEnvironment.value;\n    \n                try {\n                    await this.bufferFetcherService?.fetchBuffer(url);\n    \n                    if(reverbEnvironment.additionalData) {\n                        this.reverbEnvironment = {\n                            name: reverbEnvironment.name,\n                            url,\n                            size: reverbEnvironment.additionalData.size as number,\n                            addDuration: reverbEnvironment.additionalData.addDuration as number,\n                            link: reverbEnvironment.additionalData.link as string\n                        };\n                    } else {\n                        this.reverbEnvironment = {\n                            name: reverbEnvironment.name,\n                            url,\n                            size: 0,\n                            addDuration: 0,\n                            link: \"\"\n                        };\n                    }\n                } catch(e) { /* empty */ }\n            }\n        }\n    }\n}\n","/*\n * SoundTouch JS v0.1.30 audio processing library\n * Copyright (c) Olli Parviainen\n * Copyright (c) Ryan Berdeen\n * Copyright (c) Jakub Fiala\n * Copyright (c) Steve 'Cutter' Blades\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\nclass FifoSampleBuffer {\n  constructor() {\n    this._vector = new Float32Array();\n    this._position = 0;\n    this._frameCount = 0;\n  }\n  get vector() {\n    return this._vector;\n  }\n  get position() {\n    return this._position;\n  }\n  get startIndex() {\n    return this._position * 2;\n  }\n  get frameCount() {\n    return this._frameCount;\n  }\n  get endIndex() {\n    return (this._position + this._frameCount) * 2;\n  }\n  clear() {\n    this.receive(this._frameCount);\n    this.rewind();\n  }\n  put(numFrames) {\n    this._frameCount += numFrames;\n  }\n  putSamples(samples, position, numFrames = 0) {\n    position = position || 0;\n    const sourceOffset = position * 2;\n    if (!(numFrames >= 0)) {\n      numFrames = (samples.length - sourceOffset) / 2;\n    }\n    const numSamples = numFrames * 2;\n    this.ensureCapacity(numFrames + this._frameCount);\n    const destOffset = this.endIndex;\n    this.vector.set(samples.subarray(sourceOffset, sourceOffset + numSamples), destOffset);\n    this._frameCount += numFrames;\n  }\n  putBuffer(buffer, position, numFrames = 0) {\n    position = position || 0;\n    if (!(numFrames >= 0)) {\n      numFrames = buffer.frameCount - position;\n    }\n    this.putSamples(buffer.vector, buffer.position + position, numFrames);\n  }\n  receive(numFrames) {\n    if (!(numFrames >= 0) || numFrames > this._frameCount) {\n      numFrames = this.frameCount;\n    }\n    this._frameCount -= numFrames;\n    this._position += numFrames;\n  }\n  receiveSamples(output, numFrames = 0) {\n    const numSamples = numFrames * 2;\n    const sourceOffset = this.startIndex;\n    output.set(this._vector.subarray(sourceOffset, sourceOffset + numSamples));\n    this.receive(numFrames);\n  }\n  extract(output, position = 0, numFrames = 0) {\n    const sourceOffset = this.startIndex + position * 2;\n    const numSamples = numFrames * 2;\n    output.set(this._vector.subarray(sourceOffset, sourceOffset + numSamples));\n  }\n  ensureCapacity(numFrames = 0) {\n    const minLength = parseInt(numFrames * 2);\n    if (this._vector.length < minLength) {\n      const newVector = new Float32Array(minLength);\n      newVector.set(this._vector.subarray(this.startIndex, this.endIndex));\n      this._vector = newVector;\n      this._position = 0;\n    } else {\n      this.rewind();\n    }\n  }\n  ensureAdditionalCapacity(numFrames = 0) {\n    this.ensureCapacity(this._frameCount + numFrames);\n  }\n  rewind() {\n    if (this._position > 0) {\n      this._vector.set(this._vector.subarray(this.startIndex, this.endIndex));\n      this._position = 0;\n    }\n  }\n}\n\nclass AbstractFifoSamplePipe {\n  constructor(createBuffers) {\n    if (createBuffers) {\n      this._inputBuffer = new FifoSampleBuffer();\n      this._outputBuffer = new FifoSampleBuffer();\n    } else {\n      this._inputBuffer = this._outputBuffer = null;\n    }\n  }\n  get inputBuffer() {\n    return this._inputBuffer;\n  }\n  set inputBuffer(inputBuffer) {\n    this._inputBuffer = inputBuffer;\n  }\n  get outputBuffer() {\n    return this._outputBuffer;\n  }\n  set outputBuffer(outputBuffer) {\n    this._outputBuffer = outputBuffer;\n  }\n  clear() {\n    this._inputBuffer.clear();\n    this._outputBuffer.clear();\n  }\n}\n\nclass RateTransposer extends AbstractFifoSamplePipe {\n  constructor(createBuffers) {\n    super(createBuffers);\n    this.reset();\n    this._rate = 1;\n  }\n  set rate(rate) {\n    this._rate = rate;\n  }\n  reset() {\n    this.slopeCount = 0;\n    this.prevSampleL = 0;\n    this.prevSampleR = 0;\n  }\n  clone() {\n    const result = new RateTransposer();\n    result.rate = this._rate;\n    return result;\n  }\n  process() {\n    const numFrames = this._inputBuffer.frameCount;\n    this._outputBuffer.ensureAdditionalCapacity(numFrames / this._rate + 1);\n    const numFramesOutput = this.transpose(numFrames);\n    this._inputBuffer.receive();\n    this._outputBuffer.put(numFramesOutput);\n  }\n  transpose(numFrames = 0) {\n    if (numFrames === 0) {\n      return 0;\n    }\n    const src = this._inputBuffer.vector;\n    const srcOffset = this._inputBuffer.startIndex;\n    const dest = this._outputBuffer.vector;\n    const destOffset = this._outputBuffer.endIndex;\n    let used = 0;\n    let i = 0;\n    while (this.slopeCount < 1.0) {\n      dest[destOffset + 2 * i] = (1.0 - this.slopeCount) * this.prevSampleL + this.slopeCount * src[srcOffset];\n      dest[destOffset + 2 * i + 1] = (1.0 - this.slopeCount) * this.prevSampleR + this.slopeCount * src[srcOffset + 1];\n      i = i + 1;\n      this.slopeCount += this._rate;\n    }\n    this.slopeCount -= 1.0;\n    if (numFrames !== 1) {\n      out: while (true) {\n        while (this.slopeCount > 1.0) {\n          this.slopeCount -= 1.0;\n          used = used + 1;\n          if (used >= numFrames - 1) {\n            break out;\n          }\n        }\n        const srcIndex = srcOffset + 2 * used;\n        dest[destOffset + 2 * i] = (1.0 - this.slopeCount) * src[srcIndex] + this.slopeCount * src[srcIndex + 2];\n        dest[destOffset + 2 * i + 1] = (1.0 - this.slopeCount) * src[srcIndex + 1] + this.slopeCount * src[srcIndex + 3];\n        i = i + 1;\n        this.slopeCount += this._rate;\n      }\n    }\n    this.prevSampleL = src[srcOffset + 2 * numFrames - 2];\n    this.prevSampleR = src[srcOffset + 2 * numFrames - 1];\n    return i;\n  }\n}\n\nclass FilterSupport {\n  constructor(pipe) {\n    this._pipe = pipe;\n  }\n  get pipe() {\n    return this._pipe;\n  }\n  get inputBuffer() {\n    return this._pipe.inputBuffer;\n  }\n  get outputBuffer() {\n    return this._pipe.outputBuffer;\n  }\n  fillInputBuffer() {\n    throw new Error('fillInputBuffer() not overridden');\n  }\n  fillOutputBuffer(numFrames = 0) {\n    while (this.outputBuffer.frameCount < numFrames) {\n      const numInputFrames = 8192 * 2 - this.inputBuffer.frameCount;\n      this.fillInputBuffer(numInputFrames);\n      if (this.inputBuffer.frameCount < 8192 * 2) {\n        break;\n      }\n      this._pipe.process();\n    }\n  }\n  clear() {\n    this._pipe.clear();\n  }\n}\n\nconst noop = function () {\n  return;\n};\n\nclass SimpleFilter extends FilterSupport {\n  constructor(sourceSound, pipe, callback = noop) {\n    super(pipe);\n    this.callback = callback;\n    this.sourceSound = sourceSound;\n    this.historyBufferSize = 22050;\n    this._sourcePosition = 0;\n    this.outputBufferPosition = 0;\n    this._position = 0;\n  }\n  get position() {\n    return this._position;\n  }\n  set position(position) {\n    if (position > this._position) {\n      throw new RangeError('New position may not be greater than current position');\n    }\n    const newOutputBufferPosition = this.outputBufferPosition - (this._position - position);\n    if (newOutputBufferPosition < 0) {\n      throw new RangeError('New position falls outside of history buffer');\n    }\n    this.outputBufferPosition = newOutputBufferPosition;\n    this._position = position;\n  }\n  get sourcePosition() {\n    return this._sourcePosition;\n  }\n  set sourcePosition(sourcePosition) {\n    this.clear();\n    this._sourcePosition = sourcePosition;\n  }\n  onEnd() {\n    this.callback();\n  }\n  fillInputBuffer(numFrames = 0) {\n    const samples = new Float32Array(numFrames * 2);\n    const numFramesExtracted = this.sourceSound.extract(samples, numFrames, this._sourcePosition);\n    this._sourcePosition += numFramesExtracted;\n    this.inputBuffer.putSamples(samples, 0, numFramesExtracted);\n  }\n  extract(target, numFrames = 0) {\n    this.fillOutputBuffer(this.outputBufferPosition + numFrames);\n    const numFramesExtracted = Math.min(numFrames, this.outputBuffer.frameCount - this.outputBufferPosition);\n    this.outputBuffer.extract(target, this.outputBufferPosition, numFramesExtracted);\n    const currentFrames = this.outputBufferPosition + numFramesExtracted;\n    this.outputBufferPosition = Math.min(this.historyBufferSize, currentFrames);\n    this.outputBuffer.receive(Math.max(currentFrames - this.historyBufferSize, 0));\n    this._position += numFramesExtracted;\n    return numFramesExtracted;\n  }\n  handleSampleData(event) {\n    this.extract(event.data, 4096);\n  }\n  clear() {\n    super.clear();\n    this.outputBufferPosition = 0;\n  }\n}\n\nconst USE_AUTO_SEQUENCE_LEN = 0;\nconst DEFAULT_SEQUENCE_MS = USE_AUTO_SEQUENCE_LEN;\nconst USE_AUTO_SEEKWINDOW_LEN = 0;\nconst DEFAULT_SEEKWINDOW_MS = USE_AUTO_SEEKWINDOW_LEN;\nconst DEFAULT_OVERLAP_MS = 8;\nconst _SCAN_OFFSETS = [[124, 186, 248, 310, 372, 434, 496, 558, 620, 682, 744, 806, 868, 930, 992, 1054, 1116, 1178, 1240, 1302, 1364, 1426, 1488, 0], [-100, -75, -50, -25, 25, 50, 75, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [-20, -15, -10, -5, 5, 10, 15, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [-4, -3, -2, -1, 1, 2, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]];\nconst AUTOSEQ_TEMPO_LOW = 0.5;\nconst AUTOSEQ_TEMPO_TOP = 2.0;\nconst AUTOSEQ_AT_MIN = 125.0;\nconst AUTOSEQ_AT_MAX = 50.0;\nconst AUTOSEQ_K = (AUTOSEQ_AT_MAX - AUTOSEQ_AT_MIN) / (AUTOSEQ_TEMPO_TOP - AUTOSEQ_TEMPO_LOW);\nconst AUTOSEQ_C = AUTOSEQ_AT_MIN - AUTOSEQ_K * AUTOSEQ_TEMPO_LOW;\nconst AUTOSEEK_AT_MIN = 25.0;\nconst AUTOSEEK_AT_MAX = 15.0;\nconst AUTOSEEK_K = (AUTOSEEK_AT_MAX - AUTOSEEK_AT_MIN) / (AUTOSEQ_TEMPO_TOP - AUTOSEQ_TEMPO_LOW);\nconst AUTOSEEK_C = AUTOSEEK_AT_MIN - AUTOSEEK_K * AUTOSEQ_TEMPO_LOW;\nclass Stretch extends AbstractFifoSamplePipe {\n  constructor(createBuffers) {\n    super(createBuffers);\n    this._quickSeek = true;\n    this.midBufferDirty = false;\n    this.midBuffer = null;\n    this.overlapLength = 0;\n    this.autoSeqSetting = true;\n    this.autoSeekSetting = true;\n    this._tempo = 1;\n    this.setParameters(44100, DEFAULT_SEQUENCE_MS, DEFAULT_SEEKWINDOW_MS, DEFAULT_OVERLAP_MS);\n  }\n  clear() {\n    super.clear();\n    this.clearMidBuffer();\n  }\n  clearMidBuffer() {\n    if (this.midBufferDirty) {\n      this.midBufferDirty = false;\n      this.midBuffer = null;\n    }\n  }\n  setParameters(sampleRate, sequenceMs, seekWindowMs, overlapMs) {\n    if (sampleRate > 0) {\n      this.sampleRate = sampleRate;\n    }\n    if (overlapMs > 0) {\n      this.overlapMs = overlapMs;\n    }\n    if (sequenceMs > 0) {\n      this.sequenceMs = sequenceMs;\n      this.autoSeqSetting = false;\n    } else {\n      this.autoSeqSetting = true;\n    }\n    if (seekWindowMs > 0) {\n      this.seekWindowMs = seekWindowMs;\n      this.autoSeekSetting = false;\n    } else {\n      this.autoSeekSetting = true;\n    }\n    this.calculateSequenceParameters();\n    this.calculateOverlapLength(this.overlapMs);\n    this.tempo = this._tempo;\n  }\n  set tempo(newTempo) {\n    let intskip;\n    this._tempo = newTempo;\n    this.calculateSequenceParameters();\n    this.nominalSkip = this._tempo * (this.seekWindowLength - this.overlapLength);\n    this.skipFract = 0;\n    intskip = Math.floor(this.nominalSkip + 0.5);\n    this.sampleReq = Math.max(intskip + this.overlapLength, this.seekWindowLength) + this.seekLength;\n  }\n  get tempo() {\n    return this._tempo;\n  }\n  get inputChunkSize() {\n    return this.sampleReq;\n  }\n  get outputChunkSize() {\n    return this.overlapLength + Math.max(0, this.seekWindowLength - 2 * this.overlapLength);\n  }\n  calculateOverlapLength(overlapInMsec = 0) {\n    let newOvl;\n    newOvl = this.sampleRate * overlapInMsec / 1000;\n    newOvl = newOvl < 16 ? 16 : newOvl;\n    newOvl -= newOvl % 8;\n    this.overlapLength = newOvl;\n    this.refMidBuffer = new Float32Array(this.overlapLength * 2);\n    this.midBuffer = new Float32Array(this.overlapLength * 2);\n  }\n  checkLimits(x, mi, ma) {\n    return x < mi ? mi : x > ma ? ma : x;\n  }\n  calculateSequenceParameters() {\n    let seq;\n    let seek;\n    if (this.autoSeqSetting) {\n      seq = AUTOSEQ_C + AUTOSEQ_K * this._tempo;\n      seq = this.checkLimits(seq, AUTOSEQ_AT_MAX, AUTOSEQ_AT_MIN);\n      this.sequenceMs = Math.floor(seq + 0.5);\n    }\n    if (this.autoSeekSetting) {\n      seek = AUTOSEEK_C + AUTOSEEK_K * this._tempo;\n      seek = this.checkLimits(seek, AUTOSEEK_AT_MAX, AUTOSEEK_AT_MIN);\n      this.seekWindowMs = Math.floor(seek + 0.5);\n    }\n    this.seekWindowLength = Math.floor(this.sampleRate * this.sequenceMs / 1000);\n    this.seekLength = Math.floor(this.sampleRate * this.seekWindowMs / 1000);\n  }\n  set quickSeek(enable) {\n    this._quickSeek = enable;\n  }\n  clone() {\n    const result = new Stretch();\n    result.tempo = this._tempo;\n    result.setParameters(this.sampleRate, this.sequenceMs, this.seekWindowMs, this.overlapMs);\n    return result;\n  }\n  seekBestOverlapPosition() {\n    return this._quickSeek ? this.seekBestOverlapPositionStereoQuick() : this.seekBestOverlapPositionStereo();\n  }\n  seekBestOverlapPositionStereo() {\n    let bestOffset;\n    let bestCorrelation;\n    let correlation;\n    let i = 0;\n    this.preCalculateCorrelationReferenceStereo();\n    bestOffset = 0;\n    bestCorrelation = Number.MIN_VALUE;\n    for (; i < this.seekLength; i = i + 1) {\n      correlation = this.calculateCrossCorrelationStereo(2 * i, this.refMidBuffer);\n      if (correlation > bestCorrelation) {\n        bestCorrelation = correlation;\n        bestOffset = i;\n      }\n    }\n    return bestOffset;\n  }\n  seekBestOverlapPositionStereoQuick() {\n    let bestOffset;\n    let bestCorrelation;\n    let correlation;\n    let scanCount = 0;\n    let correlationOffset;\n    let tempOffset;\n    this.preCalculateCorrelationReferenceStereo();\n    bestCorrelation = Number.MIN_VALUE;\n    bestOffset = 0;\n    correlationOffset = 0;\n    tempOffset = 0;\n    for (; scanCount < 4; scanCount = scanCount + 1) {\n      let j = 0;\n      while (_SCAN_OFFSETS[scanCount][j]) {\n        tempOffset = correlationOffset + _SCAN_OFFSETS[scanCount][j];\n        if (tempOffset >= this.seekLength) {\n          break;\n        }\n        correlation = this.calculateCrossCorrelationStereo(2 * tempOffset, this.refMidBuffer);\n        if (correlation > bestCorrelation) {\n          bestCorrelation = correlation;\n          bestOffset = tempOffset;\n        }\n        j = j + 1;\n      }\n      correlationOffset = bestOffset;\n    }\n    return bestOffset;\n  }\n  preCalculateCorrelationReferenceStereo() {\n    let i = 0;\n    let context;\n    let temp;\n    for (; i < this.overlapLength; i = i + 1) {\n      temp = i * (this.overlapLength - i);\n      context = i * 2;\n      this.refMidBuffer[context] = this.midBuffer[context] * temp;\n      this.refMidBuffer[context + 1] = this.midBuffer[context + 1] * temp;\n    }\n  }\n  calculateCrossCorrelationStereo(mixingPosition, compare) {\n    const mixing = this._inputBuffer.vector;\n    mixingPosition += this._inputBuffer.startIndex;\n    let correlation = 0;\n    let i = 2;\n    const calcLength = 2 * this.overlapLength;\n    let mixingOffset;\n    for (; i < calcLength; i = i + 2) {\n      mixingOffset = i + mixingPosition;\n      correlation += mixing[mixingOffset] * compare[i] + mixing[mixingOffset + 1] * compare[i + 1];\n    }\n    return correlation;\n  }\n  overlap(overlapPosition) {\n    this.overlapStereo(2 * overlapPosition);\n  }\n  overlapStereo(inputPosition) {\n    const input = this._inputBuffer.vector;\n    inputPosition += this._inputBuffer.startIndex;\n    const output = this._outputBuffer.vector;\n    const outputPosition = this._outputBuffer.endIndex;\n    let i = 0;\n    let context;\n    let tempFrame;\n    const frameScale = 1 / this.overlapLength;\n    let fi;\n    let inputOffset;\n    let outputOffset;\n    for (; i < this.overlapLength; i = i + 1) {\n      tempFrame = (this.overlapLength - i) * frameScale;\n      fi = i * frameScale;\n      context = 2 * i;\n      inputOffset = context + inputPosition;\n      outputOffset = context + outputPosition;\n      output[outputOffset + 0] = input[inputOffset + 0] * fi + this.midBuffer[context + 0] * tempFrame;\n      output[outputOffset + 1] = input[inputOffset + 1] * fi + this.midBuffer[context + 1] * tempFrame;\n    }\n  }\n  process() {\n    let offset;\n    let temp;\n    let overlapSkip;\n    if (this.midBuffer === null) {\n      if (this._inputBuffer.frameCount < this.overlapLength) {\n        return;\n      }\n      this.midBuffer = new Float32Array(this.overlapLength * 2);\n      this._inputBuffer.receiveSamples(this.midBuffer, this.overlapLength);\n    }\n    while (this._inputBuffer.frameCount >= this.sampleReq) {\n      offset = this.seekBestOverlapPosition();\n      this._outputBuffer.ensureAdditionalCapacity(this.overlapLength);\n      this.overlap(Math.floor(offset));\n      this._outputBuffer.put(this.overlapLength);\n      temp = this.seekWindowLength - 2 * this.overlapLength;\n      if (temp > 0) {\n        this._outputBuffer.putBuffer(this._inputBuffer, offset + this.overlapLength, temp);\n      }\n      const start = this._inputBuffer.startIndex + 2 * (offset + this.seekWindowLength - this.overlapLength);\n      this.midBuffer.set(this._inputBuffer.vector.subarray(start, start + 2 * this.overlapLength));\n      this.skipFract += this.nominalSkip;\n      overlapSkip = Math.floor(this.skipFract);\n      this.skipFract -= overlapSkip;\n      this._inputBuffer.receive(overlapSkip);\n    }\n  }\n}\n\nconst testFloatEqual = function (a, b) {\n  return (a > b ? a - b : b - a) > 1e-10;\n};\n\nclass SoundTouch {\n  constructor() {\n    this.transposer = new RateTransposer(false);\n    this.stretch = new Stretch(false);\n    this._inputBuffer = new FifoSampleBuffer();\n    this._intermediateBuffer = new FifoSampleBuffer();\n    this._outputBuffer = new FifoSampleBuffer();\n    this._rate = 0;\n    this._tempo = 0;\n    this.virtualPitch = 1.0;\n    this.virtualRate = 1.0;\n    this.virtualTempo = 1.0;\n    this.calculateEffectiveRateAndTempo();\n  }\n  clear() {\n    this.transposer.clear();\n    this.stretch.clear();\n  }\n  clone() {\n    const result = new SoundTouch();\n    result.rate = this.rate;\n    result.tempo = this.tempo;\n    return result;\n  }\n  get rate() {\n    return this._rate;\n  }\n  set rate(rate) {\n    this.virtualRate = rate;\n    this.calculateEffectiveRateAndTempo();\n  }\n  set rateChange(rateChange) {\n    this._rate = 1.0 + 0.01 * rateChange;\n  }\n  get tempo() {\n    return this._tempo;\n  }\n  set tempo(tempo) {\n    this.virtualTempo = tempo;\n    this.calculateEffectiveRateAndTempo();\n  }\n  set tempoChange(tempoChange) {\n    this.tempo = 1.0 + 0.01 * tempoChange;\n  }\n  set pitch(pitch) {\n    this.virtualPitch = pitch;\n    this.calculateEffectiveRateAndTempo();\n  }\n  set pitchOctaves(pitchOctaves) {\n    this.pitch = Math.exp(0.69314718056 * pitchOctaves);\n    this.calculateEffectiveRateAndTempo();\n  }\n  set pitchSemitones(pitchSemitones) {\n    this.pitchOctaves = pitchSemitones / 12.0;\n  }\n  get inputBuffer() {\n    return this._inputBuffer;\n  }\n  get outputBuffer() {\n    return this._outputBuffer;\n  }\n  calculateEffectiveRateAndTempo() {\n    const previousTempo = this._tempo;\n    const previousRate = this._rate;\n    this._tempo = this.virtualTempo / this.virtualPitch;\n    this._rate = this.virtualRate * this.virtualPitch;\n    if (testFloatEqual(this._tempo, previousTempo)) {\n      this.stretch.tempo = this._tempo;\n    }\n    if (testFloatEqual(this._rate, previousRate)) {\n      this.transposer.rate = this._rate;\n    }\n    if (this._rate > 1.0) {\n      if (this._outputBuffer != this.transposer.outputBuffer) {\n        this.stretch.inputBuffer = this._inputBuffer;\n        this.stretch.outputBuffer = this._intermediateBuffer;\n        this.transposer.inputBuffer = this._intermediateBuffer;\n        this.transposer.outputBuffer = this._outputBuffer;\n      }\n    } else {\n      if (this._outputBuffer != this.stretch.outputBuffer) {\n        this.transposer.inputBuffer = this._inputBuffer;\n        this.transposer.outputBuffer = this._intermediateBuffer;\n        this.stretch.inputBuffer = this._intermediateBuffer;\n        this.stretch.outputBuffer = this._outputBuffer;\n      }\n    }\n  }\n  process() {\n    if (this._rate > 1.0) {\n      this.stretch.process();\n      this.transposer.process();\n    } else {\n      this.transposer.process();\n      this.stretch.process();\n    }\n  }\n}\n\nclass WebAudioBufferSource {\n  constructor(buffer) {\n    this.buffer = buffer;\n    this._position = 0;\n  }\n  get dualChannel() {\n    return this.buffer.numberOfChannels > 1;\n  }\n  get position() {\n    return this._position;\n  }\n  set position(value) {\n    this._position = value;\n  }\n  extract(target, numFrames = 0, position = 0) {\n    this.position = position;\n    let left = this.buffer.getChannelData(0);\n    let right = this.dualChannel ? this.buffer.getChannelData(1) : this.buffer.getChannelData(0);\n    let i = 0;\n    for (; i < numFrames; i++) {\n      target[i * 2] = left[i + position];\n      target[i * 2 + 1] = right[i + position];\n    }\n    return Math.min(numFrames, left.length - position);\n  }\n}\n\nconst getWebAudioNode = function (context, filter, sourcePositionCallback = noop, bufferSize = 4096) {\n  const node = context.createScriptProcessor(bufferSize, 2, 2);\n  const samples = new Float32Array(bufferSize * 2);\n  node.onaudioprocess = event => {\n    let left = event.outputBuffer.getChannelData(0);\n    let right = event.outputBuffer.getChannelData(1);\n    let framesExtracted = filter.extract(samples, bufferSize);\n    sourcePositionCallback(filter.sourcePosition);\n    if (framesExtracted === 0) {\n      filter.onEnd();\n    }\n    let i = 0;\n    for (; i < framesExtracted; i++) {\n      left[i] = samples[i * 2];\n      right[i] = samples[i * 2 + 1];\n    }\n  };\n  return node;\n};\n\nconst pad = function (n, width, z) {\n  z = z || '0';\n  n = n + '';\n  return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n;\n};\nconst minsSecs = function (secs) {\n  const mins = Math.floor(secs / 60);\n  const seconds = secs - mins * 60;\n  return `${mins}:${pad(parseInt(seconds), 2)}`;\n};\n\nconst onUpdate = function (sourcePosition) {\n  const currentTimePlayed = this.timePlayed;\n  const sampleRate = this.sampleRate;\n  this.sourcePosition = sourcePosition;\n  this.timePlayed = sourcePosition / sampleRate;\n  if (currentTimePlayed !== this.timePlayed) {\n    const timePlayed = new CustomEvent('play', {\n      detail: {\n        timePlayed: this.timePlayed,\n        formattedTimePlayed: this.formattedTimePlayed,\n        percentagePlayed: this.percentagePlayed\n      }\n    });\n    this._node.dispatchEvent(timePlayed);\n  }\n};\nclass PitchShifter {\n  constructor(context, buffer, bufferSize, onEnd = noop) {\n    this._soundtouch = new SoundTouch();\n    const source = new WebAudioBufferSource(buffer);\n    this.timePlayed = 0;\n    this.sourcePosition = 0;\n    this._filter = new SimpleFilter(source, this._soundtouch, onEnd);\n    this._node = getWebAudioNode(context, this._filter, sourcePostion => onUpdate.call(this, sourcePostion), bufferSize);\n    this.tempo = 1;\n    this.rate = 1;\n    this.duration = buffer.duration;\n    this.sampleRate = context.sampleRate;\n    this.listeners = [];\n  }\n  get formattedDuration() {\n    return minsSecs(this.duration);\n  }\n  get formattedTimePlayed() {\n    return minsSecs(this.timePlayed);\n  }\n  get percentagePlayed() {\n    return 100 * this._filter.sourcePosition / (this.duration * this.sampleRate);\n  }\n  set percentagePlayed(perc) {\n    this._filter.sourcePosition = parseInt(perc * this.duration * this.sampleRate);\n    this.sourcePosition = this._filter.sourcePosition;\n    this.timePlayed = this.sourcePosition / this.sampleRate;\n  }\n  get node() {\n    return this._node;\n  }\n  set pitch(pitch) {\n    this._soundtouch.pitch = pitch;\n  }\n  set pitchSemitones(semitone) {\n    this._soundtouch.pitchSemitones = semitone;\n  }\n  set rate(rate) {\n    this._soundtouch.rate = rate;\n  }\n  set tempo(tempo) {\n    this._soundtouch.tempo = tempo;\n  }\n  connect(toNode) {\n    this._node.connect(toNode);\n  }\n  disconnect() {\n    this._node.disconnect();\n  }\n  on(eventName, cb) {\n    this.listeners.push({\n      name: eventName,\n      cb: cb\n    });\n    this._node.addEventListener(eventName, event => cb(event.detail));\n  }\n  off(eventName = null) {\n    let listeners = this.listeners;\n    if (eventName) {\n      listeners = listeners.filter(e => e.name === eventName);\n    }\n    listeners.forEach(e => {\n      this._node.removeEventListener(e.name, event => e.cb(event.detail));\n    });\n  }\n}\n\nexport { AbstractFifoSamplePipe, PitchShifter, RateTransposer, SimpleFilter, SoundTouch, Stretch, WebAudioBufferSource, getWebAudioNode };\n//# sourceMappingURL=soundtouch.js.map\n","import SoundtouchWorkletMessage from \"../../model/SoundtouchWorkletMessage\";\nimport { SoundtouchWorkletOptionsWrapper } from \"../../model/SoundtouchWorkletOptionsWrapper\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nlet soundtouchWrapperFilterWorkletNodeClass: any;\n\nif(typeof(window) !== \"undefined\" && typeof(window.AudioWorkletNode) !== \"undefined\") {\n    soundtouchWrapperFilterWorkletNodeClass = class SoundtouchWrapperFilterWorkletNode extends AudioWorkletNode {\n\n        name: string = \"\";\n        private running = false;\n        private _tempo = 1;\n        private _pitch = 1;\n\n        constructor(context: BaseAudioContext, workletName: string, options: SoundtouchWorkletOptionsWrapper) {\n            super(context, workletName, options);\n            this.name = this.constructor.name;\n            this.running = true;\n            this.updateInterval = options.processorOptions.updateInterval;\n        }\n\n        async setup(tempo: number, pitch: number): Promise<void> {\n            return new Promise(resolve => {\n                if(this.port) {\n                    this.port.onmessage = (ev: MessageEvent<SoundtouchWorkletMessage>) => {\n                        if(ev && ev.data && ev.data.status === \"OK\" && ev.data.args[0] === \"setup\") {\n                            this.port.onmessage = this.messageProcessor.bind(this);\n                            resolve();\n                        }\n                    };\n    \n                    this.port.postMessage({ command: \"setup\", args: [tempo, pitch] });\n\n                    this._tempo = tempo;\n                    this._pitch = pitch;\n                }\n            });\n        }\n\n        set updateInterval(value: number) {\n            this.port.postMessage({ command: \"updateInterval\", args: [value] });\n        }\n\n        get node() {\n            return this;\n        }\n\n        set tempo(value: number) {\n            this.port.postMessage({ command: \"setTempo\", args: [value] });\n        }\n\n        set pitch(value: number) {\n            this.port.postMessage({ command: \"setPitch\", args: [value] });\n        }\n\n        get tempo(): number {\n            this.port.postMessage({ command: \"getTempo\", args: [] });\n            return this._tempo;\n        }\n\n        get pitch(): number {\n            this.port.postMessage({ command: \"getPitch\", args: [] });\n            return this._pitch;\n        }\n\n        async stop() {\n            if (!this.running) return;\n\n            this.port.postMessage({ command: \"stop\", args: [] });\n            this.disconnect();\n\n            this.running = false;\n        }\n\n        messageProcessor(e: MessageEvent<SoundtouchWorkletMessage>) {\n            if (e.data.command) {\n                const { command } = e.data;\n                \n                switch (command) {\n                case \"End\":\n                    this.stop();\n                    break;\n                default:\n                    break;\n                }\n\n                if (e.data.status) {\n                    const value = e.data.args[1];\n\n                    switch (e.data.args[0]) {\n                    case \"getTempo\":\n                        this._tempo = value as number;\n                        break;\n                    case \"getPitch\":\n                        this._pitch = value as number;\n                        break;\n                    default:\n                        break;\n                    }\n                    return;\n                }\n            }\n        }\n    };\n}\n\nexport default soundtouchWrapperFilterWorkletNodeClass;\n","export enum EventType {\n    LOADING_BUFFERS = \"loadingBuffers\",\n    LOADING_BUFFERS_ERROR = \"loadingBuffersError\",\n    FETCHING_BUFFERS = \"fetchingBuffers\",\n    FETCHING_BUFFERS_ERROR = \"fetchingBuffersError\",\n    FINISHED_FETCHING_BUFFERS = \"finishedFetchingBuffers\",\n    LOADED_BUFFERS = \"loadedBuffers\",\n    COMPATIBILITY_MODE_AUTO_ENABLED = \"compatibilityModeAutoEnabled\",\n    RENDERING_AUDIO_PROBLEM_DETECTED = \"renderingAudioProblemDetected\",\n    PLAYING_STOPPED = \"playingStopped\",\n    PLAYING_STARTED = \"playingStarted\",\n    PLAYING_FINISHED = \"playingFinished\",\n    PLAYING_UPDATE = \"playingUpdate\",\n    RECORDER_INIT = \"recorderInit\",\n    RECORDER_SUCCESS = \"recorderSuccess\",\n    RECORDER_ERROR = \"recorderError\",\n    RECORDER_UPDATE_CONSTRAINTS = \"recorderUpdateConstraints\",\n    RECORDER_RECORDING = \"recorderRecording\",\n    RECORDER_STOPPED = \"recorderStopped\",\n    RECORDER_PAUSED = \"recorderPaused\",\n    RECORDER_RESETED = \"recorderReseted\",\n    RECORDER_COUNT_UPDATE = \"recorderCountUpdate\",\n    SAMPLE_RATE_CHANGED = \"sampleRateChanged\"\n};\n","// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n//@ts-ignore\nimport { PitchShifter } from \"soundtouchjs\";\nimport Constants from \"../model/Constants\";\nimport AbstractAudioFilterWorklet from \"./interfaces/AbstractAudioFilterWorklet\";\nimport AudioFilterEntrypointInterface from \"./interfaces/AudioFilterEntrypointInterface\";\nimport { AudioFilterNodes } from \"../model/AudioNodes\";\nimport utils from \"../utils/Functions\";\nimport SoundtouchWrapperFilterWorkletNode from \"./worklets/SoundtouchWrapperFilterWorkletNode\";\nimport SimpleAudioWorkletProcessor from \"../workletPolyfill/SimpleAudioWorkletProcessor\";\nimport SoundtouchSettings from \"../model/filtersSettings/SoundtouchSettings\";\nimport { FilterSettingValue } from \"../model/filtersSettings/FilterSettings\";\nimport utilFunctions from \"../utils/Functions\";\n\nexport default class SoundtouchWrapperFilter extends AbstractAudioFilterWorklet implements AudioFilterEntrypointInterface {\n\n    private speedAudio = 1;\n    private frequencyAudio = 1;\n    private currentSpeedAudio = 1;\n    private currentPitchShifterWorklet: typeof SoundtouchWrapperFilterWorkletNode;\n    private currentPitchShifter: PitchShifter;\n    private isOfflineMode = false;\n\n    constructor() {\n        super();\n        this.enable();\n        this.setDefaultEnabled(true);\n    }\n\n    async initializeWorklet(): Promise<void> {\n        // Do nothing\n    }\n\n    get workletPath(): string {\n        return Constants.WORKLET_PATHS.SOUNDTOUCH;\n    }\n\n    constructAudioWorkletProcessor(): SimpleAudioWorkletProcessor {\n        throw new Error(\"Method not implemented.\");\n    }\n\n    get workletName(): string {\n        return Constants.WORKLET_NAMES.SOUNDTOUCH;\n    }\n\n    async getEntrypointNode(context: BaseAudioContext, buffer: AudioBuffer, offline: boolean): Promise<AudioFilterNodes> {\n        this.isOfflineMode = offline;\n\n        // In offline (compatibility) mode\n        if(offline) {\n            // If the settings are untouched, we don't use Soundtouch\n            if(!this.isEnabled() || (this.speedAudio == 1 && this.frequencyAudio == 1)) {\n                // Just return an audio buffer source node\n                const bufferSource = context.createBufferSource();\n                bufferSource.buffer = buffer;\n                bufferSource.start();\n\n                return {\n                    input: bufferSource,\n                    output: bufferSource\n                };\n            } else {\n                // If audio worklet is enabled for soundtouch, and if the speed of audio is untouched\n                // Soundtouch Audio Worklet don't support speed editing yet\n                if(this.isAudioWorkletEnabled() && utils.isAudioWorkletCompatible(context) && this.speedAudio == 1) {\n                    return this.renderWithWorklet(buffer, context);\n                } else {\n                    return this.renderWithScriptProcessorNode(buffer, context);\n                }\n            }\n        }\n\n        // Not in offline mode: get classic soundtouch script processor node\n        if (this.currentPitchShifter) {\n            this.currentPitchShifter.disconnect();\n        }\n\n        this.currentPitchShifter = this.getSoundtouchScriptProcessorNode(buffer, context);\n        this.updateState();\n\n        return {\n            input: this.currentPitchShifter,\n            output: this.currentPitchShifter\n        };\n    }\n\n    private getSoundtouchScriptProcessorNode(buffer: AudioBuffer, context: BaseAudioContext): AudioNode {\n        return new PitchShifter(context, buffer, Constants.SOUNDTOUCH_PITCH_SHIFTER_BUFFER_SIZE);\n    }\n\n    /**\n     * Use script processor node (deprecated) to render the audio buffer with Soundtouch, according to the current settings.\n     * Not working on Firefox\n     * @param buffer Audio buffer\n     * @param context Audio context\n     * @returns A promise resolving to audio nodes with the rendered audio as a buffer source\n     */\n    private async renderWithScriptProcessorNode(buffer: AudioBuffer, context: BaseAudioContext): Promise<AudioFilterNodes> {\n        const durationAudio = utils.calcAudioDuration(buffer, this.speedAudio);\n        const offlineContext = new OfflineAudioContext(2, context.sampleRate * durationAudio, context.sampleRate);\n\n        if (this.currentPitchShifter) {\n            this.currentPitchShifter.disconnect();\n        }\n\n        this.currentPitchShifter = this.getSoundtouchScriptProcessorNode(buffer, offlineContext);\n        this.updateState();\n        \n        this.currentPitchShifter.connect(offlineContext.destination);\n\n        const renderedBuffer = await offlineContext.startRendering();\n\n        const bufferSourceRendered = context.createBufferSource();\n        bufferSourceRendered.buffer = renderedBuffer;\n        bufferSourceRendered.start();\n\n        return {\n            input: bufferSourceRendered,\n            output: bufferSourceRendered\n        };\n    }\n\n    /**\n     * EXPERIMENTAL - Use audio worklet to render the audio buffer with Soundtouch, according to the current settings.\n     * Working in Firefox and Chrome\n     * @param buffer Audio buffer\n     * @param context Audio context\n     * @returns A promise resolving to audio nodes with the rendered audio as a buffer source\n     */\n    private async renderWithWorklet(buffer: AudioBuffer, context: BaseAudioContext): Promise<AudioFilterNodes> {\n        const durationAudio = utils.calcAudioDuration(buffer, this.speedAudio);\n\n        try {\n            // Stop current worklet\n            if(this.currentPitchShifterWorklet) {\n                this.currentPitchShifterWorklet.stop();\n            }\n\n            // Setup worklet JS module\n            await context.audioWorklet.addModule(Constants.WORKLET_PATHS.SOUNDTOUCH);\n    \n            // Setup an audio buffer source from the audio buffer\n            const bufferSource = context.createBufferSource();\n            bufferSource.buffer = buffer;\n            bufferSource.start();\n    \n            // Create the worklet node\n            this.currentPitchShifterWorklet = new SoundtouchWrapperFilterWorkletNode(context, \"soundtouch-worklet\", {\n                processorOptions: {\n                    bypass: false,\n                    recording: false,\n                    nInputFrames: this.approximateNInputFrames(durationAudio, context),\n                    updateInterval: 10.0,\n                    sampleRate: buffer.sampleRate\n                },\n            });\n    \n            // Connect the node for correct rendering\n            bufferSource.connect(this.currentPitchShifterWorklet.node);\n\n            // Setup pitch/speed of Soundtouch\n            if(this.isEnabled()) {\n                await this.currentPitchShifterWorklet.setup(this.speedAudio, this.frequencyAudio);\n            } else {\n                await this.currentPitchShifterWorklet.setup(1, 1);\n            }\n\n            return {\n                input: this.currentPitchShifterWorklet,\n                output: this.currentPitchShifterWorklet\n            };\n        } catch(e) {\n            // Fallback to script processor node\n            console.error(e);\n            return this.renderWithScriptProcessorNode(buffer, context);\n        }\n    }\n\n    private approximateNInputFrames(durationAudio: number, context: BaseAudioContext) {\n        // {frequencyAudio, multiplicator}: {{0.1, 10}, {0.2, 5}, {0.3, 3.33}, {0.4, 2.5}, {0.5, 2}, {0.6, 1.67}, {0.7, 1.43}, {0.8, 1.25}, {0.9, 1.11}, {1, 1}}\n        return durationAudio * context.sampleRate * (Math.round(14 * Math.exp(-4 * this.frequencyAudio)) + 1);\n    }\n    \n    get order(): number {\n        return 2;\n    }\n\n    get id(): string {\n        return Constants.FILTERS_NAMES.SOUNDTOUCH;\n    }\n\n    getSettings(): SoundtouchSettings {\n        return {\n            speedAudio: this.speedAudio,\n            frequencyAudio: this.frequencyAudio\n        };\n    }\n\n    protected isAudioWorkletEnabled() {\n        if(this.configService) {\n            return this.configService.isSoundtouchAudioWorkletEnabled();\n        }\n\n        return Constants.ENABLE_SOUNDTOUCH_AUDIO_WORKLET;\n    }\n\n    private getCurrentPitchShifter() {\n        if(this.isOfflineMode) {\n            // If the settings are untouched, we don't use Soundtouch\n            if(this.speedAudio == 1 && this.frequencyAudio == 1) {\n                return null;\n            } else {\n                if(this.isAudioWorkletEnabled() && this.currentPitchShifterWorklet && this.speedAudio == 1) {\n                    return this.currentPitchShifterWorklet;\n                } else {\n                    return this.currentPitchShifter;\n                }\n            }\n        }\n\n        return this.currentPitchShifter;\n    }\n\n    updateState(): void {\n        const pitchShifter = this.getCurrentPitchShifter();\n\n        if(!this.isEnabled()) {\n            if(pitchShifter) {\n                pitchShifter.pitch = 1;\n                pitchShifter.tempo = 1;\n            }\n                \n            this.currentSpeedAudio = 1;\n        } else {\n            if(pitchShifter) {\n                pitchShifter.pitch = this.frequencyAudio;\n                pitchShifter.tempo = this.speedAudio;\n            }\n            \n            this.currentSpeedAudio = this.speedAudio;\n        }\n    }\n\n    async setSetting(settingId: string, value: FilterSettingValue) {\n        if(!utilFunctions.isSettingValueValid(value)) {\n            return;\n        }\n\n        const valueFloat = parseFloat(value as string);\n\n        switch(settingId) {\n        case \"speedAudio\":\n            this.speedAudio = valueFloat;\n            break;\n        case \"frequencyAudio\":\n            this.frequencyAudio = valueFloat;\n            break;\n        default:\n            break;\n        }\n\n        this.updateState();\n    }\n\n    setEnabled(state: boolean): void {\n        super.setEnabled(state);\n        this.updateState();\n    }\n\n    getSpeed(): number {\n        return this.currentSpeedAudio;\n    }\n}\n","import AbstractAudioFilter from \"./interfaces/AbstractAudioFilter\";\nimport Constants from \"../model/Constants\";\nimport { FilterSettingValue } from \"../model/filtersSettings/FilterSettings\";\n\nexport default class BitCrusherFilter extends AbstractAudioFilter {\n\n    getNode(context: BaseAudioContext) {\n        const lpf1 = context.createBiquadFilter();\n        lpf1.type = \"lowpass\";\n        lpf1.frequency.value = 2000.0;\n        const lpf2 = context.createBiquadFilter();\n        lpf2.type = \"lowpass\";\n        lpf2.frequency.value = 2000.0;\n        const hpf1 = context.createBiquadFilter();\n        hpf1.type = \"highpass\";\n        hpf1.frequency.value = 500.0;\n        const hpf2 = context.createBiquadFilter();\n        hpf2.type = \"highpass\";\n        hpf2.frequency.value = 500.0;\n        lpf1.connect(lpf2);\n        lpf2.connect(hpf1);\n        hpf1.connect(hpf2);\n    \n        return {\n            input: lpf1,\n            output: hpf2\n        };\n    }\n    \n    get order(): number {\n        return 7;\n    }\n\n    get id(): string {\n        return Constants.FILTERS_NAMES.TELEPHONIZER;\n    }\n\n    getSettings() {\n        return {};\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async setSetting(settingId: string, value: FilterSettingValue) { }\n}\n","import AudioEditorEvents from \"../model/AudioEditorEvent\";\nimport { EventEmitterCallback } from \"../model/EventEmitterCallback\";\n\nclass EventEmitter {\n    listeners: AudioEditorEvents = {};\n    \n    constructor() {\n        this.listeners = {};\n    }\n\n    on(event: string, callback: EventEmitterCallback) {\n        if (!this.listeners[event]) {\n            this.listeners[event] = [];\n        }\n        this.listeners[event].push(callback);\n    }\n\n    emit(event: string, data?: string | number | AudioBuffer) {\n        if (this.listeners[event]) {\n            this.listeners[event].forEach(callback => {\n                callback(data);\n            });\n        }\n    }\n\n    off(event: string, callback: EventEmitterCallback) {\n        if (this.listeners[event]) {\n            this.listeners[event] = this.listeners[event].filter(cb => cb !== callback);\n        }\n    }\n}\n\nexport default EventEmitter;\n","/*\n * Copyright (C) 2019-2023 Eliastik (eliastiksofts.com)\n *\n * This file is part of \"Simple Voice Changer\".\n *\n * \"Simple Voice Changer\" is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * \"Simple Voice Changer\" is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with \"Simple Voice Changer\".  If not, see <http://www.gnu.org/licenses/>.\n */\n// The audio buffer player\n// Used to play the audio buffer, with time controls, pause/play, stop and loop\n\nimport EventEmitter from \"./utils/EventEmitter\";\nimport AbstractAudioElement from \"./filters/interfaces/AbstractAudioElement\";\nimport Constants from \"./model/Constants\";\nimport { EventType } from \"./model/EventTypeEnum\";\nimport { EventEmitterCallback } from \"./model/EventEmitterCallback\";\n\n// Also used in compatibility mode (which doesn't use audio buffer) with less functions (no time control)\nexport default class BufferPlayer extends AbstractAudioElement {\n\n    private context: AudioContext | OfflineAudioContext | null = null;\n    private buffer: AudioBuffer | null = null;\n    private source: AudioBufferSourceNode | null = null;\n    currentTime = 0;\n    displayTime = 0;\n    duration = 0;\n    private interval: number | null = null;\n    playing = false;\n    loop = false;\n    speedAudio = 1;\n    private eventEmitter: EventEmitter | null;\n    private onBeforePlayingCallback: () => void = async () => {};\n\n    compatibilityMode = false;\n    currentNode: AudioNode | null = null;\n\n    constructor(context: AudioContext | OfflineAudioContext | null, eventEmitter?: EventEmitter) {\n        super();\n        this.context = context;\n        this.eventEmitter = eventEmitter || new EventEmitter();\n    }\n\n    /** Init this buffer player */\n    init() {\n        this.playing = false;\n\n        if (this.context) {\n            this.context.resume();\n\n            if (!this.compatibilityMode && this.buffer) {\n                if (this.source != null) this.source.disconnect();\n                this.source = this.context.createBufferSource();\n                this.source.buffer = this.buffer;\n                this.duration = this.buffer.duration * this.speedAudio;\n                this.source.connect(this.context.destination);\n            }\n        }\n\n        this.updateInfos();\n    }\n\n    /**\n     * Load an audio buffer\n     * @param buffer The buffer\n     */\n    loadBuffer(buffer: AudioBuffer) {\n        this.compatibilityMode = false;\n        this.reset();\n        this.buffer = buffer;\n        this.init();\n    }\n\n    /**\n     * Enable compatibility mode\n     * @param currentNode Current audio node to read\n     * @param duration The audio duration\n     */\n    setCompatibilityMode(currentNode: AudioNode, duration?: number) {\n        this.compatibilityMode = true;\n        this.reset();\n        this.init();\n\n        if (duration != null) {\n            this.duration = duration * this.speedAudio;\n        }\n\n        this.currentNode = currentNode;\n        this.updateInfos();\n    }\n\n    /**\n     * Reset this player\n     */\n    reset() {\n        clearInterval(this.interval!);\n        this.currentTime = 0;\n        this.displayTime = 0;\n        this.stop();\n    }\n\n    /**\n     * Stop playing the audio\n     */\n    stop() {\n        clearInterval(this.interval!);\n\n        if (this.source != undefined && this.source != null && this.playing) {\n            this.source.stop(0);\n            this.playing = false;\n        }\n\n        if (this.currentNode) {\n            this.currentNode.disconnect();\n\n            if(this.compatibilityMode) {\n                this.currentTime = 0;\n                this.displayTime = 0;\n            }\n        }\n\n        this.eventEmitter?.emit(EventType.PLAYING_STOPPED);\n        this.updateInfos();\n    }\n\n    /**\n     * Start playing the audio\n     */\n    async start() {\n        if (this.source || this.compatibilityMode) {\n            this.stop();\n            this.init();\n\n            await this.onBeforePlayingCallback();\n\n            this.eventEmitter?.emit(EventType.PLAYING_STARTED);\n\n            if (!this.compatibilityMode) {\n                if (this.source) {\n                    this.source.start(0, this.currentTime / this.speedAudio);\n                    this.playing = true;\n                } else {\n                    return;\n                }\n            } else {\n                if (this.currentNode && this.context) {\n                    this.currentNode.connect(this.context.destination);\n                } else {\n                    return;\n                }\n            }\n\n            let startTime = performance.now();\n\n            this.interval = window.setInterval(() => {\n                const timeNow = performance.now();\n                const nextTime = timeNow - startTime;\n                startTime = timeNow;\n\n                this.currentTime += (nextTime / 1000) * this.speedAudio;\n                this.displayTime = this.currentTime;\n\n                if (this.currentTime > this.duration) {\n                    if (this.loop) {\n                        if (!this.compatibilityMode) {\n                            this.reset();\n                            this.start();\n                        } else {\n                            this.eventEmitter?.emit(EventType.PLAYING_FINISHED);\n                        }\n                    } else {\n                        this.eventEmitter?.emit(EventType.PLAYING_FINISHED);\n                        this.reset();\n                    }\n                } else {\n                    this.updateInfos();\n                }\n            }, 100);\n        }\n    }\n\n    /**\n     * Pause the audio\n     */\n    pause() {\n        this.stop();\n    }\n\n    /** Send an event to update the informations of this player */\n    private updateInfos() {\n        this.eventEmitter?.emit(EventType.PLAYING_UPDATE);\n    }\n\n    /**\n     * Set the current starting time of this player\n     * @param percent Where to start playing, in percent\n     */\n    setTimePercent(percent: number) {\n        if(!this.compatibilityMode) {\n            this.currentTime = Math.round(this.duration * (percent / 100));\n            this.displayTime = this.currentTime;\n    \n            if (this.playing) {\n                this.pause();\n                this.start();\n            } else {\n                this.updateInfos();\n            }\n        }\n    }\n\n    /**\n     * Set the current starting time of this player\n     * @param time Where to start playing, in milliseconds\n     */\n    setTime(time: number) {\n        if (!this.compatibilityMode) {\n            this.currentTime = time;\n            this.displayTime = this.currentTime;\n\n            if (this.playing) {\n                this.pause();\n                this.start();\n            } else {\n                this.updateInfos();\n            }\n        }\n    }\n\n    /**\n     * Callback called just before starting playing the audio\n     * @param callback The callback\n     */\n    onBeforePlaying(callback: () => void) {\n        this.onBeforePlayingCallback = callback;\n    }\n\n    /**\n     * Enable/disable loop playing\n     */\n    toggleLoop() {\n        this.loop = !this.loop;\n    }\n\n    /**\n     * Observe an event\n     * @param event The event name\n     * @param callback Callback called when an event of this type occurs\n     */\n    on(event: string, callback: EventEmitterCallback) {\n        this.eventEmitter?.on(event, callback);\n    }\n\n    /**\n     * Set a new audio context\n     * @param context The new audio context\n     */\n    updateContext(context: AudioContext) {\n        this.context = context;\n    }\n\n    /**\n     * Get the time in text format\n     */\n    get currentTimeDisplay() {\n        return (\"0\" + Math.trunc(this.displayTime / 60)).slice(-2) + \":\" + (\"0\" + Math.trunc(this.displayTime % 60)).slice(-2);\n    }\n\n    /** \n     * Get the audio duration in text format\n     */\n    get maxTimeDisplay() {\n        return (\"0\" + Math.trunc(this.duration / 60)).slice(-2) + \":\" + (\"0\" + Math.trunc(this.duration % 60)).slice(-2);\n    }\n\n    /**\n     * Get the percent played\n     */\n    get percent() {\n        return (100 - Math.round((this.duration - this.displayTime) / this.duration * 100));\n    }\n\n    /**\n     * Get the remaining time in text format\n     */\n    get remainingTimeDisplay() {\n        return (\"0\" + Math.trunc((this.duration - this.displayTime) / 60)).slice(-2) + \":\" + (\"0\" + Math.trunc((this.duration - this.displayTime) % 60)).slice(-2);\n    }\n\n    get order(): number {\n        return -1;\n    }\n\n    get id(): string {\n        return Constants.BUFFER_PLAYER;\n    }\n}\n","import EventEmitter from \"../utils/EventEmitter\";\nimport { EventType } from \"../model/EventTypeEnum\";\nimport utilFunctions from \"../utils/Functions\";\n\nexport default class BufferFetcherService {\n\n    private context: AudioContext;\n    private buffers: Map<string, AudioBuffer> = new Map<string, AudioBuffer>();\n    private bufferErrors: string[] = [];\n    private eventEmitter: EventEmitter | null;\n\n    constructor(context: AudioContext, eventEmitter?: EventEmitter) {\n        this.context = context;\n        this.eventEmitter = eventEmitter || new EventEmitter();\n    }\n\n    async fetchBuffer(bufferURI: string, force?: boolean) {\n        if(this.buffers.get(this.getKeyFromLocation(bufferURI)) != null && !force) {\n            return;\n        }\n\n        this.eventEmitter?.emit(EventType.FETCHING_BUFFERS, bufferURI);\n\n        try {\n            const response = await fetch(bufferURI);\n\n            if(!response.ok) {\n                this.bufferErrors.push(bufferURI);\n                this.eventEmitter?.emit(EventType.FETCHING_BUFFERS_ERROR, bufferURI);\n                throw EventType.FETCHING_BUFFERS_ERROR;\n            } else {\n                const arrayBuffer = await response.arrayBuffer();\n                const buffer = await this.context.decodeAudioData(arrayBuffer);\n                this.buffers.set(this.getKeyFromLocation(bufferURI), await utilFunctions.decodeBuffer(this.context, buffer));\n            }\n    \n            this.eventEmitter?.emit(EventType.FINISHED_FETCHING_BUFFERS, bufferURI);\n        } catch(e) {\n            this.bufferErrors.push(bufferURI);\n            this.eventEmitter?.emit(EventType.FETCHING_BUFFERS_ERROR, bufferURI);\n            throw EventType.FETCHING_BUFFERS_ERROR;\n        }\n    }\n\n    async fetchAllBuffers(bufferURIs: string[]) {\n        for(const uri of bufferURIs) {\n            await this.fetchBuffer(uri);\n        }\n    }\n\n    getAudioBuffer(filename: string): AudioBuffer | undefined {\n        return this.buffers.get(this.getKeyFromLocation(filename));\n    }\n\n    async getOrFetchAudioBuffer(filename: string): Promise<AudioBuffer | undefined> {\n        if(this.getAudioBuffer(filename) == null) {\n            await this.fetchBuffer(filename);\n        }\n\n        return this.getAudioBuffer(filename);\n    }\n\n    getDownloadedBuffersList(): string[] {\n        return Array.from(this.buffers.keys());\n    }\n\n    private getKeyFromLocation(location: string) {\n        return location.substring(location.lastIndexOf(\"/\") + 1);\n    }\n\n    updateContext(context: AudioContext) {\n        this.context = context;\n    }\n\n    reset() {\n        this.buffers.clear();\n    }\n}\n","/*\n * Copyright (c) 2012 The Chromium Authors. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *    * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *    * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *    * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n/*\n * Copyright (C) 2023 Eliastik (eliastiksofts.com)\n *\n * This file is part of \"Simple Voice Changer\".\n *\n * \"Simple Voice Changer\" is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * \"Simple Voice Changer\" is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with \"Simple Voice Changer\".  If not, see <http://www.gnu.org/licenses/>.\n */\ninterface VocoderBand {\n    frequency: number;\n}\n\nexport default class Vocoder {\n\n    private FILTER_QUALITY = 6;  // The Q value for the carrier and modulator filters\n    private FOURIER_SIZE = 4096;\n    private WAVETABLEBOOST = 40.0;\n    private SAWTOOTHBOOST = 0.40;\n    private oscillatorType = 4;   // CUSTOM\n    private oscillatorDetuneValue = 0;\n\n    private audioContext: BaseAudioContext | null = null;\n    private modulatorBuffer: AudioBuffer | undefined;\n    private carrierBuffer: AudioBuffer | null = null;\n    private modulatorNode: AudioBufferSourceNode | null = null;\n    private vocoding = false;\n\n    // These are \"placeholder\" gain nodes - because the modulator and carrier will get swapped in\n    // as they are loaded, it's easier to connect these nodes to all the bands, and the \"real\"\n    // modulator & carrier AudioBufferSourceNodes connect to these.\n    private modulatorInput: GainNode | null = null;\n    private carrierInput: GainNode | null = null;\n\n    private modulatorGain: GainNode | null = null;\n    private modulatorGainValue = 1.0;\n\n    // noise node added to the carrier signal\n    private noiseBuffer: AudioBuffer | null = null;\n    private noiseNode: AudioBufferSourceNode | null = null;\n    private noiseGain: GainNode | null = null;\n    private noiseGainValue = 0.2;\n\n    // Carrier sample gain\n    private carrierSampleNode: AudioBufferSourceNode | null = null;\n    private carrierSampleGain: GainNode | null = null;\n    private carrierSampleGainValue = 0.0;\n\n    // Carrier Synth oscillator stuff\n    private oscillatorNode: OscillatorNode | null = null;\n    private oscillatorGain: GainNode | null = null;\n    private oscillatorGainValue = 1.0;\n    private wavetable: PeriodicWave | null = null;\n    private wavetableSignalGain: GainNode | null = null;\n\n    // These are the arrays of nodes - the \"columns\" across the frequency band \"rows\"\n    private modFilterBands: BiquadFilterNode[] | null = null;    // tuned bandpass filters\n    private modFilterPostGains: GainNode[] | null = null;  // post-filter gains.\n    private heterodynes: GainNode[] | null = null;   // gain nodes used to multiply bandpass X sine\n    private powers: number[] | null = null;      // gain nodes used to multiply prev out by itself\n    private lpFilters: BiquadFilterNode[] | null = null;   // tuned LP filters to remove doubled copy of product\n    private lpFilterPostGains: GainNode[] | null = null;   // gain nodes for tuning input to waveshapers\n    private carrierBands: BiquadFilterNode[] | null = null;  // tuned bandpass filters, same as modFilterBands but in carrier chain\n    private carrierFilterPostGains: GainNode[] | null = null;  // post-bandpass gain adjustment\n    private carrierBandGains: GainNode[] | null = null;  // these are the \"control gains\" driven by the lpFilters\n\n    private vocoderBands: VocoderBand[] | null = null;\n    private numVocoderBands: number = 0;\n\n    private hpFilterGain: GainNode | null = null;\n    private outputGain: GainNode | null = null;\n\n    // Initialization function for the page.\n    constructor(ctx: BaseAudioContext, carrierB: AudioBuffer, modulatorB?: AudioBuffer) {\n        this.audioContext = ctx;\n        this.carrierBuffer = carrierB;\n        this.modulatorBuffer = modulatorB;\n    }\n\n    init() {\n        this.generateVocoderBands(55, 7040, 28);\n        // Set up the vocoder chains\n        this.setupVocoderGraph();\n        this.vocode();\n    }\n\n    getNodes() {\n        return {\n            modulatorNode: this.modulatorNode,\n            modulatorGain: this.modulatorGain,\n            synthLevel: this.oscillatorGain,\n            noiseNode: this.noiseGain,\n            oscillatorNode: this.oscillatorNode,\n            hpFilterGain: this.hpFilterGain,\n            outputGain: this.outputGain\n        };\n    }\n\n    private shutOffCarrier() {\n        if (this.oscillatorNode && this.noiseNode && this.carrierSampleNode) {\n            this.oscillatorNode.stop(0);\n            this.oscillatorNode = null;\n            this.noiseNode.stop(0);\n            this.noiseNode = null;\n            this.carrierSampleNode.stop(0);\n            this.carrierSampleNode = null;\n        }\n    }\n\n    selectSawtooth() {\n        if (this.wavetableSignalGain)\n            this.wavetableSignalGain.gain.value = this.SAWTOOTHBOOST;\n        if (this.oscillatorNode)\n            this.oscillatorNode.type = \"sawtooth\";\n    }\n\n    selectWavetable() {\n        if (this.wavetableSignalGain)\n            this.wavetableSignalGain.gain.value = this.WAVETABLEBOOST;\n        if (this.oscillatorNode && this.wavetable)\n            this.oscillatorNode.setPeriodicWave(this.wavetable);\n        if (this.wavetableSignalGain)\n            this.wavetableSignalGain.gain.value = this.WAVETABLEBOOST;\n    }\n\n    updateModGain(value: number) {\n        this.modulatorGainValue = value;\n        if (this.modulatorGain)\n            this.modulatorGain.gain.value = value;\n    }\n\n    // sample-based carrier\n    updateSampleLevel(value: number) {\n        this.carrierSampleGainValue = value;\n        if (this.carrierSampleGain)\n            this.carrierSampleGain.gain.value = value;\n    }\n\n    // noise in carrier\n    updateSynthLevel(value: number) {\n        this.oscillatorGainValue = value;\n        if (this.oscillatorGain)\n            this.oscillatorGain.gain.value = value;\n    }\n\n    // noise in carrier\n    updateNoiseLevel(value: number) {\n        this.noiseGainValue = value;\n        if (this.noiseGain)\n            this.noiseGain.gain.value = value;\n    }\n\n    // this will algorithmically re-calculate vocoder bands, distributing evenly\n    // from startFreq to endFreq, splitting evenly (logarhythmically) into a given numBands.\n    // The function places this info into the global vocoderBands and numVocoderBands letiables.\n    private generateVocoderBands(startFreq: number, endFreq: number, numBands: number) {\n        // Remember: 1200 cents in octave, 100 cents per semitone\n\n        const totalRangeInCents = 1200 * Math.log(endFreq / startFreq) / Math.LN2;\n        const centsPerBand = totalRangeInCents / numBands;\n        const scale = Math.pow(2, centsPerBand / 1200);  // This is the scaling for successive bands\n\n        this.vocoderBands = [];\n        let currentFreq = startFreq;\n\n        for (let i = 0; i < numBands; i++) {\n            this.vocoderBands[i] = { frequency: currentFreq };\n            //console.log( \"Band \" + i + \" centered at \" + currentFreq + \"Hz\" );\n            currentFreq = currentFreq * scale;\n        }\n\n        this.numVocoderBands = numBands;\n    }\n\n    private loadNoiseBuffer() {  // create a 5-second buffer of noise\n        if (!this.audioContext) return;\n\n        const lengthInSamples = 5 * this.audioContext.sampleRate;\n        this.noiseBuffer = this.audioContext.createBuffer(1, lengthInSamples, this.audioContext.sampleRate);\n        const bufferData = this.noiseBuffer.getChannelData(0);\n\n        for (let i = 0; i < lengthInSamples; ++i) {\n            bufferData[i] = (2 * Math.random() - 1);  // -1 to +1\n        }\n    }\n\n    private initBandpassFilters() {\n        if (!this.audioContext) return;\n\n        // When this function is called, the carrierNode and modulatorAnalyser\n        // may not already be created.  Create placeholder nodes for them.\n        this.modulatorInput = this.audioContext.createGain();\n        this.carrierInput = this.audioContext.createGain();\n\n        if (this.modFilterBands == null)\n            this.modFilterBands = [];\n\n        if (this.modFilterPostGains == null)\n            this.modFilterPostGains = [];\n\n        if (this.heterodynes == null)\n            this.heterodynes = [];\n\n        if (this.powers == null)\n            this.powers = [];\n\n        if (this.lpFilters == null)\n            this.lpFilters = [];\n\n        if (this.lpFilterPostGains == null)\n            this.lpFilterPostGains = [];\n\n        if (this.carrierBands == null)\n            this.carrierBands = [];\n\n        if (this.carrierFilterPostGains == null)\n            this.carrierFilterPostGains = [];\n\n        if (this.carrierBandGains == null)\n            this.carrierBandGains = [];\n\n        const waveShaperCurve = new Float32Array(65536);\n        // Populate with a \"curve\" that does an abs()\n        const n = 65536;\n        const n2 = n / 2;\n        let x;\n\n        for (let i = 0; i < n2; ++i) {\n            x = i / n2;\n\n            waveShaperCurve[n2 + i] = x;\n            waveShaperCurve[n2 - i - 1] = x;\n        }\n\n        // Set up a high-pass filter to add back in the fricatives, etc.\n        // (this isn't used by default in the \"production\" version, as I hid the slider)\n        const hpFilter = this.audioContext.createBiquadFilter();\n        hpFilter.type = \"highpass\";\n        hpFilter.frequency.value = 8000; // or use vocoderBands[numVocoderBands-1].frequency;\n        hpFilter.Q.value = 1; //  no peaking\n        this.modulatorInput.connect(hpFilter);\n\n        this.hpFilterGain = this.audioContext.createGain();\n        this.hpFilterGain.gain.value = 0.0;\n\n        hpFilter.connect(this.hpFilterGain);\n\n        if(this.modulatorBuffer) {\n            this.hpFilterGain.connect(this.audioContext.destination);\n        }\n\n        //clear the arrays\n        this.modFilterBands.length = 0;\n        this.modFilterPostGains.length = 0;\n        this.heterodynes.length = 0;\n        this.powers.length = 0;\n        this.lpFilters.length = 0;\n        this.lpFilterPostGains.length = 0;\n        this.carrierBands.length = 0;\n        this.carrierFilterPostGains.length = 0;\n        this.carrierBandGains.length = 0;\n\n        this.outputGain = this.audioContext.createGain();\n\n        if(this.modulatorBuffer) {\n            this.outputGain.connect(this.audioContext.destination);\n        }\n\n        const rectifierCurve = new Float32Array(65536);\n        for (let i = -32768; i < 32768; i++)\n            rectifierCurve[i + 32768] = ((i > 0) ? i : -i) / 32768;\n\n        for (let i = 0; i < this.numVocoderBands; i++) {\n            // CREATE THE MODULATOR CHAIN\n            // create the bandpass filter in the modulator chain\n            const modulatorFilter = this.audioContext.createBiquadFilter();\n            modulatorFilter.type = \"bandpass\";  // Bandpass filter\n            if (this.vocoderBands)\n                modulatorFilter.frequency.value = this.vocoderBands[i].frequency;\n            modulatorFilter.Q.value = this.FILTER_QUALITY; //  initial quality\n            this.modulatorInput.connect(modulatorFilter);\n            this.modFilterBands.push(modulatorFilter);\n\n            // Now, create a second bandpass filter tuned to the same frequency -\n            // this turns our second-order filter into a 4th-order filter,\n            // which has a steeper rolloff/octave\n            const secondModulatorFilter = this.audioContext.createBiquadFilter();\n            secondModulatorFilter.type = \"bandpass\";  // Bandpass filter\n            if (this.vocoderBands)\n                secondModulatorFilter.frequency.value = this.vocoderBands[i].frequency;\n            secondModulatorFilter.Q.value = this.FILTER_QUALITY; //  initial quality\n            //modulatorFilter.chainedFilter = secondModulatorFilter;\n            modulatorFilter.connect(secondModulatorFilter);\n\n            // create a post-filtering gain to bump the levels up.\n            const modulatorFilterPostGain = this.audioContext.createGain();\n            modulatorFilterPostGain.gain.value = 6;\n            secondModulatorFilter.connect(modulatorFilterPostGain);\n            this.modFilterPostGains.push(modulatorFilterPostGain);\n\n            // Create the sine oscillator for the heterodyne\n            const heterodyneOscillator = this.audioContext.createOscillator();\n            if (this.vocoderBands)\n                heterodyneOscillator.frequency.value = this.vocoderBands[i].frequency;\n\n            heterodyneOscillator.start(0);\n\n            // Create the node to multiply the sine by the modulator\n            const heterodyne = this.audioContext.createGain();\n            modulatorFilterPostGain.connect(heterodyne);\n            heterodyne.gain.value = 0.0;  // audio-rate inputs are summed with initial intrinsic value\n            heterodyneOscillator.connect(heterodyne.gain);\n\n            const heterodynePostGain = this.audioContext.createGain();\n            heterodynePostGain.gain.value = 2.0;    // GUESS:  boost\n            heterodyne.connect(heterodynePostGain);\n            this.heterodynes.push(heterodynePostGain);\n\n\n            // Create the rectifier node\n            const rectifier = this.audioContext.createWaveShaper();\n            rectifier.curve = rectifierCurve;\n            heterodynePostGain.connect(rectifier);\n\n            // Create the lowpass filter to mask off the difference (near zero)\n            const lpFilter = this.audioContext.createBiquadFilter();\n            lpFilter.type = \"lowpass\";  // Lowpass filter\n            lpFilter.frequency.value = 5.0; // Guesstimate!  Mask off 20Hz and above.\n            lpFilter.Q.value = 1; // don't need a peak\n            this.lpFilters.push(lpFilter);\n            rectifier.connect(lpFilter);\n\n            const lpFilterPostGain = this.audioContext.createGain();\n            lpFilterPostGain.gain.value = 1.0;\n            lpFilter.connect(lpFilterPostGain);\n            this.lpFilterPostGains.push(lpFilterPostGain);\n\n            const waveshaper = this.audioContext.createWaveShaper();\n            waveshaper.curve = waveShaperCurve;\n            lpFilterPostGain.connect(waveshaper);\n\n\n            // Create the bandpass filter in the carrier chain\n            const carrierFilter = this.audioContext.createBiquadFilter();\n            carrierFilter.type = \"bandpass\";\n            if (this.vocoderBands)\n                carrierFilter.frequency.value = this.vocoderBands[i].frequency;\n            carrierFilter.Q.value = this.FILTER_QUALITY;\n            this.carrierBands.push(carrierFilter);\n            this.carrierInput.connect(carrierFilter);\n\n            // We want our carrier filters to be 4th-order filter too.\n            const secondCarrierFilter = this.audioContext.createBiquadFilter();\n            secondCarrierFilter.type = \"bandpass\";  // Bandpass filter\n            if (this.vocoderBands)\n                secondCarrierFilter.frequency.value = this.vocoderBands[i].frequency;\n            secondCarrierFilter.Q.value = this.FILTER_QUALITY; //  initial quality\n            //carrierFilter.chainedFilter = secondCarrierFilter;\n            carrierFilter.connect(secondCarrierFilter);\n\n            const carrierFilterPostGain = this.audioContext.createGain();\n            carrierFilterPostGain.gain.value = 10.0;\n            secondCarrierFilter.connect(carrierFilterPostGain);\n            this.carrierFilterPostGains.push(carrierFilterPostGain);\n\n            // Create the carrier band gain node\n            const bandGain = this.audioContext.createGain();\n            this.carrierBandGains.push(bandGain);\n            carrierFilterPostGain.connect(bandGain);\n            bandGain.gain.value = 0.0;  // audio-rate inputs are summed with initial intrinsic value\n            waveshaper.connect(bandGain.gain);  // connect the lp controller\n\n            bandGain.connect(this.outputGain);\n        }\n\n\n        // Now set up our wavetable stuff.\n        const real = new Float32Array(this.FOURIER_SIZE);\n        const imag = new Float32Array(this.FOURIER_SIZE);\n        real[0] = 0.0;\n        imag[0] = 0.0;\n        for (let i = 1; i < this.FOURIER_SIZE; i++) {\n            real[i] = 1.0;\n            imag[i] = 1.0;\n        }\n\n        this.wavetable = this.audioContext.createPeriodicWave(real, imag);\n        this.loadNoiseBuffer();\n    }\n\n    private setupVocoderGraph() {\n        this.initBandpassFilters();\n    }\n\n    private createCarriersAndPlay(output: GainNode | null) {\n        if(!this.audioContext || !output) return;\n\n        this.carrierSampleNode = this.audioContext.createBufferSource();\n        this.carrierSampleNode.buffer = this.carrierBuffer;\n        this.carrierSampleNode.loop = true;\n\n        this.carrierSampleGain = this.audioContext.createGain();\n        this.carrierSampleGain.gain.value = this.carrierSampleGainValue;\n        this.carrierSampleNode.connect(this.carrierSampleGain);\n        this.carrierSampleGain.connect(output);\n\n        // The wavetable signal needs a boost.\n        this.wavetableSignalGain = this.audioContext.createGain();\n\n        this.oscillatorNode = this.audioContext.createOscillator();\n        if (this.oscillatorType == 4 && this.wavetable) { // wavetable\n            this.oscillatorNode.setPeriodicWave(this.wavetable);\n            this.wavetableSignalGain.gain.value = this.WAVETABLEBOOST;\n        } else {\n            //oscillatorNode.type = oscillatorType;\n            this.wavetableSignalGain.gain.value = this.SAWTOOTHBOOST;\n        }\n        this.oscillatorNode.frequency.value = 110;\n        this.oscillatorNode.detune.value = this.oscillatorDetuneValue;\n        this.oscillatorNode.connect(this.wavetableSignalGain);\n\n        this.oscillatorGain = this.audioContext.createGain();\n        this.oscillatorGain.gain.value = this.oscillatorGainValue;\n\n        this.wavetableSignalGain.connect(this.oscillatorGain);\n        this.oscillatorGain.connect(output);\n\n        this.noiseNode = this.audioContext.createBufferSource();\n        this.noiseNode.buffer = this.noiseBuffer;\n        this.noiseNode.loop = true;\n        this.noiseGain = this.audioContext.createGain();\n        this.noiseGain.gain.value = this.noiseGainValue;\n        this.noiseNode.connect(this.noiseGain);\n\n        this.noiseGain.connect(output);\n        this.oscillatorNode.start(0);\n        this.noiseNode.start(0);\n        this.carrierSampleNode.start(0);\n\n    }\n\n    private vocode() {\n        if(!this.audioContext) return;\n\n        if (this.vocoding) {\n            if (this.modulatorNode) {\n                this.modulatorNode.stop(0);\n            }\n            this.shutOffCarrier();\n            this.vocoding = false;\n            return;\n        }\n\n        this.createCarriersAndPlay(this.carrierInput);\n\n        this.vocoding = true;\n\n        this.modulatorGain = this.audioContext.createGain();\n        this.modulatorGain.gain.value = this.modulatorGainValue;\n\n        if(this.modulatorBuffer) {\n            this.modulatorNode = this.audioContext.createBufferSource();\n            this.modulatorNode.buffer = this.modulatorBuffer;\n            this.modulatorNode.connect(this.modulatorGain);\n            this.modulatorNode.start(0);\n        }\n\n        if (this.modulatorInput)\n            this.modulatorGain.connect(this.modulatorInput);\n    }\n}\n","import AbstractAudioFilter from \"./interfaces/AbstractAudioFilter\";\nimport { AudioFilterNodes } from \"../model/AudioNodes\";\nimport Constants from \"../model/Constants\";\nimport Vocoder from \"../utils/Vocoder\";\n\nexport default class VocoderFilter extends AbstractAudioFilter {\n\n    getNode(context: BaseAudioContext): AudioFilterNodes {\n        const modulatorBuffer = this.bufferFetcherService?.getAudioBuffer(Constants.VOCODER_MODULATOR);\n\n        const vocoder = new Vocoder(context, modulatorBuffer!);\n        vocoder.init();\n\n        const { modulatorGain, outputGain } = vocoder.getNodes();\n\n        return {\n            input: modulatorGain!,\n            output: outputGain!\n        };\n    }\n\n    getSettings() {\n        return {};\n    }\n\n    setSetting(): Promise<void> {\n        throw new Error(\"Method not implemented.\");\n    }\n    \n    get order(): number {\n        return 1;\n    }\n\n    get id(): string {\n        return Constants.FILTERS_NAMES.VOCODER;\n    }\n}\n","import Constants from \"../model/Constants\";\nimport { ConfigService } from \"../services/ConfigService\";\n\n/**\n * Default implementation for a ConfigService, using a built-in map.\n * The configuration is not stored in localstorage in this case.\n */\nexport default class GenericConfigService implements ConfigService {\n\n    private mapConfig = new Map<string, string>();\n\n    getConfig(key: string): string | undefined | null {\n        return this.mapConfig.get(key);\n    }\n\n    setConfig(key: string, value: string): void {\n        this.mapConfig.set(key, value);\n    }\n\n    isCompatibilityModeEnabled(): boolean {\n        return this.getConfig(Constants.PREFERENCES_KEYS.COMPATIBILITY_MODE_ENABLED) == \"true\";\n    }\n\n    isCompatibilityModeChecked(): boolean {\n        return this.getConfig(Constants.PREFERENCES_KEYS.COMPATIBILITY_MODE_CHECKED) == \"true\";\n    }\n\n    isAudioWorkletEnabled(): boolean {\n        const setting = this.getConfig(Constants.PREFERENCES_KEYS.ENABLE_AUDIO_WORKLET);\n\n        if(setting != null) {\n            return setting == \"true\";\n        }\n\n        return Constants.ENABLE_AUDIO_WORKLET;\n    }\n\n    isSoundtouchAudioWorkletEnabled(): boolean {\n        const setting = this.getConfig(Constants.PREFERENCES_KEYS.ENABLE_SOUNDTOUCH_AUDIO_WORKLET);\n\n        if(setting != null) {\n            return setting == \"true\";\n        }\n\n        return Constants.ENABLE_SOUNDTOUCH_AUDIO_WORKLET;\n    }\n\n    getBufferSize(): number {\n        const setting = this.getConfig(Constants.PREFERENCES_KEYS.BUFFER_SIZE);\n\n        if(setting != null) {\n            return parseInt(setting);\n        }\n\n        return Constants.DEFAULT_BUFFER_SIZE;\n    }\n\n    getSampleRate(): number {\n        const setting = this.getConfig(Constants.PREFERENCES_KEYS.SAMPLE_RATE);\n\n        if(setting != null) {\n            return parseInt(setting);\n        }\n\n        return Constants.DEFAULT_SAMPLE_RATE;\n    }\n\n    enableCompatibilityMode() {\n        this.setConfig(Constants.PREFERENCES_KEYS.COMPATIBILITY_MODE_ENABLED, \"true\");\n    }\n\n    disableCompatibilityMode() {\n        this.setConfig(Constants.PREFERENCES_KEYS.COMPATIBILITY_MODE_ENABLED, \"false\");\n    }\n};\n","var WORKER_ENABLED = !!(global === global.window && global.URL && global.Blob && global.Worker);\n\nfunction InlineWorker(func, self) {\n  var _this = this;\n  var functionBody;\n\n  self = self || {};\n\n  if (WORKER_ENABLED) {\n    functionBody = func.toString().trim().match(\n      /^function\\s*\\w*\\s*\\([\\w\\s,]*\\)\\s*{([\\w\\W]*?)}$/\n    )[1];\n\n    return new global.Worker(global.URL.createObjectURL(\n      new global.Blob([ functionBody ], { type: \"text/javascript\" })\n    ));\n  }\n\n  function postMessage(data) {\n    setTimeout(function() {\n      _this.onmessage({ data: data });\n    }, 0);\n  }\n\n  this.self = self;\n  this.self.postMessage = postMessage;\n\n  setTimeout(func.bind(self, self), 0);\n}\n\nInlineWorker.prototype.postMessage = function postMessage(data) {\n  var _this = this;\n\n  setTimeout(function() {\n    _this.self.onmessage({ data: data });\n  }, 0);\n};\n\nmodule.exports = InlineWorker;\n","// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n//@ts-ignore\nimport InlineWorker from \"inline-worker\";\nimport RecorderConfig from \"../model/RecorderConfig\";\n\nconst self = {};\nexport default function getRecorderWorker(): Worker {\n    return new InlineWorker(function (this: Worker) {\n        let recLength = 0,\n            recBuffers: Float32Array[][] = [],\n            sampleRate: number,\n            numChannels: number;\n\n        this.onmessage = function (e) {\n            switch (e.data.command) {\n            case \"init\":\n                init(e.data.config);\n                break;\n            case \"record\":\n                record(e.data.buffer);\n                break;\n            case \"exportWAV\":\n                exportWAV(e.data.type);\n                break;\n            case \"getBuffer\":\n                getBuffer();\n                break;\n            case \"clear\":\n                clear();\n                break;\n            }\n        };\n\n        const init = (config: RecorderConfig) => {\n            sampleRate = config.sampleRate;\n            numChannels = config.numChannels;\n            initBuffers();\n        };\n\n        const record = (inputBuffer: Float32Array[]) => {\n            for (let channel = 0; channel < numChannels; channel++) {\n                recBuffers[channel].push(inputBuffer[channel]);\n            }\n            recLength += inputBuffer[0].length;\n        };\n\n        const exportWAV = (type: string) => {\n            const buffers = [];\n            for (let channel = 0; channel < numChannels; channel++) {\n                buffers.push(mergeBuffers(recBuffers[channel], recLength));\n            }\n            let interleaved;\n            if (numChannels === 2) {\n                interleaved = interleave(buffers[0], buffers[1]);\n            } else {\n                interleaved = buffers[0];\n            }\n            const dataview = encodeWAV(interleaved);\n            const audioBlob = new Blob([dataview], { type: type });\n\n            this.postMessage({ command: \"exportWAV\", data: audioBlob });\n        };\n\n        const getBuffer = () => {\n            const buffers = [];\n            for (let channel = 0; channel < numChannels; channel++) {\n                buffers.push(mergeBuffers(recBuffers[channel], recLength));\n            }\n            this.postMessage({ command: \"getBuffer\", data: buffers });\n        };\n\n        const clear = () => {\n            recLength = 0;\n            recBuffers = [];\n            initBuffers();\n        };\n\n        const initBuffers = () => {\n            for (let channel = 0; channel < numChannels; channel++) {\n                recBuffers[channel] = [];\n            }\n        };\n\n        const mergeBuffers = (recBuffers: Float32Array[], recLength: number) => {\n            const result = new Float32Array(recLength);\n            let offset = 0;\n            for (let i = 0; i < recBuffers.length; i++) {\n                if (recBuffers[i]) {\n                    result.set(recBuffers[i], offset);\n                    offset += recBuffers[i].length;\n                } else {\n                    console.warn(\"RecorderWorker: undefined buffer has been detected\");\n                }\n            }\n            return result;\n        };\n\n        const interleave = (inputL: Float32Array, inputR: Float32Array) => {\n            const length = inputL.length + inputR.length;\n            const result = new Float32Array(length);\n\n            let index = 0,\n                inputIndex = 0;\n\n            while (index < length) {\n                result[index++] = inputL[inputIndex];\n                result[index++] = inputR[inputIndex];\n                inputIndex++;\n            }\n            return result;\n        };\n\n        const floatTo16BitPCM = (output: DataView, offset: number, input: Float32Array) => {\n            for (let i = 0; i < input.length; i++, offset += 2) {\n                const s = Math.max(-1, Math.min(1, input[i]));\n                output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);\n            }\n        };\n\n        const writeString = (view: DataView, offset: number, string: string) => {\n            for (let i = 0; i < string.length; i++) {\n                view.setUint8(offset + i, string.charCodeAt(i));\n            }\n        };\n\n        const encodeWAV = (samples: Float32Array) => {\n            const buffer = new ArrayBuffer(44 + samples.length * 2);\n            const view = new DataView(buffer);\n\n            /* RIFF identifier */\n            writeString(view, 0, \"RIFF\");\n            /* RIFF chunk length */\n            view.setUint32(4, 36 + samples.length * 2, true);\n            /* RIFF type */\n            writeString(view, 8, \"WAVE\");\n            /* format chunk identifier */\n            writeString(view, 12, \"fmt \");\n            /* format chunk length */\n            view.setUint32(16, 16, true);\n            /* sample format (raw) */\n            view.setUint16(20, 1, true);\n            /* channel count */\n            view.setUint16(22, numChannels, true);\n            /* sample rate */\n            view.setUint32(24, sampleRate, true);\n            /* byte rate (sample rate * block align) */\n            view.setUint32(28, sampleRate * 4, true);\n            /* block align (channel count * bytes per sample) */\n            view.setUint16(32, numChannels * 2, true);\n            /* bits per sample */\n            view.setUint16(34, 16, true);\n            /* data chunk identifier */\n            writeString(view, 36, \"data\");\n            /* data chunk length */\n            view.setUint32(40, samples.length * 2, true);\n\n            floatTo16BitPCM(view, 44, samples);\n\n            return view;\n        };\n    }, self);\n};\n","import Constants from \"../model/Constants\";\nimport { RecorderCallback, RecorderCallbacks } from \"../model/RecorderCallback\";\nimport RecorderConfig from \"../model/RecorderConfig\";\nimport RecorderWorkerMessage from \"../model/RecorderWorkerMessage\";\nimport RecorderWorkletMessage from \"../model/RecorderWorkletMessage\";\nimport utilFunctions from \"../utils/Functions\";\nimport getRecorderWorker from \"./RecorderWorker\";\n\nexport class Recorder {\n\n    // Inline Worker\n    private worker: Worker | null = null;\n    private node: ScriptProcessorNode | AudioWorkletNode | null = null;\n    private context: BaseAudioContext | null = null;\n\n    private config: RecorderConfig = {\n        bufferLen: 4096,\n        sampleRate: 44100,\n        numChannels: 2,\n        mimeType: \"audio/wav\",\n        callback: () => { }\n    };\n\n    private callbacks: RecorderCallbacks = {\n        getBuffer: [],\n        exportWAV: []\n    };\n\n    recording = false;\n\n    constructor(cfg: RecorderConfig) {\n        Object.assign(this.config, cfg);\n    }\n\n    async setup(source: AudioNode) {\n        if (this.node) { // Disconnect previous node\n            if (this.node instanceof AudioWorkletNode) {\n                this.node.port.postMessage(\"stop\");\n            }\n\n            this.node.disconnect();\n        }\n\n        if (source) {\n            this.context = source.context;\n\n            await this.createRecorderNode();\n\n            if (this.node && this.context) {\n                source.connect(this.node);\n                this.node.connect(this.context.destination);    //this should not be necessary\n            }\n        }\n\n        if (this.context && !this.worker) {\n            this.worker = getRecorderWorker();\n\n            if (this.worker) {\n                this.worker.postMessage({\n                    command: \"init\",\n                    config: {\n                        sampleRate: this.context.sampleRate,\n                        numChannels: this.config.numChannels\n                    }\n                });\n\n                this.worker.onmessage = (e: RecorderWorkerMessage) => {\n                    let callbacks = null;\n\n                    switch (e.data.command) {\n                    case \"getBuffer\":\n                        callbacks = this.callbacks.getBuffer;\n                        break;\n                    case \"exportWAV\":\n                        callbacks = this.callbacks.exportWAV;\n                        break;\n                    }\n\n                    if (callbacks) {\n                        const cb = callbacks.pop();\n                        if (typeof cb == \"function\") {\n                            (cb as RecorderCallback<Blob | Float32Array[]>)(e.data.data);\n                        }\n                    }\n                };\n            }\n        }\n    }\n\n\n    private async createRecorderNode() {\n        if (this.context) {\n            if (utilFunctions.isAudioWorkletCompatible(this.context) && Constants.ENABLE_RECORDER_AUDIO_WORKLET) {\n                try {\n                    await this.createRecorderWorklet();\n                } catch(e) {\n                    this.createRecorderScriptProcessorNode();\n                }\n            } else {\n                this.createRecorderScriptProcessorNode();\n            }\n        }\n    }\n\n    private async createRecorderWorklet() {\n        if (this.context) {\n            await this.context.audioWorklet.addModule(Constants.WORKLET_PATHS.RECORDER_WORKLET);\n\n            this.node = new AudioWorkletNode(this.context, Constants.WORKLET_NAMES.RECORDER_WORKLET);\n\n            if (this.node && this.node.port) {\n                const numChannelParameter = this.node.parameters.get(\"numChannels\");\n\n                if(numChannelParameter) {\n                    numChannelParameter.value = this.config.numChannels;\n                    numChannelParameter.setValueAtTime(this.config.numChannels, 0);\n                }\n\n                this.node.port.onmessage = (e: MessageEvent<RecorderWorkletMessage>) => {\n                    if (this.worker && e.data.command == \"record\" && e.data.buffer.length > 0) {\n                        this.worker.postMessage({\n                            command: \"record\",\n                            buffer: e.data.buffer\n                        });\n                    }\n                };\n            }\n        }\n    }\n\n    private createRecorderScriptProcessorNode() {\n        if (this.context) {\n            this.node = (this.context.createScriptProcessor).call(this.context,\n                this.config.bufferLen, this.config.numChannels, this.config.numChannels);\n\n            this.node.onaudioprocess = (e) => {\n                if (!this.recording) return;\n\n                const buffer = [];\n                for (let channel = 0; channel < this.config.numChannels; channel++) {\n                    buffer.push(e.inputBuffer.getChannelData(channel));\n                }\n\n                if (this.worker) {\n                    this.worker.postMessage({\n                        command: \"record\",\n                        buffer: buffer\n                    });\n                }\n            };\n        }\n    }\n\n    record() {\n        this.recording = true;\n\n        if (this.node instanceof AudioWorkletNode) {\n            this.node.port.postMessage(\"record\");\n        }\n    }\n\n    stop() {\n        this.recording = false;\n\n        if (this.node instanceof AudioWorkletNode) {\n            this.node.port.postMessage(\"stop\");\n        }\n    }\n\n    clear() {\n        if (this.worker) {\n            this.worker.postMessage({ command: \"clear\" });\n        }\n    }\n\n    kill() {\n        this.clear();\n        this.stop();\n\n        if (this.worker) {\n            this.worker.terminate();\n        }\n    }\n\n    getBuffer(cb: RecorderCallback<Float32Array[]>) {\n        cb = cb || this.config.callback;\n        if (!cb) throw new Error(\"Callback not set\");\n\n        this.callbacks.getBuffer.push(cb);\n\n        if (this.worker) {\n            this.worker.postMessage({ command: \"getBuffer\" });\n        }\n    }\n\n    exportWAV(cb: RecorderCallback<Blob>, mimeType?: string) {\n        mimeType = mimeType || this.config.mimeType;\n        cb = cb || this.config.callback;\n        if (!cb) throw new Error(\"Callback not set\");\n\n        this.callbacks.exportWAV.push(cb);\n\n        if (this.worker) {\n            this.worker.postMessage({\n                command: \"exportWAV\",\n                type: mimeType\n            });\n        }\n    }\n\n    static forceDownload(blob: Blob, filename: string) {\n        const link = window.document.createElement(\"a\");\n        const url = (window.URL || window.webkitURL).createObjectURL(blob);\n        window.document.body.appendChild(link);\n        link.href = url;\n        link.download = filename || \"output.wav\";\n        link.click();\n        window.URL.revokeObjectURL(url);\n    }\n};\n\nexport default Recorder;\n","/*\n * Copyright (C) 2019-2023 Eliastik (eliastiksofts.com)\n *\n * This file is part of \"Simple Voice Changer\".\n *\n * \"Simple Voice Changer\" is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * \"Simple Voice Changer\" is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with \"Simple Voice Changer\".  If not, see <http://www.gnu.org/licenses/>.\n */\nexport default class TimerSaveTime {\n    seconds = 0;\n    initialSeconds = 0;\n    interval: number | null = null;\n    incr = 1;\n\n    private countCallback: () => void = () => {};\n\n    constructor(seconds: number, incr: number) {\n        this.seconds = seconds;\n        this.initialSeconds = seconds;\n        this.interval;\n        this.incr = incr;\n    }\n\n    start() {\n        this.interval = window.setInterval(() => this.count(), 1000);\n    }\n\n    stop() {\n        clearInterval(this.interval!);\n    }\n\n    count() {\n        this.seconds += this.incr;\n\n        if(this.seconds <= 0) {\n            this.stop();\n        }\n\n        if(this.countCallback) {\n            this.countCallback();\n        }\n    }\n\n    onCount(callback: () => void) {\n        this.countCallback = callback;\n    }\n}","import AbstractAudioElement from \"./filters/interfaces/AbstractAudioElement\";\nimport AbstractAudioFilter from \"./filters/interfaces/AbstractAudioFilter\";\nimport AudioFilterEntrypointInterface from \"./filters/interfaces/AudioFilterEntrypointInterface\";\nimport AbstractAudioRenderer from \"./filters/interfaces/AbstractAudioRenderer\";\nimport BassBoosterFilter from \"./filters/BassBoosterFilter\";\nimport BitCrusherFilter from \"./filters/BitCrusherFilter\";\nimport EchoFilter from \"./filters/EchoFilter\";\nimport HighPassFilter from \"./filters/HighPassFilter\";\nimport LimiterFilter from \"./filters/LimiterFilter\";\nimport LowPassFilter from \"./filters/LowPassFilter\";\nimport ReturnAudioRenderer from \"./filters/ReturnAudioRenderer\";\nimport ReverbFilter from \"./filters/ReverbFilter\";\nimport SoundtouchWrapperFilter from \"./filters/SountouchWrapperFilter\";\nimport TelephonizerFilter from \"./filters/TelephonizerFilter\";\nimport utils from \"./utils/Functions\";\nimport BufferPlayer from \"./BufferPlayer\";\nimport BufferFetcherService from \"./services/BufferFetcherService\";\nimport EventEmitter from \"./utils/EventEmitter\";\nimport { EventType } from \"./model/EventTypeEnum\";\nimport Constants from \"./model/Constants\";\nimport AbstractAudioFilterWorklet from \"./filters/interfaces/AbstractAudioFilterWorklet\";\nimport { AudioFilterNodes } from \"./model/AudioNodes\";\nimport VocoderFilter from \"./filters/VocoderFilter\";\nimport { ConfigService } from \"./services/ConfigService\";\nimport utilFunctions from \"./utils/Functions\";\nimport { FilterSettings } from \"./model/filtersSettings/FilterSettings\";\nimport RecorderWorkerMessage from \"./model/RecorderWorkerMessage\";\nimport { EventEmitterCallback } from \"./model/EventEmitterCallback\";\nimport { FilterState } from \"./model/FilterState\";\nimport GenericConfigService from \"./utils/GenericConfigService\";\nimport getRecorderWorker from \"./recorder/RecorderWorker\";\nimport { Recorder } from \"./recorder/Recorder\";\nimport ReverbSettings from \"./model/filtersSettings/ReverbSettings\";\n\nexport default class AudioEditor extends AbstractAudioElement {\n\n    /** The current audio context */\n    private currentContext: AudioContext | null | undefined;\n    /** The audio buffer to be processed */\n    private principalBuffer: AudioBuffer | null = null;\n    /** The sum of all the samples of the principal buffer,\n     * used to detect the need to enable the compatibility mode */\n    private sumPrincipalBuffer: number = 0;\n    /** The resulting audio buffer */\n    private renderedBuffer: AudioBuffer | null = null;\n    /** The entrypoint filter */\n    private entrypointFilter: (AbstractAudioFilter & AudioFilterEntrypointInterface) | null = null;\n    /** A list of filters */\n    private filters: AbstractAudioFilter[] = [];\n    /** A list of renderers */\n    private renderers: AbstractAudioRenderer[] = [];\n    /** The audio player */\n    private bufferPlayer: BufferPlayer | undefined;\n    /** The event emitter */\n    private eventEmitter: EventEmitter | undefined;\n    /** The current connected nodes */\n    private currentNodes: AudioFilterNodes | null = null;\n\n    /** If we are currently processing and downloading the buffer */\n    private savingBuffer = false;\n    /** The previous sample rate setting */\n    private previousSampleRate = Constants.DEFAULT_SAMPLE_RATE;\n    /** List of audio buffers to fetch */\n    private audioBuffersToFetch: string[] = [];\n\n    /** Callback used when saving audio */\n    private playingStoppedCallback: (() => void) | null = null;\n\n    /** True if we are downloading initial buffer data */\n    downloadingInitialData = false;\n\n    constructor(context?: AudioContext | null, player?: BufferPlayer, eventEmitter?: EventEmitter, configService?: ConfigService, audioBuffersToFetch?: string[]) {\n        super();\n\n        this.currentContext = context;\n        this.eventEmitter = eventEmitter || new EventEmitter();\n        this.bufferPlayer = player || new BufferPlayer(context!);\n        this.configService = configService || new GenericConfigService();\n        this.bufferFetcherService = new BufferFetcherService(this.currentContext!, this.eventEmitter);\n        this.audioBuffersToFetch = audioBuffersToFetch || [];\n\n        // Callback called just before starting audio player\n        this.setup();\n    }\n\n    private setup() {\n        if (this.configService) {\n            this.previousSampleRate = this.configService.getSampleRate();\n\n            if (this.eventEmitter) {\n                this.eventEmitter.emit(EventType.SAMPLE_RATE_CHANGED, this.previousSampleRate);\n            }\n        }\n\n        if (!this.currentContext) {\n            this.createNewContext(this.previousSampleRate);\n        }\n\n        if (this.bufferPlayer) {\n            // Callback called just before starting playing audio, when compatibility mode is enabled\n            this.bufferPlayer.onBeforePlaying(async () => {\n                if (this.bufferPlayer && this.bufferPlayer.compatibilityMode && this.currentContext) {\n                    await this.setupOutput(this.currentContext);\n                }\n            });\n\n            // Callback called when playing is finished\n            this.bufferPlayer.on(EventType.PLAYING_FINISHED, () => {\n                if(this.savingBuffer && this.playingStoppedCallback) {\n                    this.off(EventType.PLAYING_STOPPED, this.playingStoppedCallback);\n                }\n\n                if (this.bufferPlayer && this.bufferPlayer.loop) {\n                    this.bufferPlayer.start();\n                }\n            });\n        }\n\n        this.setupDefaultFilters();\n        this.setupDefaultRenderers();\n\n        if (this.audioBuffersToFetch.length > 0) {\n            this.fetchBuffers(false);\n        }\n    }\n\n    /**\n     * Add a new custom filter for this audio editor\n     * @param filters One or more AbstractAudioFilter\n     */\n    addFilters(...filters: AbstractAudioFilter[]) {\n        for (const filter of filters) {\n            filter.initializeDefaultSettings();\n            filter.bufferFetcherService = this.bufferFetcherService;\n            filter.configService = this.configService;\n        }\n\n        this.filters.push(...filters);\n    }\n\n    /**\n     * Add a new custom renderer for this audio editor\n     * @param renderers One or more AbstractAudioRenderer\n     */\n    addRenderers(...renderers: AbstractAudioRenderer[]) {\n        for (const renderer of renderers) {\n            renderer.bufferFetcherService = this.bufferFetcherService;\n            renderer.configService = this.configService;\n        }\n\n        this.renderers.push(...renderers);\n    }\n\n    /** Setup all audio filters */\n    private setupDefaultFilters() {\n        const bassBooster = new BassBoosterFilter(200, 15, 200, -2);\n        const bitCrusher = new BitCrusherFilter(16, 0.9);\n        const echo = new EchoFilter(0.2, 0.75);\n        const highPass = new HighPassFilter(3500);\n        const lowPass = new LowPassFilter(3500);\n        const reverb = new ReverbFilter();\n        const soundtouchWrapper = new SoundtouchWrapperFilter();\n        const limiterFilter = new LimiterFilter(0, 0, 0, 3, -0.05, 0.1);\n        const telephonizerFilter = new TelephonizerFilter();\n        const vocoder = new VocoderFilter();\n\n        this.entrypointFilter = soundtouchWrapper;\n        this.addFilters(bassBooster, bitCrusher, echo, highPass, lowPass, reverb, limiterFilter, telephonizerFilter, soundtouchWrapper, vocoder);\n    }\n\n    /** Setup the renderers */\n    private setupDefaultRenderers() {\n        const returnAudio = new ReturnAudioRenderer();\n        this.addRenderers(returnAudio);\n    }\n\n    /**\n     * Fetch default buffers from network\n     * @param refetch true if we need to refetch the buffers\n     */\n    private async fetchBuffers(refetch: boolean) {\n        if (this.downloadingInitialData || !this.bufferFetcherService) {\n            return;\n        }\n\n        this.downloadingInitialData = true;\n\n        if (this.eventEmitter && !refetch) {\n            this.eventEmitter.emit(EventType.LOADING_BUFFERS);\n        }\n\n        try {\n            await this.bufferFetcherService.fetchAllBuffers(this.audioBuffersToFetch);\n            this.downloadingInitialData = false;\n\n            if (this.eventEmitter && !refetch) {\n                this.eventEmitter.emit(EventType.LOADED_BUFFERS);\n            }\n        } catch (e) {\n            if (this.eventEmitter && !refetch) {\n                this.eventEmitter.emit(EventType.LOADING_BUFFERS_ERROR);\n            }\n        }\n    }\n\n    /**\n     * Create new context if needed, for example if sample rate setting have changed\n     */\n    private async createNewContextIfNeeded() {\n        const isCompatibilityModeEnabled = this.configService && this.configService.isCompatibilityModeEnabled();\n\n        if (isCompatibilityModeEnabled && this.principalBuffer) {\n            // If compatibility mode is enabled, we use the sample rate of the input audio buffer\n            if (this.currentSampleRate != this.principalBuffer.sampleRate) {\n                await this.createNewContext(this.principalBuffer.sampleRate);\n                this.previousSampleRate = this.principalBuffer.sampleRate;\n\n                // We need to refetch all buffers of the fetcher\n                await this.resetBufferFetcher();\n            }\n        } else {\n            // Otherwise we change the context if the sample rate has changed\n            let currentSampleRate = Constants.DEFAULT_SAMPLE_RATE;\n\n            if (this.configService) {\n                currentSampleRate = this.configService.getSampleRate();\n            }\n\n            // If sample rate setting has changed, create a new audio context\n            if (currentSampleRate != this.previousSampleRate) {\n                await this.createNewContext(currentSampleRate);\n                this.previousSampleRate = currentSampleRate;\n\n                // We need to refetch all buffers of the fetcher\n                await this.resetBufferFetcher();\n            }\n        }\n    }\n\n    /**\n     * Reset the buffer fetcher and redownload the buffers. Used when changing sample rate.\n     */\n    private async resetBufferFetcher() {\n        if (this.bufferFetcherService) {\n            this.bufferFetcherService.reset();\n            await this.fetchBuffers(true);\n\n            // Fetch the current select environment for the reverb filter\n            const filterSettings = this.getFiltersSettings();\n            const reverbSettings = filterSettings.get(Constants.FILTERS_NAMES.REVERB);\n\n            if (reverbSettings) {\n                const reverbUrl = (reverbSettings as ReverbSettings).reverbEnvironment?.value;\n\n                if (reverbUrl) {\n                    await this.bufferFetcherService.fetchBuffer(reverbUrl);\n                }\n            }\n        }\n    }\n\n    /** \n     * Stop previous audio context and create a new one\n     */\n    private async createNewContext(sampleRate: number) {\n        if (this.currentContext) {\n            await this.currentContext.close();\n        }\n\n        const options: AudioContextOptions = {\n            latencyHint: \"interactive\"\n        };\n\n        if (sampleRate != 0) {\n            options.sampleRate = sampleRate;\n        }\n\n        this.currentContext = new AudioContext(options);\n\n        if (this.eventEmitter) {\n            this.eventEmitter.emit(EventType.SAMPLE_RATE_CHANGED, this.currentContext.sampleRate);\n        }\n\n        if (this.bufferPlayer) {\n            this.bufferPlayer.updateContext(this.currentContext);\n        }\n\n        if (this.bufferFetcherService) {\n            this.bufferFetcherService.updateContext(this.currentContext);\n        }\n    }\n\n    /** Prepare the AudioContext before use */\n    private async prepareContext() {\n        await this.createNewContextIfNeeded();\n\n        if (this.currentContext) {\n            this.currentContext.resume();\n        }\n    }\n\n    /**\n     * Get the current sample rate used\n     */\n    get currentSampleRate(): number {\n        if (this.currentContext) {\n            return this.currentContext.sampleRate;\n        }\n\n        return 0;\n    }\n\n    /**\n     * Get the default device sample rate\n     */\n    get defaultDeviceSampleRate(): number {\n        const tempContext = new AudioContext();\n        let sampleRate = 0;\n\n        if (tempContext) {\n            sampleRate = tempContext.sampleRate;\n            tempContext.close();\n        }\n\n        return sampleRate;\n    }\n\n    /** Decode and load an audio buffer from an audio file */\n    async loadBufferFromFile(file: File) {\n        this.principalBuffer = null;\n\n        await this.prepareContext();\n\n        if (this.currentContext) {\n            this.principalBuffer = await utilFunctions.loadAudioBuffer(this.currentContext, file);\n            this.sumPrincipalBuffer = utils.sumAudioBuffer(this.principalBuffer);\n        } else {\n            throw new Error(\"Audio Context is not ready!\");\n        }\n    }\n\n    /** Change the principal audio buffer of this editor */\n    loadBuffer(audioBuffer: AudioBuffer) {\n        this.principalBuffer = audioBuffer;\n        this.sumPrincipalBuffer = utils.sumAudioBuffer(this.principalBuffer);\n    }\n\n    /**\n     * Connect the Audio API nodes of the enabled filters\n     * @param context The Audio Context\n     * @param buffer  The Audio Buffer\n     * @param keepCurrentInputOutput Keep current first input/output nodes?\n     */\n    private async connectNodes(context: BaseAudioContext, buffer: AudioBuffer, keepCurrentInputOutput: boolean, isCompatibilityMode: boolean) {\n        if (!this.entrypointFilter) {\n            return;\n        }\n\n        let entrypointNode: AudioNode | null = null;\n\n        if (keepCurrentInputOutput && this.currentNodes) {\n            entrypointNode = this.currentNodes.input;\n        } else {\n            const entrypointNodes = await this.entrypointFilter.getEntrypointNode(context, buffer, !isCompatibilityMode);\n            entrypointNode = entrypointNodes.input;\n        }\n\n        const intermediateNodes: AudioFilterNodes[] = [];\n        let previousNode: AudioNode | undefined = entrypointNode;\n\n        this.disconnectOldNodes(keepCurrentInputOutput);\n\n        // Sort by filter order, then remove the disabled filter (but always keep the last/output filter)\n        const filters = this.filters\n            .sort((a, b) => a.order - b.order)\n            .filter((filter, index) => filter !== this.entrypointFilter && (filter.isEnabled() || index >= this.filters.length - 1));\n\n        for (const filter of filters) {\n            const node = filter.getNode(context);\n\n            if (previousNode) {\n                previousNode.connect(node.input);\n            }\n\n            previousNode = node.output;\n            intermediateNodes.push(node);\n        }\n\n        if (this.entrypointFilter) {\n            this.entrypointFilter.updateState();\n        }\n\n        this.currentNodes = {\n            input: entrypointNode!,\n            output: previousNode!,\n            intermediateNodes: intermediateNodes\n                .filter(n => n.input != previousNode && n.output != previousNode &&\n                    n.input != entrypointNode && n.output != entrypointNode)\n        };\n    }\n\n    /**\n     * Disconnect old audio nodes\n     * @param keepCurrentOutput Keeps current output nodes?\n     */\n    private disconnectOldNodes(keepCurrentOutput: boolean) {\n        if (this.currentNodes) {\n            this.currentNodes.input.disconnect();\n\n            if (!keepCurrentOutput) {\n                this.currentNodes.output.disconnect();\n            }\n\n            if (this.currentNodes.intermediateNodes) {\n                for (const intermediate of this.currentNodes.intermediateNodes) {\n                    intermediate.input.disconnect();\n                    intermediate.output.disconnect();\n                }\n            }\n        }\n    }\n\n    /** Reconnect the nodes if the compatibility/direct mode is enabled */\n    private async reconnectNodesIfNeeded() {\n        if (this.bufferPlayer && this.bufferPlayer.compatibilityMode &&\n            this.currentContext && this.principalBuffer &&\n            this.bufferPlayer && this.entrypointFilter) {\n            await this.connectNodes(this.currentContext, this.principalBuffer, true, this.bufferPlayer.compatibilityMode);\n\n            const speedAudio = this.entrypointFilter.getSpeed();\n            this.bufferPlayer.speedAudio = speedAudio;\n            this.bufferPlayer.duration = this.calculateAudioDuration(speedAudio) * speedAudio;\n        }\n    }\n\n    /** Initialize worklets filters */\n    private async initializeWorklets(context: BaseAudioContext) {\n        for (const filter of this.filters) {\n            if (filter.isWorklet()) {\n                await (filter as AbstractAudioFilterWorklet).initializeWorklet(context);\n            }\n        }\n    }\n\n    /**\n     * Get the rendered audio buffer\n     * @returns The AudioBuffer\n     */\n    getOutputBuffer() {\n        return this.renderedBuffer;\n    }\n\n    /**\n     * Render the audio to a buffer\n     * @returns A promise resolved when the audio processing is finished.\n     * The resulting audio buffer can then be obtained by using the \"getOutputBuffer\" method.\n     */\n    async renderAudio(): Promise<void> {\n        await this.prepareContext();\n\n        if (!this.currentContext) {\n            throw new Error(\"AudioContext is not yet available\");\n        }\n\n        if (!this.entrypointFilter) {\n            throw new Error(\"Entrypoint filter is not available\");\n        }\n\n        const speedAudio = this.entrypointFilter.getSpeed();\n        const durationAudio = this.calculateAudioDuration(speedAudio);\n        const offlineContext = new OfflineAudioContext(2, this.currentContext.sampleRate * durationAudio, this.currentContext.sampleRate);\n        const outputContext = this.configService && this.configService.isCompatibilityModeEnabled() ? this.currentContext : offlineContext;\n\n        let currentBuffer = this.principalBuffer!;\n\n        for (const renderer of this.renderers.sort((a, b) => a.order - b.order)) {\n            if (renderer.isEnabled()) {\n                currentBuffer = await renderer.renderAudio(outputContext, currentBuffer);\n            }\n        }\n\n        this.renderedBuffer = currentBuffer;\n\n        return await this.setupOutput(outputContext, durationAudio, offlineContext);\n    }\n\n    /**\n     * Setup output buffers/nodes, then process the audio\n     * @param outputContext Output audio context\n     * @param durationAudio Duration of the audio buffer\n     * @param offlineContext An offline context to do the rendering (can be omited, in this case the rendering is done in real time - \"compatibility mode\")\n     * @returns A promise resolved when the audio processing is done\n     */\n    private async setupOutput(outputContext: BaseAudioContext, durationAudio?: number, offlineContext?: OfflineAudioContext): Promise<void> {\n        if (this.renderedBuffer && this.configService) {\n            await this.initializeWorklets(outputContext);\n            await this.connectNodes(outputContext, this.renderedBuffer, false, this.configService.isCompatibilityModeEnabled());\n\n            if (this.entrypointFilter && this.bufferPlayer) {\n                const speedAudio = this.entrypointFilter.getSpeed();\n                this.bufferPlayer.speedAudio = speedAudio;\n            }\n\n            if (!this.configService.isCompatibilityModeEnabled() && offlineContext && this.currentNodes) {\n                this.currentNodes.output.connect(outputContext.destination);\n\n                const renderedBuffer = await offlineContext.startRendering();\n                const sumRenderedAudio = utils.sumAudioBuffer(renderedBuffer);\n\n                if (sumRenderedAudio == 0 && this.sumPrincipalBuffer !== 0) {\n                    if (!this.configService.isCompatibilityModeChecked()) {\n                        this.setCompatibilityModeChecked(true);\n                        this.configService.enableCompatibilityMode();\n\n                        if (this.eventEmitter) {\n                            this.eventEmitter.emit(EventType.COMPATIBILITY_MODE_AUTO_ENABLED);\n                        }\n\n                        return await this.setupOutput(this.currentContext!, durationAudio);\n                    }\n\n                    if (this.eventEmitter) {\n                        this.eventEmitter.emit(EventType.RENDERING_AUDIO_PROBLEM_DETECTED);\n                    }\n                }\n\n                this.renderedBuffer = renderedBuffer;\n\n                if (this.bufferPlayer) {\n                    this.bufferPlayer.loadBuffer(this.renderedBuffer);\n                }\n            } else {\n                if (this.bufferPlayer) {\n                    this.bufferPlayer.setCompatibilityMode(this.currentNodes!.output, durationAudio);\n                }\n            }\n        }\n    }\n\n    /**\n     * Calculate approximative audio duration according to enabled filters and their settings\n     * @param speedAudio Current audio speed\n     * @returns The audio duration\n     */\n    private calculateAudioDuration(speedAudio: number): number {\n        if (this.principalBuffer) {\n            let duration = utils.calcAudioDuration(this.principalBuffer, speedAudio);\n\n            for (const filter of this.filters) {\n                if (filter.isEnabled()) {\n                    duration += filter.getAddingTime();\n                }\n            }\n\n            return duration;\n        }\n\n        return 0;\n    }\n\n    get order(): number {\n        return -1;\n    }\n\n    get id(): string {\n        return Constants.AUDIO_EDITOR;\n    }\n\n    isEnabled(): boolean {\n        return true;\n    }\n\n    /**\n     * Check if AudioWorklet are available\n     * @returns boolean\n     */\n    isAudioWorkletAvailable(): boolean {\n        if (this.currentContext) {\n            return utilFunctions.isAudioWorkletCompatible(this.currentContext);\n        }\n\n        return false;\n    }\n\n    /**\n     * Set compatibility/direct audio rendering mode already checked for auto enabling (if an error occurs rendering in offline context)\n     * @param checked boolean\n     */\n    private setCompatibilityModeChecked(checked: boolean) {\n        if (this.configService) {\n            this.configService.setConfig(Constants.PREFERENCES_KEYS.COMPATIBILITY_MODE_CHECKED, \"\" + checked);\n        }\n    }\n\n    /** Filters settings */\n\n    /**\n     * Get enabled/disabled state of all filters/renderers\n     * @returns The filters state (enabled/disabled)\n     */\n    getFiltersState(): FilterState {\n        const state: FilterState = {};\n\n        [...this.filters, ...this.renderers].forEach(filter => {\n            state[filter.id] = filter.isEnabled();\n        });\n\n        return state;\n    }\n\n    /**\n     * Get the settings of all filters/renderers\n     * @returns \n     */\n    getFiltersSettings(): Map<string, FilterSettings> {\n        const settings = new Map<string, FilterSettings>();\n\n        for (const filter of this.filters) {\n            settings.set(filter.id, filter.getSettings());\n        }\n\n        return settings;\n    }\n\n    /**\n     * Toggle enabled/disabled state for a filter/renderer\n     * @param filterId The filter/renderer ID\n     */\n    toggleFilter(filterId: string) {\n        const filter = this.filters.find(f => f.id === filterId);\n        const renderer = this.renderers.find(f => f.id === filterId);\n\n        if (filter) {\n            filter.toggle();\n        }\n\n        if (renderer) {\n            renderer.toggle();\n        }\n\n        this.reconnectNodesIfNeeded();\n    }\n\n    /**\n     * Change a filter/renderer setting\n     * @param filterId Filter ID\n     * @param settings Filter setting (key/value)\n     */\n    async changeFilterSettings(filterId: string, settings: FilterSettings) {\n        const filter = this.filters.find(f => f.id === filterId);\n\n        if (filter) {\n            for (const key of Object.keys(settings)) {\n                await filter.setSetting(key, settings[key]);\n            }\n\n            await this.reconnectNodesIfNeeded();\n        }\n    }\n\n    /**\n     * Reset the settings of a filter/renderer\n     * @param filterId Id of the filter/renderer\n     */\n    resetFilterSettings(filterId: string) {\n        const filter = this.filters.find(f => f.id === filterId);\n\n        if (filter) {\n            filter.resetSettings();\n            this.reconnectNodesIfNeeded();\n        }\n    }\n\n    /**\n     * Reset all filters/renderers state (enabled/disabled) based on their default states\n     */\n    resetAllFiltersState() {\n        [...this.filters, ...this.renderers].forEach(element => {\n            if (element.isDefaultEnabled()) {\n                element.enable();\n            } else {\n                element.disable();\n            }\n        });\n\n        this.reconnectNodesIfNeeded();\n    }\n\n    /** Events and exit */\n\n    /**\n     * Exit/reset the audio editor basic state\n     */\n    exit() {\n        if (this.bufferPlayer) {\n            this.bufferPlayer.stop();\n            this.bufferPlayer.reset();\n            this.principalBuffer = null;\n        }\n    }\n\n    /**\n     * Subscribe to an event\n     * @param event The event ID\n     * @param callback The callback function\n     */\n    on(event: string, callback: EventEmitterCallback) {\n        if (this.eventEmitter) {\n            this.eventEmitter.on(event, callback);\n        }\n    }\n\n    /**\n     * Unsubscribe to an event\n     * @param event The event ID\n     * @param callback The callback function\n     */\n    off(event: string, callback: EventEmitterCallback) {\n        if (this.eventEmitter) {\n            this.eventEmitter.off(event, callback);\n        }\n    }\n\n    /**\n     * Save the rendered audio to a buffer\n     * @returns A promise resolved when the audio buffer is downloaded to the user\n     */\n    saveBuffer(): Promise<boolean> {\n        if (this.savingBuffer) {\n            return Promise.reject();\n        }\n\n        this.savingBuffer = true;\n\n        return new Promise((resolve, reject) => {\n            if (!this.bufferPlayer) {\n                return reject();\n            }\n\n            if (!this.bufferPlayer.compatibilityMode) {\n                if (!this.renderedBuffer || !this.currentContext) {\n                    return resolve(false);\n                }\n\n                const worker = getRecorderWorker();\n\n                if (worker) {\n                    worker.onmessage = (e: RecorderWorkerMessage) => {\n                        if (e.data.command == Constants.EXPORT_WAV_COMMAND) {\n                            this.downloadAudioBlob(e.data.data);\n                        }\n\n                        worker.terminate();\n                        this.savingBuffer = false;\n                        resolve(true);\n                    };\n\n                    worker.postMessage({\n                        command: Constants.INIT_COMMAND,\n                        config: {\n                            sampleRate: this.renderedBuffer.sampleRate,\n                            numChannels: 2\n                        }\n                    });\n\n                    const buffer: Float32Array[] = [];\n\n                    for (let i = 0; i < this.renderedBuffer.numberOfChannels; i++) {\n                        buffer.push(this.renderedBuffer.getChannelData(i));\n                    }\n\n                    worker.postMessage({\n                        command: Constants.RECORD_COMMAND,\n                        buffer\n                    });\n\n                    worker.postMessage({\n                        command: Constants.EXPORT_WAV_COMMAND,\n                        type: Constants.AUDIO_WAV\n                    });\n                }\n            } else {\n                this.bufferPlayer.start().then(() => {\n                    if (!this.configService) {\n                        return reject();\n                    }\n\n                    const rec = new Recorder({\n                        bufferLen: this.configService.getBufferSize(),\n                        sampleRate: this.configService.getSampleRate(),\n                        numChannels: 2,\n                        mimeType: \"audio/wav\"\n                    });\n\n                    rec.setup(this.currentNodes!.output).then(() => {\n                        rec.record();\n\n                        this.playingStoppedCallback = () => {\n                            rec.kill();\n\n                            this.savingBuffer = false;\n                            this.off(EventType.PLAYING_FINISHED, finishedCallback);\n\n                            if (this.playingStoppedCallback) {\n                                this.off(EventType.PLAYING_STOPPED, this.playingStoppedCallback);\n                            }\n\n                            resolve(true);\n                        };\n\n                        const finishedCallback = () => {\n                            if (this.playingStoppedCallback) {\n                                this.off(EventType.PLAYING_STOPPED, this.playingStoppedCallback);\n                            }\n\n                            rec.stop();\n\n                            rec.exportWAV((blob: Blob) => {\n                                this.downloadAudioBlob(blob);\n\n                                this.savingBuffer = false;\n                                this.off(EventType.PLAYING_FINISHED, finishedCallback);\n                                rec.kill();\n\n                                resolve(true);\n                            });\n                        };\n\n                        this.on(EventType.PLAYING_FINISHED, finishedCallback);\n                        this.on(EventType.PLAYING_STOPPED, this.playingStoppedCallback);\n                    });\n                });\n            }\n        });\n    }\n\n    /**\n     * Download an audio Blob\n     * @param blob The blob\n     */\n    private downloadAudioBlob(blob: Blob) {\n        Recorder.forceDownload(blob, \"audio-\" + new Date().toISOString() + \".wav\");\n    }\n}\n","\n/*\n * Copyright (C) 2019-2023 Eliastik (eliastiksofts.com)\n *\n * This file is part of \"Simple Voice Changer\".\n *\n * \"Simple Voice Changer\" is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * \"Simple Voice Changer\" is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with \"Simple Voice Changer\".  If not, see <http://www.gnu.org/licenses/>.\n */\n// The Voice Recorder class\n// Used to record a sound (voice, etc.) with the user microphone\n// Offer control with play/pause and audio feedback\nimport TimerSaveTime from \"./utils/TimerSaveTime\";\nimport EventEmitter from \"./utils/EventEmitter\";\nimport { EventType } from \"./model/EventTypeEnum\";\nimport AudioConstraintWrapper from \"./model/AudioConstraintWrapper\";\nimport { RecorderSettings } from \"./model/RecorderSettings\";\nimport { ConfigService } from \"./services/ConfigService\";\nimport AbstractAudioElement from \"./filters/interfaces/AbstractAudioElement\";\nimport Constants from \"./model/Constants\";\nimport { EventEmitterCallback } from \"./model/EventEmitterCallback\";\nimport AudioConstraint from \"./model/AudioConstraint\";\nimport Recorder from \"./recorder/Recorder\";\n\nexport default class VoiceRecorder extends AbstractAudioElement {\n\n    private context: AudioContext | null | undefined;\n    private input: MediaStreamAudioSourceNode | null = null;\n    private stream: MediaStream | null = null;\n    private recorder: Recorder | null = null;\n    private alreadyInit = false;\n    private timer: TimerSaveTime | null = null;\n    private enableAudioFeedback = false;\n    private recording = false;\n    private deviceList: MediaDeviceInfo[] = [];\n    private constraints: AudioConstraintWrapper = {\n        audio: {\n            noiseSuppression: true,\n            echoCancellation: true,\n            autoGainControl: true\n        }\n    };\n    private eventEmitter: EventEmitter | null = null;\n    private previousSampleRate = Constants.DEFAULT_SAMPLE_RATE;\n\n    constructor(context?: AudioContext | null, eventEmitter?: EventEmitter, configService?: ConfigService) {\n        super();\n        this.context = context;\n        this.eventEmitter = eventEmitter || new EventEmitter();\n        this.configService = configService || null;\n\n        if (this.configService) {\n            this.previousSampleRate = this.configService.getSampleRate();\n        }\n    }\n\n    /** Initialize this voice recorder */\n    async init() {\n        if (!this.isRecordingAvailable()) {\n            return;\n        }\n\n        if (!this.context) {\n            await this.createNewContext(this.previousSampleRate);\n        } else {\n            await this.createNewContextIfNeeded();\n        }\n\n        this.eventEmitter?.emit(EventType.RECORDER_INIT);\n\n        try {\n            const stream = await navigator.mediaDevices.getUserMedia(this.constraints);\n\n            if (this.context) {\n                this.context.resume();\n            }\n\n            await this.setup(stream, false, false);\n\n            this.alreadyInit = true;\n            this.timer = new TimerSaveTime(0, 1);\n\n            this.timer.onCount(() => {\n                this.eventEmitter?.emit(EventType.RECORDER_COUNT_UPDATE);\n            });\n\n            this.successCallback();\n        } catch (e) {\n            this.errorCallback();\n        }\n\n        navigator.mediaDevices.ondevicechange = () => this.updateInputList();\n    }\n\n    /**\n     * Create new context if needed, for example if sample rate setting have changed\n     */\n    private async createNewContextIfNeeded() {\n        let currentSampleRate = Constants.DEFAULT_SAMPLE_RATE;\n\n        if (this.configService) {\n            currentSampleRate = this.configService.getSampleRate();\n        }\n\n        // If sample rate setting has changed, create a new audio context\n        if (currentSampleRate != this.previousSampleRate) {\n            await this.createNewContext(currentSampleRate);\n            this.previousSampleRate = currentSampleRate;\n        }\n    }\n\n    /** \n     * Stop previous audio context and create a new one\n     */\n    private async createNewContext(sampleRate: number) {\n        if (this.context) {\n            await this.context.close();\n        }\n\n        const options: AudioContextOptions = {\n            latencyHint: \"balanced\"\n        };\n\n        if (sampleRate != 0) {\n            options.sampleRate = sampleRate;\n        }\n\n        this.context = new AudioContext(options);\n    }\n\n    private successCallback() {\n        this.eventEmitter?.emit(EventType.RECORDER_SUCCESS);\n    }\n\n    private errorCallback() {\n        this.eventEmitter?.emit(EventType.RECORDER_ERROR);\n    }\n\n    /**\n     * Enable or disable audio feedback\n     * @param enable boolean\n     */\n    audioFeedback(enable: boolean) {\n        if (this.context) {\n            if (enable) {\n                this.input && this.input.connect(this.context.destination);\n                this.enableAudioFeedback = true;\n            } else {\n                this.input && this.input.connect(this.context.destination) && this.input.disconnect(this.context.destination);\n                this.enableAudioFeedback = false;\n            }\n\n            this.eventEmitter?.emit(EventType.RECORDER_UPDATE_CONSTRAINTS);\n        }\n    }\n\n    /**\n     * Get current constraints/settings\n     * @returns MediaTrackSettings\n     */\n    private getConstraints() {\n        if (this.stream) {\n            const tracks = this.stream.getTracks();\n\n            if (tracks && tracks.length > 0) {\n                return tracks[0].getSettings();\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Update the current constraints\n     */\n    private updateConstraints() {\n        const constraints = this.getConstraints();\n\n        if (constraints) {\n            this.constraints.audio = Object.assign(this.constraints.audio, constraints);\n            this.eventEmitter?.emit(EventType.RECORDER_UPDATE_CONSTRAINTS);\n        }\n    }\n\n    /**\n     * Reset the current constraints\n     * @param newConstraint AudioConstraintWrapper\n     */\n    private async resetConstraints(newConstraint?: AudioConstraintWrapper) {\n        if (this.stream) {\n            const precAudioFeedback = this.enableAudioFeedback;\n            const precRecording = this.recording;\n            const tracks = this.stream.getTracks();\n\n            if (newConstraint) {\n                this.updateConstraints();\n                this.constraints.audio = Object.assign(this.constraints.audio, newConstraint.audio);\n            }\n\n            if (tracks && tracks.length > 0) {\n                try {\n                    await tracks[0].applyConstraints(this.constraints.audio);\n\n                    const newConstraints = this.getConstraints();\n                    const newConstraintName = newConstraint ? Object.keys(newConstraint.audio)[0] : \"\";\n\n                    this.audioFeedback(false);\n                    this.pause();\n\n                    if (!newConstraint ||\n                        (newConstraints && (newConstraints as AudioConstraint)[newConstraintName] != newConstraint.audio[newConstraintName])) {\n                        this.stopStream();\n\n                        const stream = await navigator.mediaDevices.getUserMedia(this.constraints);\n\n                        await this.setup(stream, precRecording, precAudioFeedback);\n                    } else {\n                        await this.setup(null, precRecording, precAudioFeedback);\n                    }\n                } catch (e) {\n                    this.errorCallback();\n                }\n            }\n        }\n    }\n\n    /**\n     * Setup this voice recorder\n     * @param stream MediaStream\n     * @param precRecording Was recording?\n     * @param precAudioFeedback Has audio feedback?\n     */\n    private async setup(stream: MediaStream | null, precRecording: boolean, precAudioFeedback: boolean) {\n        if (stream && this.context) {\n            this.input = this.context.createMediaStreamSource(stream);\n            this.stream = stream;\n        }\n\n        if (this.recorder && this.input) {\n            await this.recorder.setup(this.input);\n\n            if (precRecording) {\n                await this.record();\n            }\n        }\n\n        this.audioFeedback(precAudioFeedback);\n        this.updateConstraints();\n        await this.updateInputList();\n    }\n\n    /**\n     * Enable/disable noise suppression\n     * @param enable boolean\n     */\n    setNoiseSuppression(enable: boolean) {\n        this.resetConstraints({\n            audio: {\n                noiseSuppression: enable\n            }\n        });\n    }\n\n    /**\n     * Enable/disable auto gain\n     * @param enable boolean\n     */\n    setAutoGain(enable: boolean) {\n        this.resetConstraints({\n            audio: {\n                autoGainControl: enable\n            }\n        });\n    }\n\n    /**\n     * Enable/disable echo cancellation\n     * @param enable boolean\n     */\n    setEchoCancellation(enable: boolean) {\n        this.resetConstraints({\n            audio: {\n                echoCancellation: enable\n            }\n        });\n    }\n\n    /**\n     * Update current audio input list\n     */\n    private async updateInputList() {\n        if (this.deviceList) {\n            const devices = await navigator.mediaDevices.enumerateDevices();\n            this.deviceList = [];\n\n            devices.forEach(device => {\n                if (device.kind == \"audioinput\") {\n                    this.deviceList.push(device);\n                }\n            });\n        }\n    }\n\n    /**\n     * Change audio input\n     * @param deviceId Device ID\n     * @param groupId Group ID (optional)\n     */\n    changeInput(deviceId: string, groupId: string | undefined) {\n        if (groupId) {\n            this.constraints.audio.deviceId = deviceId;\n            this.constraints.audio.groupId = groupId;\n            this.resetConstraints();\n        }\n    }\n\n    /**\n     * Start audio recording\n     */\n    async record() {\n        if (this.alreadyInit && this.configService && this.input) {\n            if (!this.recorder) {\n                this.recorder = new Recorder({\n                    bufferLen: this.configService.getBufferSize(),\n                    sampleRate: this.configService.getSampleRate(),\n                    numChannels: 2,\n                    mimeType: \"audio/wav\"\n                });\n\n                await this.recorder.setup(this.input);\n            }\n\n            if (this.recorder) {\n                this.recorder.record();\n            }\n\n            this.timer && this.timer.start();\n            this.recording = true;\n\n            if (this.eventEmitter) {\n                this.eventEmitter.emit(EventType.RECORDER_RECORDING);\n            }\n        }\n    }\n\n    /**\n     * Stop audio recording\n     */\n    async stop() {\n        if (this.alreadyInit && this.recorder) {\n            this.recorder.stop();\n            this.timer && this.timer.stop();\n            this.recording = false;\n\n            this.recorder.getBuffer((buffer: Float32Array[]) => {\n                if (this.context) {\n                    this.context.resume();\n\n                    const newBuffer = this.context.createBuffer(2, buffer[0].length, this.context.sampleRate);\n                    newBuffer.getChannelData(0).set(buffer[0]);\n                    newBuffer.getChannelData(1).set(buffer[1]);\n\n                    this.eventEmitter?.emit(EventType.RECORDER_STOPPED, newBuffer);\n                    this.reset();\n                }\n            });\n        }\n    }\n\n    /**\n     * Pause audio recording\n     */\n    pause() {\n        if (this.alreadyInit) {\n            this.recorder && this.recorder.stop();\n            this.timer && this.timer.stop();\n            this.recording = false;\n            this.eventEmitter?.emit(EventType.RECORDER_PAUSED);\n        }\n    }\n\n    /**\n     * Stop stream\n     */\n    private stopStream() {\n        if (this.stream) {\n            const tracks = this.stream.getTracks();\n\n            for (let i = 0, l = tracks.length; i < l; i++) {\n                tracks[i].stop();\n            }\n        }\n    }\n\n    /**\n     * Reset this voice recorder\n     */\n    reset() {\n        this.recorder && this.recorder.kill();\n        this.timer && this.timer.stop();\n        this.audioFeedback(false);\n\n        this.stopStream();\n\n        this.input = null;\n        this.recorder = null;\n        this.stream = null;\n        this.alreadyInit = false;\n        this.timer = null;\n\n        this.eventEmitter?.emit(EventType.RECORDER_RESETED);\n    }\n\n    /**\n     * Get current recording time in text format\n     */\n    get currentTimeDisplay() {\n        return this.timer?.seconds ? (\"0\" + Math.trunc(this.timer?.seconds / 60)).slice(-2) + \":\" + (\"0\" + Math.trunc(this.timer?.seconds % 60)).slice(-2) : \"00:00\";\n    }\n\n    /**\n     * Get current recording time in seconds\n     */\n    get currentTime() {\n        return this.timer ? this.timer.seconds : 0;\n    }\n\n    /**\n     * Get the current settings for this voice recorder\n     * @returns RecorderSettings\n     */\n    getSettings(): RecorderSettings {\n        return {\n            deviceList: this.deviceList,\n            audioFeedback: this.enableAudioFeedback,\n            constraints: this.constraints.audio\n        };\n    }\n\n    /**\n     * Observe an event\n     * @param event The event name\n     * @param callback Callback called when an event of this type occurs\n     */\n    on(event: string, callback: EventEmitterCallback) {\n        this.eventEmitter?.on(event, callback);\n    }\n\n    /**\n     * Check if browser is compatible with audio recording\n     * @returns boolean\n     */\n    isRecordingAvailable() {\n        return typeof (navigator.mediaDevices) !== \"undefined\" && typeof (navigator.mediaDevices.getUserMedia) !== \"undefined\";\n    }\n\n    get order(): number {\n        return -1;\n    }\n\n    get id(): string {\n        throw Constants.VOICE_RECORDER;\n    }\n}\n"],"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","SuppressedError","AbstractAudioElement","constructor","this","enabled","defaultEnabled","bufferFetcherService","configService","isEnabled","isDefaultEnabled","setDefaultEnabled","state","setEnabled","enable","disable","toggle","AbstractAudioFilter","defaultSettings","getAddingTime","initializeDefaultSettings","getSettings","getDefaultSettings","resetSettings","Object","keys","forEach","key","setSetting","isWorklet","Constants","AUDIO_EDITOR","VOICE_RECORDER","BUFFER_PLAYER","EXPORT_WAV_COMMAND","AUDIO_WAV","RECORD_COMMAND","INIT_COMMAND","FILTERS_NAMES","REVERB","ECHO","BASS_BOOST","BITCRUSHER","HIGH_PASS","LIMITER","LOW_PASS","PASS_THROUGH","RETURN_AUDIO","SOUNDTOUCH","TELEPHONIZER","VOCODER","WORKLET_PATHS","RECORDER_WORKLET","WORKLET_NAMES","PREFERENCES_KEYS","COMPATIBILITY_MODE_ENABLED","COMPATIBILITY_MODE_CHECKED","ENABLE_AUDIO_WORKLET","ENABLE_SOUNDTOUCH_AUDIO_WORKLET","BUFFER_SIZE","SAMPLE_RATE","ENABLE_RECORDER_AUDIO_WORKLET","SOUNDTOUCH_PITCH_SHIFTER_BUFFER_SIZE","DEFAULT_REVERB_ENVIRONMENT","name","url","size","addDuration","link","VOCODER_MODULATOR","DEFAULT_BUFFER_SIZE","VALID_BUFFER_SIZE","DEFAULT_SAMPLE_RATE","VALID_SAMPLE_RATES","utilFunctions","calcAudioDuration","audio","speed","duration","loadAudioBuffer","context","file","arrayBuffer","readAsArrayBufferPromisified","audioBuffer","decodeAudioData","decodeBuffer","reader","FileReader","onload","ev","_a","target","ArrayBuffer","readAsArrayBuffer","buffer","numberOfChannels","resume","sampleRate","newBuffer","createBuffer","sourceChannelData","getChannelData","channel0Data","channel1Data","i","length","convertAudioBufferToFloat32Array","array","channel","push","convertAudioParamToFloat32Array","param","Float32Array","set","sumAudioBufferChannel","reduce","a","b","sumAudioBuffer","sum","isAudioWorkletCompatible","audioContext","isSettingValueValid","isNaN","Number","trim","BassBoosterFilter","frequencyBooster","dbBooster","frequencyReduce","dbReduce","super","getNode","bassBoostFilter","createBiquadFilter","type","frequency","gain","bassBoostFilterHighFreq","connect","input","output","order","id","settingId","parseInt","AudioParamPolyfill","defaultValue","_value","_minValue","_maxValue","MAX_SAFE_INTEGER","_defaultValue","automationRate","undefined","newValue","Math","max","min","minValue","maxValue","setValueAtTime","startTime","console","warn","linearRampToValueAtTime","endTime","exponentialRampToValueAtTime","cancelAndHoldAtTime","cancelTime","Error","cancelScheduledValues","setTargetAtTime","timeConstant","setValueCurveAtTime","values","WorkletScriptProcessorNodeAdapter","node","bufferSize","_parameters","Map","_port","currentContext","workletProcessor","_scriptProcessorNode","createScriptProcessor","setupPort","setupProcessor","setupWorkletScope","messageChannel","MessageChannel","port1","onmessage","port2","postMessage","data","onaudioprocess","inputArray","Functions","inputBuffer","ouputArray","outputBuffer","records","entries","recordsMap","fromEntries","process","descriptors","defaultParameterDescriptors","descriptor","window","port","parameters","RegisterProcessorPolyfill","registerProcessor","processorName","processorClass","processorsMap","getProcessor","processor","get","SimpleAudioWorkletProcessor","inputs","outputs","parameterDescriptors","AudioWorkletProcessor","global","AbstractAudioFilterWorklet","currentWorkletNode","fallbackToScriptProcessor","keepCurrentNodeIfPossible","initializeWorklet","stop","error","audioWorklet","addModule","workletPath","catch","isAudioWorkletEnabled","initializeNode","workletName","AudioWorkletNode","getBufferSize","applyCurrentSettingsToWorklet","currentSettings","settingKey","settingFromWorklet","BitCrusherProcessor","stopped","phaser","last","event","pow","bits","currentNormFreq","normFreq","Array","fill","blockSize","inp","out","floor","parseFloat","EchoFilter","delay","delayNode","createDelay","delayTime","gainNode","createGain","HighPassFilter","highFrequency","highPassFilter","DelayBuffer","n","_array","readPointer","writePointer","init","read","v","reset","clear","LimiterProcessor","delayBuffer","envelopeSample","disabled","getEnvelope","attackTime","releaseTime","attackGain","exp","releaseGain","envelope","envIn","abs","getMaxEnvelope","channels","index","ampToDB","log10","dBToAmp","db","envelopeData","postGainAmp","postGain","preGainAmp","preGain","lookAheadTime","k","slope","gainDB","threshold","LimiterFilter","LowPassFilter","lowFrequency","lowPassFilter","AbstractAudioRenderer","ReturnAudioRenderer","renderAudio","numChannels","totalFrames","bufferReturned","nowBuffering","ReverbFilter","reverbEnvironment","convolver","createConvolver","getAudioBuffer","settings","additionalData","downloadedBuffers","getDownloadedBuffersList","fetchBuffer","FifoSampleBuffer","_vector","_position","_frameCount","vector","position","startIndex","frameCount","endIndex","receive","rewind","put","numFrames","putSamples","samples","sourceOffset","numSamples","ensureCapacity","destOffset","subarray","putBuffer","receiveSamples","extract","minLength","newVector","ensureAdditionalCapacity","AbstractFifoSamplePipe","createBuffers","_inputBuffer","_outputBuffer","RateTransposer","_rate","rate","slopeCount","prevSampleL","prevSampleR","clone","numFramesOutput","transpose","src","srcOffset","dest","used","srcIndex","FilterSupport","pipe","_pipe","fillInputBuffer","fillOutputBuffer","numInputFrames","noop","SimpleFilter","sourceSound","callback","historyBufferSize","_sourcePosition","outputBufferPosition","RangeError","newOutputBufferPosition","sourcePosition","onEnd","numFramesExtracted","currentFrames","handleSampleData","_SCAN_OFFSETS","AUTOSEEK_K","Stretch","_quickSeek","midBufferDirty","midBuffer","overlapLength","autoSeqSetting","autoSeekSetting","_tempo","setParameters","clearMidBuffer","sequenceMs","seekWindowMs","overlapMs","calculateSequenceParameters","calculateOverlapLength","tempo","newTempo","intskip","nominalSkip","seekWindowLength","skipFract","sampleReq","seekLength","inputChunkSize","outputChunkSize","overlapInMsec","newOvl","refMidBuffer","checkLimits","x","mi","ma","seq","seek","AUTOSEQ_AT_MIN","AUTOSEEK_AT_MIN","quickSeek","seekBestOverlapPosition","seekBestOverlapPositionStereoQuick","seekBestOverlapPositionStereo","bestOffset","bestCorrelation","correlation","preCalculateCorrelationReferenceStereo","MIN_VALUE","calculateCrossCorrelationStereo","correlationOffset","tempOffset","scanCount","j","temp","mixingPosition","compare","mixing","calcLength","mixingOffset","overlap","overlapPosition","overlapStereo","inputPosition","outputPosition","tempFrame","frameScale","fi","inputOffset","outputOffset","offset","overlapSkip","start","testFloatEqual","SoundTouch","transposer","stretch","_intermediateBuffer","virtualPitch","virtualRate","virtualTempo","calculateEffectiveRateAndTempo","rateChange","tempoChange","pitch","pitchOctaves","pitchSemitones","previousTempo","previousRate","WebAudioBufferSource","dualChannel","left","right","minsSecs","secs","mins","width","z","join","onUpdate","currentTimePlayed","timePlayed","CustomEvent","detail","formattedTimePlayed","percentagePlayed","_node","dispatchEvent","PitchShifter","_soundtouch","source","_filter","filter","sourcePositionCallback","framesExtracted","getWebAudioNode","sourcePostion","call","listeners","formattedDuration","perc","semitone","toNode","disconnect","on","eventName","cb","addEventListener","off","removeEventListener","soundtouchWrapperFilterWorkletNodeClass","options","running","_pitch","updateInterval","processorOptions","setup","status","args","messageProcessor","bind","command","EventType","SoundtouchWrapperFilterWorkletNode","SoundtouchWrapperFilter","speedAudio","frequencyAudio","currentSpeedAudio","isOfflineMode","constructAudioWorkletProcessor","getEntrypointNode","offline","bufferSource","createBufferSource","utils","renderWithWorklet","renderWithScriptProcessorNode","currentPitchShifter","getSoundtouchScriptProcessorNode","updateState","durationAudio","offlineContext","OfflineAudioContext","destination","renderedBuffer","startRendering","bufferSourceRendered","currentPitchShifterWorklet","bypass","recording","nInputFrames","approximateNInputFrames","round","isSoundtouchAudioWorkletEnabled","getCurrentPitchShifter","pitchShifter","valueFloat","getSpeed","BitCrusherFilter","lpf1","lpf2","hpf1","hpf2","EventEmitter","emit","BufferPlayer","eventEmitter","currentTime","displayTime","interval","playing","loop","onBeforePlayingCallback","compatibilityMode","currentNode","updateInfos","loadBuffer","setCompatibilityMode","clearInterval","PLAYING_STOPPED","PLAYING_STARTED","performance","now","setInterval","timeNow","nextTime","PLAYING_FINISHED","_b","pause","PLAYING_UPDATE","setTimePercent","percent","setTime","time","onBeforePlaying","toggleLoop","updateContext","currentTimeDisplay","trunc","slice","maxTimeDisplay","remainingTimeDisplay","BufferFetcherService","buffers","bufferErrors","bufferURI","force","getKeyFromLocation","FETCHING_BUFFERS","response","fetch","ok","FETCHING_BUFFERS_ERROR","_c","FINISHED_FETCHING_BUFFERS","_d","fetchAllBuffers","bufferURIs","uri","filename","getOrFetchAudioBuffer","from","location","substring","lastIndexOf","Vocoder","ctx","carrierB","modulatorB","FILTER_QUALITY","FOURIER_SIZE","WAVETABLEBOOST","SAWTOOTHBOOST","oscillatorType","oscillatorDetuneValue","carrierBuffer","modulatorNode","vocoding","modulatorInput","carrierInput","modulatorGain","modulatorGainValue","noiseBuffer","noiseNode","noiseGain","noiseGainValue","carrierSampleNode","carrierSampleGain","carrierSampleGainValue","oscillatorNode","oscillatorGain","oscillatorGainValue","wavetable","wavetableSignalGain","modFilterBands","modFilterPostGains","heterodynes","powers","lpFilters","lpFilterPostGains","carrierBands","carrierFilterPostGains","carrierBandGains","vocoderBands","numVocoderBands","hpFilterGain","outputGain","modulatorBuffer","generateVocoderBands","setupVocoderGraph","vocode","getNodes","synthLevel","shutOffCarrier","selectSawtooth","selectWavetable","setPeriodicWave","updateModGain","updateSampleLevel","updateSynthLevel","updateNoiseLevel","startFreq","endFreq","numBands","centsPerBand","log","LN2","scale","currentFreq","loadNoiseBuffer","lengthInSamples","bufferData","random","initBandpassFilters","waveShaperCurve","n2","hpFilter","Q","rectifierCurve","modulatorFilter","secondModulatorFilter","modulatorFilterPostGain","heterodyneOscillator","createOscillator","heterodyne","heterodynePostGain","rectifier","createWaveShaper","curve","lpFilter","lpFilterPostGain","waveshaper","carrierFilter","secondCarrierFilter","carrierFilterPostGain","bandGain","real","imag","createPeriodicWave","createCarriersAndPlay","detune","VocoderFilter","vocoder","GenericConfigService","mapConfig","getConfig","setConfig","isCompatibilityModeEnabled","isCompatibilityModeChecked","setting","getSampleRate","enableCompatibilityMode","disableCompatibilityMode","WORKER_ENABLED","URL","Blob","Worker","InlineWorker","func","self","functionBody","_this","toString","match","createObjectURL","setTimeout","prototype","getRecorderWorker","recLength","recBuffers","config","record","exportWAV","getBuffer","initBuffers","mergeBuffers","interleaved","interleave","dataview","encodeWAV","audioBlob","inputL","inputR","inputIndex","writeString","view","string","setUint8","charCodeAt","DataView","setUint32","setUint16","s","setInt16","floatTo16BitPCM","Recorder","cfg","worker","bufferLen","mimeType","callbacks","assign","createRecorderNode","pop","createRecorderWorklet","createRecorderScriptProcessorNode","numChannelParameter","kill","terminate","forceDownload","blob","document","createElement","webkitURL","body","appendChild","href","download","click","revokeObjectURL","TimerSaveTime","seconds","incr","initialSeconds","countCallback","count","onCount","player","audioBuffersToFetch","principalBuffer","sumPrincipalBuffer","entrypointFilter","filters","renderers","currentNodes","savingBuffer","previousSampleRate","playingStoppedCallback","downloadingInitialData","bufferPlayer","SAMPLE_RATE_CHANGED","createNewContext","setupOutput","setupDefaultFilters","setupDefaultRenderers","fetchBuffers","addFilters","addRenderers","renderer","bassBooster","bitCrusher","echo","highPass","lowPass","reverb","soundtouchWrapper","limiterFilter","telephonizerFilter","TelephonizerFilter","returnAudio","refetch","LOADING_BUFFERS","LOADED_BUFFERS","LOADING_BUFFERS_ERROR","createNewContextIfNeeded","currentSampleRate","resetBufferFetcher","reverbSettings","getFiltersSettings","reverbUrl","close","latencyHint","AudioContext","prepareContext","defaultDeviceSampleRate","tempContext","loadBufferFromFile","connectNodes","keepCurrentInputOutput","isCompatibilityMode","entrypointNode","entrypointNodes","intermediateNodes","previousNode","disconnectOldNodes","sort","keepCurrentOutput","intermediate","reconnectNodesIfNeeded","calculateAudioDuration","initializeWorklets","getOutputBuffer","outputContext","currentBuffer","setCompatibilityModeChecked","COMPATIBILITY_MODE_AUTO_ENABLED","RENDERING_AUDIO_PROBLEM_DETECTED","isAudioWorkletAvailable","checked","getFiltersState","toggleFilter","filterId","find","f","changeFilterSettings","resetFilterSettings","resetAllFiltersState","element","exit","saveBuffer","rec","finishedCallback","downloadAudioBlob","Date","toISOString","stream","recorder","alreadyInit","timer","enableAudioFeedback","deviceList","constraints","noiseSuppression","echoCancellation","autoGainControl","isRecordingAvailable","RECORDER_INIT","navigator","mediaDevices","getUserMedia","RECORDER_COUNT_UPDATE","successCallback","errorCallback","ondevicechange","updateInputList","RECORDER_SUCCESS","RECORDER_ERROR","audioFeedback","RECORDER_UPDATE_CONSTRAINTS","getConstraints","tracks","getTracks","updateConstraints","resetConstraints","newConstraint","precAudioFeedback","precRecording","applyConstraints","newConstraints","newConstraintName","stopStream","createMediaStreamSource","setNoiseSuppression","setAutoGain","setEchoCancellation","devices","enumerateDevices","device","kind","changeInput","deviceId","groupId","RECORDER_RECORDING","RECORDER_STOPPED","RECORDER_PAUSED","l","RECORDER_RESETED"],"mappings":"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","x_google_ignoreList":[0,23,34]}