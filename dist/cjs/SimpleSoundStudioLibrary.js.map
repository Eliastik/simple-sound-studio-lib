{"version":3,"file":"SimpleSoundStudioLibrary.js","sources":["../../node_modules/tslib/tslib.es6.js","../../lib/filters/interfaces/AbstractAudioElement.ts","../../lib/model/EventTypeEnum.ts","../../lib/utils/Functions.ts","../../lib/utils/EventEmitter.ts","../../lib/model/Constants.ts","../../lib/BufferPlayer.ts","../../lib/services/BufferFetcherService.ts","../../lib/utils/GenericConfigService.ts","../../lib/services/BufferDecoderService.ts","../../lib/filters/interfaces/AbstractAudioFilter.ts","../../lib/filters/BassBoosterFilter.ts","../../lib/workletPolyfill/AudioParamPolyfill.ts","../../lib/workletPolyfill/WorkletScriptProcessorNodeAdapter.ts","../../lib/workletPolyfill/RegisterProcessorPolyfill.ts","../../lib/workletPolyfill/SimpleAudioWorkletProcessor.ts","../../lib/workletPolyfill/AudioWorkletProcessorPolyfill.ts","../../lib/filters/interfaces/AbstractAudioFilterWorklet.ts","../../lib/filters/worklets/BitCrusher.worklet.ts","../../lib/filters/BitCrusherFilter.ts","../../lib/filters/EchoFilter.ts","../../lib/filters/HighPassFilter.ts","../../lib/utils/DelayBuffer.ts","../../lib/filters/worklets/Limiter.worklet.ts","../../lib/filters/LimiterFilter.ts","../../lib/filters/LowPassFilter.ts","../../lib/filters/interfaces/AbstractAudioRenderer.ts","../../lib/filters/ReturnAudioRenderer.ts","../../lib/filters/ReverbFilter.ts","../../node_modules/soundtouchjs/dist/soundtouch.js","../../lib/filters/worklets/SoundtouchWrapperFilterWorkletNode.ts","../../lib/filters/SountouchWrapperFilter.ts","../../lib/filters/TelephonizerFilter.ts","../../lib/utils/Vocoder.ts","../../lib/filters/VocoderFilter.ts","../../lib/filters/worklets/Passthrough.worklet.ts","../../lib/filters/PassThroughFilter.ts","../../lib/audioEditor/FilterManager.ts","../../lib/audioEditor/AudioContextManager.ts","../../lib/recorder/getRecorderWorker.ts","../../lib/recorder/Recorder.ts","../../lib/audioEditor/SaveBufferManager.ts","../../lib/audioEditor/AudioProcessor.ts","../../lib/audioEditor/BufferManager.ts","../../lib/utils/TimerSaveTime.ts","../../lib/audioEditor/AudioEditor.ts","../../lib/VoiceRecorder.ts"],"sourcesContent":["/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.unshift(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.unshift(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\n\r\nexport function __runInitializers(thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\n\r\nexport function __propKey(x) {\r\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nexport function __setFunctionName(f, name, prefix) {\r\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n\r\nexport function __addDisposableResource(env, value, async) {\r\n    if (value !== null && value !== void 0) {\r\n        if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\r\n        var dispose;\r\n        if (async) {\r\n            if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\r\n            dispose = value[Symbol.asyncDispose];\r\n        }\r\n        if (dispose === void 0) {\r\n            if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\r\n            dispose = value[Symbol.dispose];\r\n        }\r\n        if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\r\n        env.stack.push({ value: value, dispose: dispose, async: async });\r\n    }\r\n    else if (async) {\r\n        env.stack.push({ async: true });\r\n    }\r\n    return value;\r\n}\r\n\r\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\r\n\r\nexport function __disposeResources(env) {\r\n    function fail(e) {\r\n        env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\r\n        env.hasError = true;\r\n    }\r\n    function next() {\r\n        while (env.stack.length) {\r\n            var rec = env.stack.pop();\r\n            try {\r\n                var result = rec.dispose && rec.dispose.call(rec.value);\r\n                if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\r\n            }\r\n            catch (e) {\r\n                fail(e);\r\n            }\r\n        }\r\n        if (env.hasError) throw env.error;\r\n    }\r\n    return next();\r\n}\r\n\r\nexport default {\r\n    __extends: __extends,\r\n    __assign: __assign,\r\n    __rest: __rest,\r\n    __decorate: __decorate,\r\n    __param: __param,\r\n    __metadata: __metadata,\r\n    __awaiter: __awaiter,\r\n    __generator: __generator,\r\n    __createBinding: __createBinding,\r\n    __exportStar: __exportStar,\r\n    __values: __values,\r\n    __read: __read,\r\n    __spread: __spread,\r\n    __spreadArrays: __spreadArrays,\r\n    __spreadArray: __spreadArray,\r\n    __await: __await,\r\n    __asyncGenerator: __asyncGenerator,\r\n    __asyncDelegator: __asyncDelegator,\r\n    __asyncValues: __asyncValues,\r\n    __makeTemplateObject: __makeTemplateObject,\r\n    __importStar: __importStar,\r\n    __importDefault: __importDefault,\r\n    __classPrivateFieldGet: __classPrivateFieldGet,\r\n    __classPrivateFieldSet: __classPrivateFieldSet,\r\n    __classPrivateFieldIn: __classPrivateFieldIn,\r\n    __addDisposableResource: __addDisposableResource,\r\n    __disposeResources: __disposeResources,\r\n};\r\n","import BufferDecoderService from \"../../services/BufferDecoderService\";\nimport BufferFetcherService from \"../../services/BufferFetcherService\";\nimport { ConfigService } from \"../../services/ConfigService\";\n\nexport default abstract class AbstractAudioElement {\n\n    private enabled = false;\n    private defaultEnabled = false;\n    bufferFetcherService: BufferFetcherService | null = null;\n    bufferDecoderService: BufferDecoderService | null = null;\n    configService: ConfigService | null = null;\n\n    /** Returns the order in which the filter/renderer needs to be applied */\n    abstract get order(): number;\n\n    /** Returns the id of this filter/renderer */\n    abstract get id(): string;\n\n    /** Is this filter/renderer enabled? */\n    isEnabled(): boolean {\n        return this.enabled;\n    }\n\n    /** Is this filter/renderer enabled by default? */\n    isDefaultEnabled(): boolean {\n        return this.defaultEnabled;\n    }\n\n    /** Set to true if this filter/renderer needs to be enabled by default */\n    setDefaultEnabled(state: boolean) {\n        this.defaultEnabled = state;\n    }\n\n    setEnabled(state: boolean) {\n        this.enabled = state;\n    }\n\n    /** Enable this filter/renderer */\n    enable() {\n        this.setEnabled(true);\n    }\n\n    /** Disable this filter/renderer */\n    disable() {\n        this.setEnabled(false);\n    }\n\n    /** Toggle to enabled/disabled this filter */\n    toggle() {\n        this.setEnabled(!this.isEnabled());\n    }\n}\n","export enum EventType {\n    LOADING_BUFFERS = \"loadingBuffers\",\n    LOADING_BUFFERS_ERROR = \"loadingBuffersError\",\n    FETCHING_BUFFERS = \"fetchingBuffers\",\n    FETCHING_BUFFERS_ERROR = \"fetchingBuffersError\",\n    FINISHED_FETCHING_BUFFERS = \"finishedFetchingBuffers\",\n    LOADED_BUFFERS = \"loadedBuffers\",\n    COMPATIBILITY_MODE_AUTO_ENABLED = \"compatibilityModeAutoEnabled\",\n    RENDERING_AUDIO_PROBLEM_DETECTED = \"renderingAudioProblemDetected\",\n    AUDIO_RENDERING_FINISHED = \"audioRenderingFinished\",\n    OFFLINE_AUDIO_RENDERING_FINISHED = \"offlineAudioRenderingFinished\",\n    PLAYING_STOPPED = \"playingStopped\",\n    PLAYING_STARTED = \"playingStarted\",\n    PLAYING_FINISHED = \"playingFinished\",\n    PLAYING_UPDATE = \"playingUpdate\",\n    RECORDER_INIT = \"recorderInit\",\n    RECORDER_SUCCESS = \"recorderSuccess\",\n    RECORDER_ERROR = \"recorderError\",\n    RECORDER_UPDATE_CONSTRAINTS = \"recorderUpdateConstraints\",\n    RECORDER_RECORDING = \"recorderRecording\",\n    RECORDER_STOPPED = \"recorderStopped\",\n    RECORDER_PAUSED = \"recorderPaused\",\n    RECORDER_RESETED = \"recorderReseted\",\n    RECORDER_COUNT_UPDATE = \"recorderCountUpdate\",\n    SAMPLE_RATE_CHANGED = \"sampleRateChanged\",\n    DECODING_AUDIO_FILE = \"decodingAudioFile\",\n    DECODED_AUDIO_FILE = \"decodedAudioFile\",\n    ERROR_DECODING_AUDIO_FILE = \"errorDecodingAudioFile\",\n    RECORDER_NOT_FOUND_ERROR = \"recorderNotFoundError\",\n    RECORDER_UNKNOWN_ERROR = \"recorderUnknownError\",\n    UPDATE_AUDIO_TREATMENT_PERCENT = \"updateAudioTreatmentPercent\",\n    UPDATE_REMAINING_TIME_ESTIMATED = \"updateRemainingTimeEstimated\",\n    CANCELLED_AND_LOADED_INITIAL_AUDIO = \"cancelledAndLoadedInitialAudio\",\n    CANCELLING_AUDIO_PROCESSING = \"cancellingAudioProcessing\"\n};\n","import FilterManager from \"@/audioEditor/FilterManager\";\nimport { FilterSettingValue } from \"../model/filtersSettings/FilterSettings\";\nimport EventEmitter from \"./EventEmitter\";\nimport { EventType } from \"@/model/EventTypeEnum\";\n\nconst utilFunctions = {\n    calcAudioDuration: (audio: AudioBuffer, speed: number) => {\n        if (audio) {\n            let duration = audio.duration + 1;\n\n            if (speed) {\n                duration = duration / speed;\n            }\n\n            return duration;\n        }\n\n        return 0;\n    },\n    loadAudioBuffer: async (context: AudioContext, file: File) => {\n        const arrayBuffer = await utilFunctions.readAsArrayBufferPromisified(file);\n        const audioBuffer = await context.decodeAudioData(arrayBuffer);\n        return utilFunctions.decodeBuffer(context, audioBuffer);\n    },\n    readAsArrayBufferPromisified: (file: File): Promise<ArrayBuffer> => {\n        return new Promise((resolve, reject) => {\n            const reader = new FileReader();\n\n            reader.onload = ev => {\n                const result = ev?.target?.result;\n\n                if (result instanceof ArrayBuffer) {\n                    resolve(result);\n                } else {\n                    reject();\n                }\n            };\n\n            if (file) {\n                reader.readAsArrayBuffer(file); // Read the file\n            }\n        });\n    },\n    decodeBuffer: (context: AudioContext, buffer: AudioBuffer) => {\n        if (buffer.numberOfChannels == 1) { // convert to stereo buffer\n            context.resume();\n\n            const duration = buffer.duration;\n            const sampleRate = context.sampleRate;\n\n            const newBuffer = context.createBuffer(2, sampleRate * duration + sampleRate * 2, sampleRate);\n\n            // Original buffer data\n            const sourceChannelData = buffer.getChannelData(0);\n\n            // Destination buffers\n            const channel0Data = newBuffer.getChannelData(0);\n            const channel1Data = newBuffer.getChannelData(1);\n\n            for (let i = 0; i < sourceChannelData.length; i++) {\n                channel0Data[i] = sourceChannelData[i];\n                channel1Data[i] = sourceChannelData[i];\n            }\n\n            return newBuffer;\n        }\n\n        return buffer;\n    },\n    convertAudioBufferToFloat32Array: (buffer: AudioBuffer) => {\n        const array: Float32Array[] = [];\n\n        for (let channel = 0; channel < buffer.numberOfChannels; channel++) {\n            array.push(buffer.getChannelData(channel));\n        }\n\n        return array;\n    },\n    convertAudioParamToFloat32Array: (param: AudioParam, length: number) => {\n        const array = new Float32Array(length);\n\n        for (let i = 0; i < length; i++) {\n            array.set([param.value], i);\n        }\n\n        return array;\n    },\n    sumAudioBufferChannel(buffer: AudioBuffer, channel: number) {\n        return buffer.getChannelData(channel).reduce((a, b) => a + b, 0);\n    },\n    sumAudioBuffer(buffer: AudioBuffer) {\n        let sum = 0;\n\n        for (let channel = 0; channel < buffer.numberOfChannels; channel++) {\n            sum += this.sumAudioBufferChannel(buffer, channel);\n        }\n\n        return sum;\n    },\n    /**\n    * This method checks if the browser is compatible with audio worklets\n    * @param audioContext \n    */\n    isAudioWorkletCompatible(audioContext: BaseAudioContext) {\n        if (typeof (audioContext) !== \"undefined\" && typeof (audioContext.audioWorklet) !== \"undefined\") {\n            return true;\n        }\n\n        return false;\n    },\n    /**\n     * Check that the setting value is correct\n     * @param value FilterSettingValue\n     */\n    isSettingValueValid(value: FilterSettingValue) {\n        return typeof (value) !== \"undefined\" && !isNaN(Number(value)) && !(typeof (value) === \"string\" && value.trim() === \"\");\n    },\n    /**\n     * Calculate approximative audio duration according to enabled filters and their settings\n     * @param speedAudio Current audio speed\n     * @returns The audio duration\n     */\n    calculateAudioDuration(buffer: AudioBuffer, filterManager: FilterManager, speedAudio: number): number {\n        if (buffer && filterManager) {\n            const duration = this.calcAudioDuration(buffer, speedAudio);\n            return duration + filterManager.getAddingTime();\n        }\n\n        return 0;\n    },\n    /**\n     * Reset audio rendering progress\n     */\n    resetAudioRenderingProgress(eventEmitter: EventEmitter | undefined) {\n        if (eventEmitter) {\n            eventEmitter.emit(EventType.UPDATE_AUDIO_TREATMENT_PERCENT, 0);\n            eventEmitter.emit(EventType.UPDATE_REMAINING_TIME_ESTIMATED, -1);\n        }\n    }\n};\n\nexport default utilFunctions;\n","import AudioEditorEvents from \"../model/AudioEditorEvent\";\nimport { EventEmitterCallback } from \"../model/EventEmitterCallback\";\n\nclass EventEmitter {\n    listeners: AudioEditorEvents = {};\n    \n    constructor() {\n        this.listeners = {};\n    }\n\n    on(event: string, callback: EventEmitterCallback) {\n        if (!this.listeners[event]) {\n            this.listeners[event] = [];\n        }\n        this.listeners[event].push(callback);\n    }\n\n    emit(event: string, data?: string | number | AudioBuffer) {\n        if (this.listeners[event]) {\n            this.listeners[event].forEach(callback => {\n                callback(data);\n            });\n        }\n    }\n\n    off(event: string, callback: EventEmitterCallback) {\n        if (this.listeners[event]) {\n            this.listeners[event] = this.listeners[event].filter(cb => cb !== callback);\n        }\n    }\n}\n\nexport default EventEmitter;\n","const Constants = {\n    AUDIO_EDITOR: \"audioEditor\",\n    VOICE_RECORDER: \"voiceRecorder\",\n    BUFFER_PLAYER: \"bufferPlayer\",\n    EXPORT_WAV_COMMAND: \"exportWAV\",\n    EXPORT_MP3_COMMAND: \"exportMP3\",\n    AUDIO_WAV: \"audio/wav\",\n    AUDIO_MP3: \"audio/mp3\",\n    RECORD_COMMAND: \"record\",\n    INIT_COMMAND: \"init\",\n    FILTERS_NAMES: {\n        REVERB: \"reverb\",\n        ECHO: \"echo\",\n        BASS_BOOST: \"bassboost\",\n        BITCRUSHER: \"bitcrusher\",\n        HIGH_PASS: \"highpass\",\n        LIMITER: \"limiter\",\n        LOW_PASS: \"lowpass\",\n        PASSTHROUGH: \"passthroughfilter\",\n        RETURN_AUDIO: \"returnAudio\",\n        SOUNDTOUCH: \"soundtouch\",\n        TELEPHONIZER: \"telephonizer\",\n        VOCODER: \"vocoder\"\n    },\n    WORKLET_PATHS: {\n        BITCRUSHER: \"BitCrusher.worklet.js\",\n        LIMITER: \"Limiter.worklet.js\",\n        SOUNDTOUCH: \"Soundtouch.worklet.js\",\n        RECORDER_WORKLET: \"RecorderWorklet.js\",\n        PASSTHROUGH: \"Passthrough.worklet.js\"\n    },\n    WORKLET_NAMES: {\n        BITCRUSHER: \"bitcrusher-processor\",\n        LIMITER: \"limiter-processor\",\n        SOUNDTOUCH: \"soundtouch-worklet\",\n        RECORDER_WORKLET: \"recorder-worklet\",\n        PASSTHROUGH: \"passthrough\"\n    },\n    PREFERENCES_KEYS: {\n        COMPATIBILITY_MODE_ENABLED: \"compatibility-mode-enabled\",\n        COMPATIBILITY_MODE_CHECKED: \"compatibility-mode-checked\",\n        ENABLE_AUDIO_WORKLET: \"enable-audio-worklet\",\n        ENABLE_SOUNDTOUCH_AUDIO_WORKLET: \"enable-soundtouch-audio-worklet\",\n        BUFFER_SIZE: \"buffer-size\",\n        SAMPLE_RATE: \"sample-rate\",\n        DISABLE_INITIAL_RENDERING: \"disable-initial-rendering\",\n        BITRATE_MP3: \"bitrate-mp3\"\n    },\n    // Enable or disable the use of Audio Worklet version of Soundtouch\n    // If disabled, the ScriptProcessorNode version is used\n    ENABLE_SOUNDTOUCH_AUDIO_WORKLET: true,\n    ENABLE_AUDIO_WORKLET: true,\n    ENABLE_RECORDER_AUDIO_WORKLET: true,\n    SOUNDTOUCH_PITCH_SHIFTER_BUFFER_SIZE: 16384,\n    DEFAULT_REVERB_ENVIRONMENT: {\n        name: \"Medium Damping Cave E002 M2S\",\n        url: \"impulse_response.wav\",\n        size: 1350278,\n        addDuration: 4,\n        link: \"http://www.cksde.com/p_6_250.htm\"\n    },\n    VOCODER_MODULATOR: \"modulator.mp3\",\n    DEFAULT_BUFFER_SIZE: 0,\n    VALID_BUFFER_SIZE: [0, 256, 512, 1024, 2048, 4096, 8192, 16384],\n    VALID_MP3_BITRATES: [32, 64, 96, 128, 160, 256, 320],\n    DEFAULT_SAMPLE_RATE: 0, // 0 = AUTO\n    VALID_SAMPLE_RATES: [0, 8000, 11025, 16000, 22050, 32000, 44100, 48000, 88200, 96000, 176400, 192000],\n    // Interval used by the treatment percent counter. The event will be dispatched each ms defined here\n    TREATMENT_TIME_COUNTING_THROTTLE_INTERVAL: 100,\n    // Smoothing factor for the time couting estimation (between 0 and 1)\n    TREATMENT_TIME_COUNTING_SMOOTHING_FACTOR: 0.9,\n    // Disable initial rendering (when opening audio file or buffer)\n    DISABLE_INITIAL_RENDERING: true,\n    // Default save format\n    DEFAULT_SAVE_FORMAT: \"wav\",\n    // Default bitrate for the MP3 encoder\n    DEFAULT_MP3_BITRATE: 320\n};\n\nexport default Constants;\n","/*\n * Copyright (C) 2019-2023 Eliastik (eliastiksofts.com)\n *\n * This file is part of \"Simple Voice Changer\".\n *\n * \"Simple Voice Changer\" is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * \"Simple Voice Changer\" is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with \"Simple Voice Changer\".  If not, see <http://www.gnu.org/licenses/>.\n */\n// The audio buffer player\n// Used to play the audio buffer, with time controls, pause/play, stop and loop\nimport { EventType } from \"./model/EventTypeEnum\";\nimport { EventEmitterCallback } from \"./model/EventEmitterCallback\";\nimport EventEmitter from \"./utils/EventEmitter\";\nimport AbstractAudioElement from \"./filters/interfaces/AbstractAudioElement\";\nimport Constants from \"./model/Constants\";\nimport AudioContextManager from \"./audioEditor/AudioContextManager\";\n\n// Also used in compatibility mode (which doesn't use audio buffer) with less functions (no time control)\nexport default class BufferPlayer extends AbstractAudioElement {\n\n    private _contextManager: AudioContextManager | undefined | null;\n    private buffer: AudioBuffer | null = null;\n    private source: AudioBufferSourceNode | null = null;\n    currentTime = 0;\n    displayTime = 0;\n    duration = 0;\n    private intervals: number[] = [];\n    playing = false;\n    loop = false;\n    speedAudio = 1;\n    private eventEmitter: EventEmitter | null;\n    private onBeforePlayingCallback: () => void = async () => {};\n\n    compatibilityMode = false;\n    currentNode: AudioNode | null = null;\n\n    constructor(contextManager: AudioContextManager | undefined | null, eventEmitter?: EventEmitter) {\n        super();\n        this._contextManager = contextManager;\n        this.eventEmitter = eventEmitter || new EventEmitter();\n    }\n\n    /** Init this buffer player */\n    init(direct?: boolean) {\n        this.playing = false;\n\n        if (this._contextManager && this._contextManager.currentContext) {\n            this._contextManager.currentContext.resume();\n\n            if (!this.compatibilityMode && this.buffer) {\n                if (this.source != null && !direct) this.source.disconnect();\n                this.source = this._contextManager.currentContext.createBufferSource();\n                this.source.buffer = this.buffer;\n                this.duration = this.buffer.duration * this.speedAudio;\n                this.source.connect(this._contextManager.currentContext.destination);\n            }\n        }\n\n        this.updateInfos();\n    }\n\n    /**\n     * Load an audio buffer\n     * @param buffer The buffer\n     */\n    loadBuffer(buffer: AudioBuffer) {\n        this.compatibilityMode = false;\n        this.reset();\n        this.buffer = buffer;\n        this.init();\n    }\n\n    /**\n     * Enable compatibility mode\n     * @param currentNode Current audio node to read\n     * @param duration The audio duration\n     */\n    setCompatibilityMode(currentNode: AudioNode, duration?: number) {\n        this.compatibilityMode = true;\n        this.reset();\n        this.init();\n\n        if (duration != null) {\n            this.duration = duration * this.speedAudio;\n        }\n\n        this.currentNode = currentNode;\n        this.updateInfos();\n    }\n\n    /**\n     * Reset this player\n     */\n    reset(direct?: boolean) {\n        this.clearIntervals();\n\n        this.currentTime = 0;\n        this.displayTime = 0;\n\n        if (!direct) {\n            this.stop();\n        }\n    }\n\n    /**\n     * Stop playing the audio\n     */\n    stop() {\n        this.clearIntervals();\n\n        if (this.source != undefined && this.source != null && this.playing) {\n            this.source.stop(0);\n            this.playing = false;\n        }\n\n        if (this.currentNode) {\n            this.currentNode.disconnect();\n\n            if(this.compatibilityMode) {\n                this.currentTime = 0;\n                this.displayTime = 0;\n            }\n        }\n\n        this.eventEmitter?.emit(EventType.PLAYING_STOPPED);\n        this.updateInfos();\n    }\n\n    /**\n     * Clear old intervals\n     */\n    private clearIntervals() {\n        for (const interval of this.intervals) {\n            clearInterval(interval);\n        }\n\n        this.intervals = [];\n    }\n\n    /**\n     * Start playing the audio\n     */\n    async start(direct?: boolean) {\n        if (this.source || this.compatibilityMode) {\n            if (!direct) {\n                this.stop();\n            }\n\n            this.init(direct);\n\n            await this.onBeforePlayingCallback();\n\n            this.eventEmitter?.emit(EventType.PLAYING_STARTED);\n\n            if (!this.compatibilityMode) {\n                if (this.source) {\n                    this.source.start(0, direct ? 0 : this.currentTime / this.speedAudio);\n                    this.playing = true;\n                } else {\n                    return;\n                }\n            } else {\n                if (this.currentNode && this._contextManager && this._contextManager.currentContext) {\n                    this.currentNode.connect(this._contextManager.currentContext.destination);\n                } else {\n                    return;\n                }\n            }\n\n            let startTime = performance.now();\n\n            this.intervals.push(window.setInterval(() => {\n                const timeNow = performance.now();\n                const nextTime = timeNow - startTime;\n                startTime = timeNow;\n\n                this.currentTime += (nextTime / 1000) * this.speedAudio;\n                this.displayTime = this.currentTime;\n\n                if (this.currentTime > this.duration) {\n                    if (this.loop) {\n                        if (!this.compatibilityMode) {\n                            this.reset(direct);\n                            this.start();\n                        } else {\n                            this.eventEmitter?.emit(EventType.PLAYING_FINISHED);\n                        }\n                    } else {\n                        this.eventEmitter?.emit(EventType.PLAYING_FINISHED);\n                        this.reset(direct);\n                    }\n                } else {\n                    this.updateInfos();\n                }\n            }, 100));\n        }\n    }\n\n    /**\n     * Play audio directly, without stopping previous audio play\n     */\n    async playDirect() {\n        if (!this.compatibilityMode) {\n            this.start(true);\n        } else {\n            // Play direct is not possible when compatibility mode is enabled\n            this.start(false);\n        }\n    }\n\n    /**\n     * Pause the audio\n     */\n    pause() {\n        this.stop();\n    }\n\n    /** Send an event to update the informations of this player */\n    private updateInfos() {\n        this.eventEmitter?.emit(EventType.PLAYING_UPDATE);\n    }\n\n    /**\n     * Set the current starting time of this player\n     * @param percent Where to start playing, in percent\n     */\n    setTimePercent(percent: number) {\n        if(!this.compatibilityMode) {\n            this.currentTime = Math.round(this.duration * (percent / 100));\n            this.displayTime = this.currentTime;\n    \n            if (this.playing) {\n                this.pause();\n                this.start();\n            } else {\n                this.updateInfos();\n            }\n        }\n    }\n\n    /**\n     * Set the current starting time of this player\n     * @param time Where to start playing, in milliseconds\n     */\n    setTime(time: number) {\n        if (!this.compatibilityMode) {\n            this.currentTime = time;\n            this.displayTime = this.currentTime;\n\n            if (this.playing) {\n                this.pause();\n                this.start();\n            } else {\n                this.updateInfos();\n            }\n        }\n    }\n\n    /**\n     * Callback called just before starting playing the audio\n     * @param callback The callback\n     */\n    onBeforePlaying(callback: () => void) {\n        this.onBeforePlayingCallback = callback;\n    }\n\n    /**\n     * Enable/disable loop playing\n     */\n    toggleLoop() {\n        this.loop = !this.loop;\n    }\n\n    /**\n     * Observe an event\n     * @param event The event name\n     * @param callback Callback called when an event of this type occurs\n     */\n    on(event: string, callback: EventEmitterCallback) {\n        this.eventEmitter?.on(event, callback);\n    }\n\n    /**\n     * Get the time in text format\n     */\n    get currentTimeDisplay() {\n        return (\"0\" + Math.trunc(this.displayTime / 60)).slice(-2) + \":\" + (\"0\" + Math.trunc(this.displayTime % 60)).slice(-2);\n    }\n\n    /** \n     * Get the audio duration in text format\n     */\n    get maxTimeDisplay() {\n        return (\"0\" + Math.trunc(this.duration / 60)).slice(-2) + \":\" + (\"0\" + Math.trunc(this.duration % 60)).slice(-2);\n    }\n\n    /**\n     * Get the percent played\n     */\n    get percent() {\n        return (100 - Math.round((this.duration - this.displayTime) / this.duration * 100));\n    }\n\n    /**\n     * Get the remaining time in text format\n     */\n    get remainingTimeDisplay() {\n        return (\"0\" + Math.trunc((this.duration - this.displayTime) / 60)).slice(-2) + \":\" + (\"0\" + Math.trunc((this.duration - this.displayTime) % 60)).slice(-2);\n    }\n\n    set contextManager(contextManager: AudioContextManager | undefined) {\n        this._contextManager = contextManager;\n    }\n\n    get order(): number {\n        return -1;\n    }\n\n    get id(): string {\n        return Constants.BUFFER_PLAYER;\n    }\n}\n","import { EventType } from \"../model/EventTypeEnum\";\nimport { ConfigService } from \"./ConfigService\";\nimport utilFunctions from \"../utils/Functions\";\nimport EventEmitter from \"../utils/EventEmitter\";\nimport AudioContextManager from \"@/audioEditor/AudioContextManager\";\n\nexport default class BufferFetcherService {\n\n    private contextManager: AudioContextManager;\n    private buffers: Map<string, AudioBuffer> = new Map<string, AudioBuffer>();\n    private bufferErrors: string[] = [];\n    private eventEmitter: EventEmitter | null;\n    private configService: ConfigService | null = null;\n\n    constructor(contextManager: AudioContextManager, configService: ConfigService, eventEmitter?: EventEmitter) {\n        this.contextManager = contextManager;\n        this.eventEmitter = eventEmitter || new EventEmitter();\n        this.configService = configService;\n    }\n\n    async fetchBuffer(bufferURI: string, force?: boolean) {\n        const realBufferURI = (this.configService ? this.configService.getSoundBasePath() : \"\") + bufferURI;\n\n        if(this.buffers.get(this.getKeyFromLocation(realBufferURI)) != null && !force) {\n            return;\n        }\n\n        this.eventEmitter?.emit(EventType.FETCHING_BUFFERS, realBufferURI);\n\n        try {\n            const response = await fetch(realBufferURI);\n\n            if(!response.ok) {\n                this.bufferErrors.push(realBufferURI);\n                this.eventEmitter?.emit(EventType.FETCHING_BUFFERS_ERROR, realBufferURI);\n                throw EventType.FETCHING_BUFFERS_ERROR;\n            } else {\n                const arrayBuffer = await response.arrayBuffer();\n\n                if (this.contextManager && this.contextManager.currentContext) {\n                    const buffer = await this.contextManager.currentContext.decodeAudioData(arrayBuffer);\n                    this.buffers.set(this.getKeyFromLocation(realBufferURI), utilFunctions.decodeBuffer(this.contextManager.currentContext, buffer));\n                }\n            }\n    \n            this.eventEmitter?.emit(EventType.FINISHED_FETCHING_BUFFERS, realBufferURI);\n        } catch(e) {\n            this.bufferErrors.push(realBufferURI);\n            this.eventEmitter?.emit(EventType.FETCHING_BUFFERS_ERROR, realBufferURI);\n            throw EventType.FETCHING_BUFFERS_ERROR;\n        }\n    }\n\n    async fetchAllBuffers(bufferURIs: string[]) {\n        for(const uri of bufferURIs) {\n            await this.fetchBuffer(uri);\n        }\n    }\n\n    getAudioBuffer(filename: string): AudioBuffer | undefined {\n        return this.buffers.get(this.getKeyFromLocation(filename));\n    }\n\n    async getOrFetchAudioBuffer(filename: string): Promise<AudioBuffer | undefined> {\n        if(this.getAudioBuffer(filename) == null) {\n            await this.fetchBuffer(filename);\n        }\n\n        return this.getAudioBuffer(filename);\n    }\n\n    getDownloadedBuffersList(): string[] {\n        return Array.from(this.buffers.keys());\n    }\n\n    private getKeyFromLocation(location: string) {\n        return location.substring(location.lastIndexOf(\"/\") + 1);\n    }\n\n    reset() {\n        this.buffers.clear();\n    }\n}\n","import Constants from \"../model/Constants\";\nimport { ConfigService } from \"../services/ConfigService\";\n\n/**\n * Default implementation for a ConfigService, using a built-in map.\n * The configuration is not stored in localstorage in this case.\n */\nexport default class GenericConfigService implements ConfigService {\n\n    private mapConfig = new Map<string, string>();\n\n    getConfig(key: string): string | undefined | null {\n        return this.mapConfig.get(key);\n    }\n\n    setConfig(key: string, value: string): void {\n        this.mapConfig.set(key, value);\n    }\n\n    isCompatibilityModeEnabled(): boolean {\n        return this.getConfig(Constants.PREFERENCES_KEYS.COMPATIBILITY_MODE_ENABLED) == \"true\";\n    }\n\n    isCompatibilityModeChecked(): boolean {\n        return this.getConfig(Constants.PREFERENCES_KEYS.COMPATIBILITY_MODE_CHECKED) == \"true\";\n    }\n\n    isAudioWorkletEnabled(): boolean {\n        const setting = this.getConfig(Constants.PREFERENCES_KEYS.ENABLE_AUDIO_WORKLET);\n\n        if(setting != null) {\n            return setting == \"true\";\n        }\n\n        return Constants.ENABLE_AUDIO_WORKLET;\n    }\n\n    isSoundtouchAudioWorkletEnabled(): boolean {\n        const setting = this.getConfig(Constants.PREFERENCES_KEYS.ENABLE_SOUNDTOUCH_AUDIO_WORKLET);\n\n        if(setting != null) {\n            return setting == \"true\";\n        }\n\n        return Constants.ENABLE_SOUNDTOUCH_AUDIO_WORKLET;\n    }\n\n    getBufferSize(): number {\n        const setting = this.getConfig(Constants.PREFERENCES_KEYS.BUFFER_SIZE);\n\n        if(setting != null) {\n            return parseInt(setting);\n        }\n\n        return Constants.DEFAULT_BUFFER_SIZE;\n    }\n\n    getSampleRate(): number {\n        const setting = this.getConfig(Constants.PREFERENCES_KEYS.SAMPLE_RATE);\n\n        if(setting != null) {\n            return parseInt(setting);\n        }\n\n        return Constants.DEFAULT_SAMPLE_RATE;\n    }\n\n    getBitrateMP3(): number {\n        const setting = this.getConfig(Constants.PREFERENCES_KEYS.BITRATE_MP3);\n\n        if(setting != null) {\n            return parseInt(setting);\n        }\n\n        return Constants.DEFAULT_MP3_BITRATE;\n    }\n\n    enableCompatibilityMode() {\n        this.setConfig(Constants.PREFERENCES_KEYS.COMPATIBILITY_MODE_ENABLED, \"true\");\n    }\n\n    disableCompatibilityMode() {\n        this.setConfig(Constants.PREFERENCES_KEYS.COMPATIBILITY_MODE_ENABLED, \"false\");\n    }\n\n    getWorkletBasePath(): string {\n        return \"\";\n    }\n\n    getWorkerBasePath(): string {\n        return \"\";\n    }\n\n    getSoundBasePath(): string {\n        return \"\";\n    }\n\n    isInitialRenderingDisabled(): boolean {\n        const setting = this.getConfig(Constants.PREFERENCES_KEYS.DISABLE_INITIAL_RENDERING);\n\n        if(setting != null) {\n            return setting == \"true\";\n        }\n\n        return Constants.DISABLE_INITIAL_RENDERING;\n    }\n};\n","import { EventType } from \"../model/EventTypeEnum\";\nimport EventEmitter from \"../utils/EventEmitter\";\nimport utilFunctions from \"../utils/Functions\";\nimport AudioContextManager from \"@/audioEditor/AudioContextManager\";\n\nexport default class BufferDecoderService {\n\n    private contextManager: AudioContextManager;\n    private eventEmitter: EventEmitter | null;\n\n    constructor(contextManager: AudioContextManager, eventEmitter?: EventEmitter) {\n        this.contextManager = contextManager;\n        this.eventEmitter = eventEmitter || new EventEmitter();\n    }\n\n    async decodeBufferFromFile(file: File): Promise<AudioBuffer | null> {\n        if (this.eventEmitter) {\n            this.eventEmitter.emit(EventType.DECODING_AUDIO_FILE);\n        }\n\n        try {\n            if (this.contextManager && this.contextManager.currentContext) {\n                const buffer = await utilFunctions.loadAudioBuffer(this.contextManager.currentContext, file);\n    \n                if (this.eventEmitter) {\n                    this.eventEmitter.emit(EventType.DECODED_AUDIO_FILE);\n                }\n    \n                return buffer;\n            }\n        } catch (e) {\n            console.error(e);\n\n            if (this.eventEmitter) {\n                this.eventEmitter.emit(EventType.DECODED_AUDIO_FILE);\n                this.eventEmitter.emit(EventType.ERROR_DECODING_AUDIO_FILE);\n            }\n        }\n\n        return null;\n    }\n}\n","import AbstractAudioElement from \"./AbstractAudioElement\";\nimport { AudioFilterNodes } from \"../../model/AudioNodes\";\nimport { FilterSettingValue, FilterSettings } from \"../../model/filtersSettings/FilterSettings\";\nimport EventEmitter from \"../../utils/EventEmitter\";\n\nexport default abstract class AbstractAudioFilter extends AbstractAudioElement {\n\n    private defaultSettings: FilterSettings | null = null;\n    eventEmitter: EventEmitter | undefined = undefined;\n\n    /** Return a input and output AudioNode of the filter */\n    abstract getNode(context: BaseAudioContext): AudioFilterNodes;\n    /** Return an object with current settings of this filter */\n    abstract getSettings(): FilterSettings;\n    /** Set a filter setting */\n    abstract setSetting(settingId: string, value: FilterSettingValue): Promise<void>;\n\n    /** Get the amount of time this filter add to the audio */\n    getAddingTime(): number {\n        return 0;\n    }\n\n    /** Store the default settings */\n    public initializeDefaultSettings() {\n        this.defaultSettings = this.getSettings();\n    }\n\n    /** Returns the default settings of this filter */\n    public getDefaultSettings() {\n        return this.defaultSettings;\n    }\n\n    /** Reset the default settings of this filter */\n    public async resetSettings() {\n        if (this.defaultSettings) {\n            for (const key in this.defaultSettings) {\n                if (this.defaultSettings && typeof (this.defaultSettings[key]) !== \"undefined\") {\n                    await this.setSetting(key, this.defaultSettings[key]);\n                }\n            }\n        }\n    }\n\n    /** Return if the current filter use an audio worklet */\n    public isWorklet() {\n        return false;\n    }\n}\n","import AbstractAudioFilter from \"./interfaces/AbstractAudioFilter\";\nimport Constants from \"../model/Constants\";\nimport BassBoosterSettings from \"../model/filtersSettings/BassBoosterSettings\";\nimport { FilterSettingValue } from \"../model/filtersSettings/FilterSettings\";\nimport utilFunctions from \"../utils/Functions\";\n\nexport default class BassBoosterFilter extends AbstractAudioFilter {\n    private frequencyBooster = 200;\n    private frequencyReduce = 200;\n    private dbBooster = 15;\n    private dbReduce = -2;\n\n    constructor(frequencyBooster: number, dbBooster: number, frequencyReduce: number, dbReduce: number) {\n        super();\n        this.frequencyBooster = frequencyBooster;\n        this.dbBooster = dbBooster;\n        this.frequencyReduce = frequencyReduce;\n        this.dbReduce = dbReduce;\n    }\n\n    getNode(context: BaseAudioContext) {\n        const bassBoostFilter = context.createBiquadFilter();\n        bassBoostFilter.type = \"lowshelf\";\n        bassBoostFilter.frequency.value = this.frequencyBooster;\n        bassBoostFilter.gain.value = this.dbBooster;\n\n        const bassBoostFilterHighFreq = context.createBiquadFilter();\n        bassBoostFilterHighFreq.type = \"highshelf\";\n        bassBoostFilterHighFreq.frequency.value = this.frequencyReduce;\n        bassBoostFilterHighFreq.gain.value = this.dbReduce;\n        bassBoostFilterHighFreq.connect(bassBoostFilter);\n\n        return {\n            input: bassBoostFilterHighFreq,\n            output: bassBoostFilter\n        };\n    }\n    \n    get order(): number {\n        return 3;\n    }\n\n    get id(): string {\n        return Constants.FILTERS_NAMES.BASS_BOOST;\n    }\n\n    getSettings(): BassBoosterSettings {\n        return {\n            frequencyBooster: this.frequencyBooster,\n            frequencyReduce: this.frequencyReduce,\n            dbBooster: this.dbBooster,\n            dbReduce: this.dbReduce,\n        };\n    }\n\n    async setSetting(settingId: string, value: FilterSettingValue) {\n        if(!utilFunctions.isSettingValueValid(value)) {\n            return;\n        }\n\n        switch(settingId) {\n        case \"frequencyBooster\":\n            this.frequencyBooster = parseInt(value as string);\n            break;\n        case \"frequencyReduce\":\n            this.frequencyReduce = parseInt(value as string);\n            break;\n        case \"dbBooster\":\n            this.dbBooster = parseInt(value as string);\n            break;\n        case \"dbReduce\":\n            this.dbReduce = parseInt(value as string);\n            break;\n        }\n    }\n}\n","/* eslint-disable @typescript-eslint/no-unused-vars */\n/**\n * This class is a polyfill for the standard web AudioParam class used by worklets\n */\nexport default class AudioParamPolyfill implements AudioParam {\n    private _value: number = 0;\n    private _minValue: number = 0;\n    private _maxValue: number = Number.MAX_SAFE_INTEGER;\n    private _defaultValue: number = 0;\n    private context: BaseAudioContext | null = null;\n    automationRate: AutomationRate = \"a-rate\";\n\n    constructor(context: BaseAudioContext, defaultValue?: number) {\n        this._defaultValue = defaultValue !== undefined ? defaultValue : 0;\n        this._value = this._defaultValue;\n        this.context = context;\n    }\n\n    get value(): number {\n        return this._value;\n    }\n\n    set value(newValue: number) {\n        this._value = Math.max(this._minValue, Math.min(this._maxValue, newValue));\n    }\n\n    get minValue(): number {\n        return this._minValue;\n    }\n\n    get maxValue(): number {\n        return this._maxValue;\n    }\n\n    get defaultValue(): number {\n        return this._defaultValue;\n    }\n\n    setValueAtTime(value: number, startTime: number): AudioParam {\n        console.warn(\"setValueAtTime used with AudioParamPolyfill, is not fully compatible with standard AudioParam\");\n        this.value = value;\n        return new AudioParamPolyfill(this.context!, value);\n    }\n\n    linearRampToValueAtTime(value: number, endTime: number): AudioParam {\n        console.warn(\"linearRampToValueAtTime used with AudioParamPolyfill, is not fully compatible with standard AudioParam\");\n        this.value = value;\n        return new AudioParamPolyfill(this.context!, value);\n    }\n\n    exponentialRampToValueAtTime(value: number, endTime: number): AudioParam {\n        console.warn(\"exponentialRampToValueAtTime used with AudioParamPolyfill, is not fully compatible with standard AudioParam\");\n        this.value = value;\n        return new AudioParamPolyfill(this.context!, value);\n    }\n\n    cancelAndHoldAtTime(cancelTime: number): AudioParam {\n        throw new Error(\"Method not implemented.\");\n    }\n\n    cancelScheduledValues(cancelTime: number): AudioParam {\n        throw new Error(\"Method not implemented.\");\n    }\n\n    setTargetAtTime(target: number, startTime: number, timeConstant: number): AudioParam {\n        throw new Error(\"Method not implemented.\");\n    }\n\n    setValueCurveAtTime(values: unknown, startTime: unknown, duration: unknown): AudioParam {\n        throw new Error(\"Method not implemented.\");\n    }\n}\n","import SimpleAudioWorkletProcessor from \"./SimpleAudioWorkletProcessor\";\nimport AudioParamPolyfill from \"./AudioParamPolyfill\";\nimport Functions from \"../utils/Functions\";\n\n/**\n * This class convert an audio worklet processor node to a script processor node\n * automagically. Highly experimental, and might not work with some WorkletProcessor\n */\nexport default class WorkletScriptProcessorNodeAdapter {\n\n    private workletProcessor: SimpleAudioWorkletProcessor;\n    private _parameters = new Map<string, AudioParamPolyfill>();\n    private _port: MessagePort | null = null;\n    private _scriptProcessorNode: ScriptProcessorNode | null;\n    private currentContext: BaseAudioContext | null = null;\n\n    constructor(context: BaseAudioContext, node: SimpleAudioWorkletProcessor, bufferSize?: number) {\n        this.workletProcessor = node;\n        this.currentContext = context;\n\n        // Create a ScriptProcessorNode with the same number of input and output channels\n        this._scriptProcessorNode = context.createScriptProcessor(\n            bufferSize,\n            2,\n            2\n        );\n\n        this.setupPort();\n        this.setupProcessor();\n        this.setupWorkletScope(context);\n    }\n\n    private setupPort(): void {\n        const messageChannel = new MessageChannel();\n\n        messageChannel.port1.onmessage = (ev) => {\n            if(this.workletProcessor && this.workletProcessor.port2) {\n                this.workletProcessor.port2.postMessage(ev.data);\n            }\n        };\n\n        if(this.workletProcessor && this.workletProcessor.port2) {\n            this.workletProcessor.port2.onmessage = (ev) => {\n                messageChannel.port1.postMessage(ev.data);\n            };\n        }\n\n        this._port = messageChannel.port2;\n    }\n\n    private setupProcessor() {\n        if(!this._scriptProcessorNode) {\n            return;\n        }\n\n        this._scriptProcessorNode.onaudioprocess = (ev: AudioProcessingEvent) => {\n            if(this.workletProcessor) {\n                const inputArray = [Functions.convertAudioBufferToFloat32Array(ev.inputBuffer)];\n                const ouputArray = [Functions.convertAudioBufferToFloat32Array(ev.outputBuffer)];\n\n                const records: [string, Float32Array][] = [];\n\n                for (const [key, value] of this._parameters.entries()) {\n                    records.push([key, Functions.convertAudioParamToFloat32Array(value, 1)]);\n                }\n\n                const recordsMap: Record<string, Float32Array> = Object.fromEntries(records);\n                \n                this.workletProcessor.process(inputArray, ouputArray, recordsMap);\n            }\n        };\n\n        const descriptors = this.workletProcessor.defaultParameterDescriptors;\n\n        if(descriptors) {\n            descriptors.forEach(descriptor => {\n                if(this.currentContext) {\n                    this._parameters.set(descriptor.name, new AudioParamPolyfill(this.currentContext, descriptor.defaultValue));\n                }\n            });\n        }\n    }\n\n    private setupWorkletScope(context: BaseAudioContext) {\n        if(typeof(window) !== \"undefined\") {\n            window.sampleRate = context.sampleRate;\n        }\n    }\n\n    get port() {\n        return this._port;\n    }\n\n    get parameters(): AudioParamMap {\n        return this._parameters;\n    }\n\n    get node() {\n        return this._scriptProcessorNode;\n    }\n\n    get context() {\n        return this._scriptProcessorNode?.context;\n    }\n}\n","import SimpleAudioWorkletProcessor from \"./SimpleAudioWorkletProcessor\";\n\n/**\n * Polyfill for registerProcessor method used in AudioWorklets\n */\nexport default class RegisterProcessorPolyfill {\n\n    private static processorsMap = new Map<string, typeof SimpleAudioWorkletProcessor>();\n\n    static registerProcessor(processorName: string, processorClass: typeof SimpleAudioWorkletProcessor) {\n        RegisterProcessorPolyfill.processorsMap.set(processorName, processorClass);\n    }\n\n    static getProcessor(processorName: string): SimpleAudioWorkletProcessor | null {\n        const processor = RegisterProcessorPolyfill.processorsMap.get(processorName);\n\n        if(processor) {\n            return new processor();\n        }\n\n        return null;\n    }\n};\n","/**\n * This class is the standard AudioWorkletProcessor interface\n */\nexport interface AudioWorkletProcessorInterface {\n\n    process(inputs: Float32Array[][], outputs: Float32Array[][], parameters: Record<string, Float32Array>): boolean;\n    get parameters(): AudioParamMap;\n    get parameterDescriptors(): AudioParamMap;\n    messageProcessor?: (event: MessageEvent) => void;\n}\n\ntype ParameterDescriptors = {\n    name: string;\n    defaultValue: number;\n}[];\n\n/**\n * This class is a polyfill for the AudioWorkletProcessor interface\n */\nexport default class SimpleAudioWorkletProcessor implements AudioWorkletProcessorInterface {\n    private messageChannel: MessageChannel | null = null;\n    messageProcessor?: ((event: MessageEvent) => void) | undefined;\n\n    constructor() {\n        this.messageChannel = new MessageChannel();\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    process(inputs: Float32Array[][], outputs: Float32Array[][], parameters: Record<string, Float32Array>): boolean {\n        return true;\n    }\n\n    get port(): MessagePort | null {\n        return this.messageChannel && this.messageChannel.port1;\n    }\n\n    get port2(): MessagePort | null {\n        return this.messageChannel && this.messageChannel.port2;\n    }\n\n    get parameters(): AudioParamMap {\n        throw new Error(\"Method not implemented.\");\n    }\n\n    get parameterDescriptors(): AudioParamMap {\n        throw new Error(\"Method not implemented.\");\n    }\n\n    get defaultParameterDescriptors(): ParameterDescriptors {\n        return [];\n    }\n};\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport RegisterProcessorPolyfill from \"./RegisterProcessorPolyfill\";\nimport SimpleAudioWorkletProcessor from \"./SimpleAudioWorkletProcessor\";\n\nif(typeof(window) !== \"undefined\" && !(\"AudioWorkletProcessor\" in window)) {\n    (window as any).AudioWorkletProcessor = SimpleAudioWorkletProcessor;\n    (window as any).registerProcessor = RegisterProcessorPolyfill.registerProcessor;\n}\n\nif(typeof(global) !== \"undefined\" && !(\"AudioWorkletProcessor\" in global)) {\n    (global as any).AudioWorkletProcessor = SimpleAudioWorkletProcessor;\n    (global as any).registerProcessor = RegisterProcessorPolyfill.registerProcessor;\n}\n","import WorkletScriptProcessorNodeAdapter from \"../../workletPolyfill/WorkletScriptProcessorNodeAdapter\";\nimport AbstractAudioFilter from \"./AbstractAudioFilter\";\nimport Constants from \"../../model/Constants\";\nimport \"../../workletPolyfill/AudioWorkletProcessorPolyfill\";\nimport RegisterProcessorPolyfill from \"../../workletPolyfill/RegisterProcessorPolyfill\";\nimport utilFunctions from \"../../utils/Functions\";\n\nexport default abstract class AbstractAudioFilterWorklet<T> extends AbstractAudioFilter {\n\n    protected currentWorkletNode: AudioWorkletNode | WorkletScriptProcessorNodeAdapter | null = null;\n    protected fallbackToScriptProcessor = false;\n    protected keepCurrentNodeIfPossible = false;\n\n    /**\n     * Return the worklet name (as registered with method registerProcessor)\n     */\n    abstract get workletName(): string;\n\n    /**\n     * Return the path to worklet file\n     */\n    abstract get workletPath(): string;\n\n    /**\n     * Receive event from the worklet\n     */\n    abstract receiveEvent(message: MessageEvent<T>): void;\n\n    /**\n     * Initialize the audio worklet by loading the module\n     * @param audioContext The audio context\n     */\n    async initializeWorklet(audioContext: BaseAudioContext): Promise<void> {\n        this.stop();\n\n        if(!utilFunctions.isAudioWorkletCompatible(audioContext)) {\n            console.error(\"Audio Worklets not supported on this browser. Fallback to ScriptProcessor\");\n            this.fallbackToScriptProcessor = true;\n            return;\n        }\n\n        const workletPath = (this.configService ? this.configService.getWorkletBasePath() : \"\") + this.workletPath;\n\n        await audioContext.audioWorklet.addModule(workletPath)\n            .catch(e => {\n                console.error(`Error when loading Worklet (${workletPath}) for filter ${this.id}. Fallback to ScriptProcessor. Exception:`, e);\n                this.fallbackToScriptProcessor = true;\n            });\n    }\n\n    /**\n     * This method checks if audio worklet are enabled\n     * @param audioContext \n     */\n    protected isAudioWorkletEnabled() {\n        if(this.configService) {\n            return this.configService.isAudioWorkletEnabled();\n        }\n\n        return Constants.ENABLE_AUDIO_WORKLET;\n    }\n\n    /**\n     * Initialize the AudioWorkletNode or fallback to ScriptProcessorNode\n     * @param context The audio context\n     * @param workletName The worklet name\n     */\n    private initializeNode(context: BaseAudioContext, workletName: string) {\n        if (this.isAudioWorkletEnabled() && !this.fallbackToScriptProcessor) {\n            // Standard Audio Worklet\n            this.currentWorkletNode = new AudioWorkletNode(context, workletName);\n        } else {\n            // Fallback to ScriptProcessorNode (polyfill)\n            const processor = RegisterProcessorPolyfill.getProcessor(workletName);\n\n            if(processor) {\n                this.currentWorkletNode = new WorkletScriptProcessorNodeAdapter(context, processor, this.configService!.getBufferSize());\n            } else {\n                throw new Error(`No processor registered with name ${workletName} for filter ${this.id} to use the fallback/polyfill for AudioWorklet. Make sure you have created the class.`);\n            }\n        }\n\n        if (this.currentWorkletNode && this.currentWorkletNode.port) {\n            this.currentWorkletNode.port.onmessage = message => this.receiveEvent(message);\n        }\n    }\n\n    /**\n     * Apply current settings to the audio worklet node.\n     * Uses the getSettings method to extract the settings.\n     */\n    protected applyCurrentSettingsToWorklet() {\n        if (this.currentWorkletNode && this.currentWorkletNode.parameters) {\n            const currentSettings = this.getSettings();\n\n            for (const settingKey of Object.keys(currentSettings)) {\n                const settingFromWorklet = this.currentWorkletNode.parameters.get(settingKey);\n\n                if (settingFromWorklet) {\n                    settingFromWorklet.value = currentSettings[settingKey] as number;\n                    settingFromWorklet.setValueAtTime(currentSettings[settingKey] as number, 0);\n                }\n            }\n        }\n    }\n\n    /** Default implementation for GetNode - AbstractAudioFilterWorklet */\n    getNode(context: BaseAudioContext) {\n        if(!this.keepCurrentNodeIfPossible || !this.currentWorkletNode\n            || this.currentWorkletNode.context != context) {\n            this.stop();\n            this.initializeNode(context, this.workletName);\n        }\n\n        this.applyCurrentSettingsToWorklet();\n        this.setEnabled(this.isEnabled());\n\n        if (this.currentWorkletNode) {\n            if (this.currentWorkletNode instanceof WorkletScriptProcessorNodeAdapter) {\n                return {\n                    input: this.currentWorkletNode.node!,\n                    output: this.currentWorkletNode.node!,\n                };\n            } else {\n                return {\n                    input: this.currentWorkletNode,\n                    output: this.currentWorkletNode,\n                };\n            }\n        }\n\n        throw new Error(\"Worklet node has not yet been created\");\n    }\n\n    /**\n     * Stop the current worklet node. The worklet need to respond to \"stop\" events.\n     */\n    stop() {\n        if (this.currentWorkletNode && this.currentWorkletNode.port) {\n            this.currentWorkletNode.port.postMessage(\"stop\");\n            this.currentWorkletNode.port.onmessage = null;\n        }\n\n        this.currentWorkletNode = null;\n    }\n\n    /**\n     * Pass the current disabled/enabled state to the worklet.\n     * The worklet need to respond to \"enable\"/\"disable\" events.\n     * @param state The current disabled/enabled state\n     */\n    setEnabled(state: boolean): void {\n        if (this.currentWorkletNode && this.currentWorkletNode.port) {\n            this.currentWorkletNode.port.postMessage(state ? \"enable\" : \"disable\");\n        }\n\n        super.setEnabled(state);\n    }\n\n    public isWorklet(): boolean {\n        return true;\n    }\n}\n","import Constants from \"../../model/Constants\";\n\nclass BitCrusherProcessor extends AudioWorkletProcessor {\n    private stopped = false;\n    private phaser: number[] | null = null;\n    private last: number[] | null = null;\n\n    constructor() {\n        super();\n        this.port.onmessage = (event) => {\n            if (event.data == \"stop\") {\n                this.stop();\n            }\n        };\n    }\n\n    static get parameterDescriptors() {\n        return [\n            { name: \"bits\", defaultValue: 16 },\n            { name: \"normFreq\", defaultValue: 0.9 },\n        ];\n    }\n\n    get defaultParameterDescriptors() {\n        return BitCrusherProcessor.parameterDescriptors;\n    }\n\n    process(inputs: Float32Array[][], outputs: Float32Array[][], parameters: Record<string, Float32Array>): boolean {\n        if (this.stopped) return false;\n\n        const input = inputs[0];\n        const output = outputs[0];\n\n        const step = 2 * Math.pow(1 / 2, parameters.bits[0]);\n        const currentNormFreq = (1 - parameters.normFreq[0]) / (sampleRate / 48000);\n\n        if (this.last == null) {\n            this.last = new Array(input.length).fill(0);\n        }\n\n        if (this.phaser == null) {\n            this.phaser = new Array(input.length).fill(0);\n        }\n\n        if (input && input[0]) {\n            const blockSize = input[0].length;\n\n            for (let channel = 0; channel < input.length; channel++) {\n                const inp = input[channel];\n                const out = output[channel];\n\n                if (inp && out) {\n                    for (let i = 0; i < blockSize; i++) {\n                        this.phaser[channel] += currentNormFreq;\n\n                        if (this.phaser[channel] >= 1.0) {\n                            this.phaser[channel] -= 1.0;\n                            this.last[channel] = step * Math.floor((inp[i] * (1 / step)) + 0.5);\n                        }\n\n                        out[i] = this.last[channel];\n                    }\n                }\n            }\n        }\n\n        return true;\n    }\n\n    stop() {\n        this.stopped = true;\n        this.phaser = null;\n        this.last = null;\n    }\n}\n\nregisterProcessor(Constants.WORKLET_NAMES.BITCRUSHER, BitCrusherProcessor);\n","import AbstractAudioFilterWorklet from \"./interfaces/AbstractAudioFilterWorklet\";\nimport Constants from \"../model/Constants\";\nimport BitCrusherSettings from \"../model/filtersSettings/BitCrusherSettings\";\nimport { FilterSettingValue } from \"../model/filtersSettings/FilterSettings\";\nimport \"./worklets/BitCrusher.worklet\";\nimport utilFunctions from \"../utils/Functions\";\n\nexport default class BitCrusherFilter extends AbstractAudioFilterWorklet<void> {\n    private bits = 16;\n    private normFreq = 0.9;\n\n    constructor(bits: number, normFreq: number) {\n        super();\n        this.bits = bits;\n        this.normFreq = normFreq;\n    }\n    \n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    receiveEvent(message: MessageEvent<void>): void {\n        // Do nothing\n    }\n\n    get workletPath(): string {\n        return Constants.WORKLET_PATHS.BITCRUSHER;\n    }\n    \n    get workletName(): string {\n        return Constants.WORKLET_NAMES.BITCRUSHER;\n    }\n\n    get order(): number {\n        return 6;\n    }\n\n    get id(): string {\n        return Constants.FILTERS_NAMES.BITCRUSHER;\n    }\n\n    getSettings(): BitCrusherSettings {\n        return {\n            bits: this.bits,\n            normFreq: this.normFreq,\n        };\n    }\n\n    async setSetting(settingId: string, value: FilterSettingValue) {\n        if(!utilFunctions.isSettingValueValid(value)) {\n            return;\n        }\n\n        switch (settingId) {\n        case \"bits\":\n            this.bits = parseInt(value as string);\n            break;\n        case \"normFreq\":\n            this.normFreq = parseFloat(value as string);\n            break;\n        }\n\n        this.applyCurrentSettingsToWorklet();\n    }\n}\n","import AbstractAudioFilter from \"./interfaces/AbstractAudioFilter\";\nimport Constants from \"../model/Constants\";\nimport EchoSettings from \"../model/filtersSettings/EchoSettings\";\nimport { FilterSettingValue } from \"../model/filtersSettings/FilterSettings\";\nimport utilFunctions from \"../utils/Functions\";\n\nexport default class EchoFilter extends AbstractAudioFilter {\n    private delay = 0.2;\n    private gain = 0.75;\n\n    constructor(delay: number, gain: number) {\n        super();\n        this.delay = delay;\n        this.gain = gain;\n    }\n\n    getNode(context: BaseAudioContext) {\n        const delayNode = context.createDelay(179);\n        delayNode.delayTime.value = this.delay;\n\n        const gainNode = context.createGain();\n        gainNode.gain.value = this.gain;\n\n        gainNode.connect(delayNode);\n        delayNode.connect(gainNode);\n\n        return {\n            input: gainNode,\n            output: delayNode\n        };\n    }\n    \n    get order(): number {\n        return 7;\n    }\n\n    get id(): string {\n        return Constants.FILTERS_NAMES.ECHO;\n    }\n\n    getAddingTime() {\n        return 5;\n    }\n\n    getSettings(): EchoSettings {\n        return {\n            delay: this.delay,\n            gain: this.gain\n        };\n    }\n\n    async setSetting(settingId: string, value: FilterSettingValue) {\n        if(!utilFunctions.isSettingValueValid(value)) {\n            return;\n        }\n        \n        switch(settingId) {\n        case \"delay\":\n            this.delay = parseFloat(value as string);\n            break;\n        case \"gain\":\n            this.gain = parseFloat(value as string);\n            break;\n        }\n    }\n}\n","import AbstractAudioFilter from \"./interfaces/AbstractAudioFilter\";\nimport Constants from \"../model/Constants\";\nimport HighPassSettings from \"../model/filtersSettings/HighPassSettings\";\nimport { FilterSettingValue } from \"../model/filtersSettings/FilterSettings\";\nimport utilFunctions from \"../utils/Functions\";\n\nexport default class HighPassFilter extends AbstractAudioFilter {\n    private highFrequency = 3500;\n\n    constructor(highFrequency: number) {\n        super();\n        this.highFrequency = highFrequency;\n    }\n\n    getNode(context: BaseAudioContext) {\n        const highPassFilter = context.createBiquadFilter();\n        highPassFilter.type = \"highpass\";\n        highPassFilter.frequency.value = this.highFrequency;\n\n        return {\n            input: highPassFilter,\n            output: highPassFilter\n        };\n    }\n    \n    get order(): number {\n        return 4;\n    }\n\n    get id(): string {\n        return Constants.FILTERS_NAMES.HIGH_PASS;\n    }\n\n    getSettings(): HighPassSettings {\n        return {\n            highFrequency: this.highFrequency\n        };\n    }\n\n    async setSetting(settingId: string, value: FilterSettingValue) {\n        if(!utilFunctions.isSettingValueValid(value)) {\n            return;\n        }\n        \n        switch(settingId) {\n        case \"highFrequency\":\n            this.highFrequency = parseInt(value as string);\n            break;\n        }\n    }\n}\n","export default class DelayBuffer {\n    private _array: Float32Array = new Float32Array();\n    private n: number = 0;\n    private length: number = 0;\n    private readPointer: number = 0;\n    private writePointer: number = 0;\n\n    constructor(n: number) {\n        this.n = Math.floor(n);\n        this.init();\n    }\n\n    init() {\n        this._array = new Float32Array(2 * this.n);\n        this.length = this._array.length;\n        this.readPointer = 0;\n        this.writePointer = this.n - 1;\n        this._array.fill(0);\n    }\n\n    read() {\n        const value = this._array[this.readPointer % this.length];\n        this.readPointer = (this.readPointer + 1) % this.length;\n        return value;\n    }\n\n    push(v: number) {\n        this._array[this.writePointer % this.length] = v;\n        this.writePointer = (this.writePointer + 1) % this.length;\n    }\n\n    reset() {\n        this.init();\n    }\n\n    clear() {\n        this._array = new Float32Array();\n        this.length = 0;\n        this.readPointer = 0;\n        this.writePointer = 0;\n    }\n\n    sum() {\n        return this._array.reduce((a, b) => a + b, 0);\n    }\n}\n","/*\n * Copyright (C) 2019-2023 Eliastik (eliastiksofts.com)\n *\n * This file is part of \"Simple Voice Changer\".\n *\n * \"Simple Voice Changer\" is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * \"Simple Voice Changer\" is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with \"Simple Voice Changer\".  If not, see <http://www.gnu.org/licenses/>.\n */\n// Source: https://webaudiotech.com/2016/01/21/should-your-web-audio-app-have-a-limiter/ (https://web.archive.org/web/20220519100003/https://webaudiotech.com/2016/01/21/should-your-web-audio-app-have-a-limiter/)\n// Original code: https://webaudiotech.com/sites/limiter_comparison/limiter.js\n// Additions by Eliastik (eliastiksofts.com): Stereo and multi-channel support, code simplified in one object class (Limiter), converted into AudioWorklet\nimport Constants from \"../../model/Constants\";\nimport DelayBuffer from \"../../utils/DelayBuffer\";\n\nclass LimiterProcessor extends AudioWorkletProcessor {\n    private delayBuffer: DelayBuffer[] = [];\n    private envelopeSample = 0;\n    private stopped = false;\n    private disabled = false;\n\n    constructor() {\n        super();\n        this.port.onmessage = (event) => {\n            if (event.data == \"reset\") {\n                this.reset();\n            } else if (event.data == \"stop\") {\n                this.stop();\n            } else if (event.data == \"disable\") {\n                this.disabled = true;\n            } else if (event.data == \"enable\") {\n                this.disabled = false;\n            }\n        };\n    }\n\n    static get parameterDescriptors() {\n        return [\n            { name: \"preGain\", defaultValue: 0 },\n            { name: \"postGain\", defaultValue: 0 },\n            { name: \"attackTime\", defaultValue: 0 },\n            { name: \"releaseTime\", defaultValue: 3 },\n            { name: \"threshold\", defaultValue: -0.05 },\n            { name: \"lookAheadTime\", defaultValue: 0 }\n        ];\n    }\n\n    get defaultParameterDescriptors() {\n        return LimiterProcessor.parameterDescriptors;\n    }\n\n    getEnvelope(data: Float32Array, attackTime: number, releaseTime: number, sampleRate: number) {\n        const attackGain = Math.exp(-1 / (sampleRate * attackTime));\n        const releaseGain = Math.exp(-1 / (sampleRate * releaseTime));\n\n        const envelope = new Float32Array(data.length);\n\n        for (let i = 0; i < data.length; i++) {\n            const envIn = Math.abs(data[i]);\n\n            if (this.envelopeSample < envIn) {\n                this.envelopeSample = envIn + attackGain * (this.envelopeSample - envIn);\n            } else {\n                this.envelopeSample = envIn + releaseGain * (this.envelopeSample - envIn);\n            }\n\n            envelope[i] = this.envelopeSample;\n        }\n\n        return envelope;\n    }\n\n    getMaxEnvelope(envelope: Float32Array[], channels: number, index: number) {\n        let max = envelope[0][index];\n\n        for (let channel = 0; channel < channels; channel++) {\n            if (envelope[channel][index] > max) {\n                max = envelope[channel][index];\n            }\n        }\n\n        return max;\n    }\n\n    ampToDB(value: number) {\n        return 20 * Math.log10(value);\n    }\n\n    dBToAmp(db: number) {\n        return Math.pow(10, db / 20);\n    }\n\n    process(inputs: Float32Array[][], outputs: Float32Array[][], parameters: Record<string, Float32Array>): boolean {\n        if (this.stopped) return false;\n\n        const inputBuffer = inputs[0];\n        const outputBuffer = outputs[0];\n        const envelopeData = [];\n\n        // transform db to amplitude value\n        const postGainAmp = this.dBToAmp(parameters.postGain[0]);\n        const preGainAmp = this.dBToAmp(parameters.preGain[0]);\n\n        // apply pre gain to signal\n        // compute the envelope for each channel\n        for (let channel = 0; channel < outputBuffer.length; channel++) {\n            const inp = inputBuffer[channel];\n            const out = outputBuffer[channel];\n\n            // create a delay buffer\n            if (this.delayBuffer[channel] == null) {\n                this.delayBuffer[channel] = new DelayBuffer(parameters.lookAheadTime[0] * sampleRate);\n            }\n\n            // apply pre gain to signal\n            if (inp && out) {\n                for (let k = 0; k < inp.length; ++k) {\n                    if (!this.disabled) {\n                        out[k] = preGainAmp * inp[k];\n                    } else {\n                        out[k] = inp[k];\n                    }\n                }\n            }\n\n            // compute the envelope\n            if (!this.disabled && out) {\n                envelopeData[channel] = this.getEnvelope(out, parameters.attackTime[0], parameters.releaseTime[0], sampleRate);\n            }\n        }\n\n        for (let channel = 0; channel < outputBuffer.length; channel++) {\n            const inp = inputBuffer[channel];\n            const out = outputBuffer[channel];\n\n            if (parameters.lookAheadTime[0] > 0 && out) {\n                // write signal into buffer and read delayed signal\n                for (let i = 0; i < out.length; i++) {\n                    this.delayBuffer[channel].push(out[i]);\n                    out[i] = this.delayBuffer[channel].read();\n                }\n            }\n\n            // If disabled we don't apply the limitation to the audio\n            if (this.disabled) {\n                continue;\n            }\n\n            // limiter mode: slope is 1\n            const slope = 1;\n\n            if (inp && out) {\n                for (let i = 0; i < inp.length; i++) {\n                    let gainDB = slope * (parameters.threshold[0] - this.ampToDB(this.getMaxEnvelope(envelopeData, outputBuffer.length, i))); // max gain\n\n                    // is gain below zero?\n                    gainDB = Math.min(0, gainDB);\n                    const gain = this.dBToAmp(gainDB);\n                    out[i] *= (gain * postGainAmp);\n                }\n            }\n        }\n\n        return true;\n    }\n\n    reset() {\n        for (let i = 0; i < this.delayBuffer.length; i++) {\n            if (this.delayBuffer[i] != null) {\n                this.delayBuffer[i].reset();\n            }\n        }\n\n        this.envelopeSample = 0;\n    }\n\n    stop() {\n        for (let i = 0; i < this.delayBuffer.length; i++) {\n            if (this.delayBuffer[i] != null) {\n                this.delayBuffer[i].clear();\n            }\n        }\n\n        this.delayBuffer = [];\n        this.envelopeSample = 0;\n        this.stopped = true;\n    }\n}\n\nregisterProcessor(Constants.WORKLET_NAMES.LIMITER, LimiterProcessor);\n","import AbstractAudioFilterWorklet from \"./interfaces/AbstractAudioFilterWorklet\";\nimport Constants from \"../model/Constants\";\nimport LimiterSettings from \"../model/filtersSettings/LimiterSettings\";\nimport { FilterSettingValue } from \"../model/filtersSettings/FilterSettings\";\nimport \"./worklets/Limiter.worklet\";\nimport utilFunctions from \"../utils/Functions\";\n\nexport default class LimiterFilter extends AbstractAudioFilterWorklet<void> {\n    private preGain = 0; // dB\n    private postGain = 0; // dB\n    private attackTime = 0; // s\n    private releaseTime = 3; // s\n    private threshold = -0.05; // dB\n    private lookAheadTime = 0.1; // s\n\n    constructor(preGain: number, postGain: number, attackTime: number, releaseTime: number, threshold: number, lookAheadTime: number) {\n        super();\n        this.preGain = preGain || this.preGain;\n        this.postGain = postGain || this.postGain;\n        this.attackTime = attackTime || this.attackTime;\n        this.releaseTime = releaseTime || this.releaseTime;\n        this.threshold = threshold || this.threshold;\n        this.lookAheadTime = lookAheadTime || this.lookAheadTime;\n        this.keepCurrentNodeIfPossible = true;\n        this.enable();\n        this.setDefaultEnabled(true);\n    }\n    \n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    receiveEvent(message: MessageEvent<void>): void {\n        // Do nothing\n    }\n\n    get workletPath(): string {\n        return Constants.WORKLET_PATHS.LIMITER;\n    }\n    \n    get workletName(): string {\n        return Constants.WORKLET_NAMES.LIMITER;\n    }\n\n    get order(): number {\n        return 11;\n    }\n\n    get id(): string {\n        return Constants.FILTERS_NAMES.LIMITER;\n    }\n\n    getAddingTime() {\n        return this.lookAheadTime;\n    }\n\n    getSettings(): LimiterSettings {\n        return {\n            preGain: this.preGain,\n            postGain: this.postGain,\n            attackTime: this.attackTime,\n            releaseTime: this.releaseTime,\n            threshold: this.threshold,\n            lookAheadTime: this.lookAheadTime\n        };\n    }\n\n    async setSetting(settingId: string, value: FilterSettingValue) {\n        if(!utilFunctions.isSettingValueValid(value)) {\n            return;\n        }\n        \n        switch (settingId) {\n        case \"preGain\":\n            this.preGain = parseFloat(value as string);\n            break;\n        case \"postGain\":\n            this.postGain = parseFloat(value as string);\n            break;\n        case \"attackTime\":\n            this.attackTime = parseFloat(value as string);\n            break;\n        case \"releaseTime\":\n            this.releaseTime = parseFloat(value as string);\n            break;\n        case \"threshold\":\n            this.threshold = parseFloat(value as string);\n            break;\n        case \"lookAheadTime\":\n            this.lookAheadTime = parseFloat(value as string);\n            break;\n        }\n\n        this.applyCurrentSettingsToWorklet();\n    }\n}\n","import AbstractAudioFilter from \"./interfaces/AbstractAudioFilter\";\nimport Constants from \"../model/Constants\";\nimport LowPassSettings from \"../model/filtersSettings/LowPassSettings\";\nimport { FilterSettingValue } from \"../model/filtersSettings/FilterSettings\";\nimport utilFunctions from \"../utils/Functions\";\n\nexport default class LowPassFilter extends AbstractAudioFilter {\n    private lowFrequency = 3500;\n\n    constructor(lowFrequency: number) {\n        super();\n        this.lowFrequency = lowFrequency;\n    }\n    \n    getNode(context: BaseAudioContext) {\n        const lowPassFilter = context.createBiquadFilter();\n        lowPassFilter.type = \"lowpass\";\n        lowPassFilter.frequency.value = this.lowFrequency;\n\n        return {\n            input: lowPassFilter,\n            output: lowPassFilter\n        };\n    }\n    \n    get order(): number {\n        return 5;\n    }\n\n    get id(): string {\n        return Constants.FILTERS_NAMES.LOW_PASS;\n    }\n\n    getSettings(): LowPassSettings {\n        return {\n            lowFrequency: this.lowFrequency\n        };\n    }\n\n    async setSetting(settingId: string, value: FilterSettingValue) {\n        if(!utilFunctions.isSettingValueValid(value)) {\n            return;\n        }\n        \n        switch (settingId) {\n        case \"lowFrequency\":\n            this.lowFrequency = parseInt(value as string);\n            break;\n        }\n    }\n}\n","import AbstractAudioElement from \"./AbstractAudioElement\";\n\nexport default abstract class AbstractAudioRenderer extends AbstractAudioElement {\n    /** Render an AudioBuffer based on another input AudioBuffer */\n    abstract renderAudio(context: BaseAudioContext, buffer: AudioBuffer): Promise<AudioBuffer>;\n}","import AbstractAudioRenderer from \"./interfaces/AbstractAudioRenderer\";\nimport Constants from \"../model/Constants\";\n\nexport default class ReturnAudioRenderer extends AbstractAudioRenderer {\n    renderAudio(context: BaseAudioContext, buffer: AudioBuffer): Promise<AudioBuffer> {\n        return new Promise(resolve => {\n            const numChannels = buffer.numberOfChannels;\n            const totalFrames = context.sampleRate * buffer.duration + context.sampleRate * 2;\n            const bufferReturned = context.createBuffer(numChannels, totalFrames, context.sampleRate);\n\n            for (let channel = 0; channel < numChannels; channel++) {\n                const nowBuffering = bufferReturned.getChannelData(channel);\n                const sourceChannelData = buffer.getChannelData(channel);\n\n                for (let i = 0; i < totalFrames; i++) {\n                    if (i < sourceChannelData.length) {\n                        nowBuffering[i] = sourceChannelData[sourceChannelData.length - 1 - i];\n                    } else {\n                        nowBuffering[i] = 0;\n                    }\n                }\n            }\n\n            resolve(bufferReturned);\n        });\n    }\n\n    get order(): number {\n        return 0;\n    }\n\n    get id(): string {\n        return Constants.FILTERS_NAMES.RETURN_AUDIO;\n    }\n}\n","import AbstractAudioFilter from \"./interfaces/AbstractAudioFilter\";\nimport Constants from \"../model/Constants\";\nimport { ReverbEnvironment } from \"../model/ReverbEnvironment\";\nimport ReverbSettings from \"../model/filtersSettings/ReverbSettings\";\nimport GenericSettingValue from \"../model/filtersSettings/GenericSettingValue\";\nimport { FilterSettingValue } from \"../model/filtersSettings/FilterSettings\";\nimport utilFunctions from \"@/utils/Functions\";\n\nexport default class ReverbFilter extends AbstractAudioFilter {\n\n    private reverbEnvironment: ReverbEnvironment = Constants.DEFAULT_REVERB_ENVIRONMENT;\n    private reverbCustomEnvironmentAddTime = 5;\n    private customEnvironment: AudioBuffer | null = null;\n\n    getNode(context: BaseAudioContext) {\n        const convolver = context.createConvolver();\n\n        if (!this.reverbEnvironment || (this.reverbEnvironment.url == \"custom\" && !this.customEnvironment)) {\n            // Fallback to default environment otherwise\n            this.reverbEnvironment = Constants.DEFAULT_REVERB_ENVIRONMENT;\n        }\n\n        const buffer = this.getReverbBuffer(context);\n\n        if (buffer) {\n            convolver.buffer = buffer;\n        }\n\n        return {\n            input: convolver,\n            output: convolver\n        };\n    }\n\n    private getReverbBuffer(context: BaseAudioContext): AudioBuffer | undefined {\n        if (this.reverbEnvironment.url == \"custom\" && this.customEnvironment) {\n            if (this.customEnvironment.sampleRate === context.sampleRate) {\n                return this.customEnvironment;\n            } else {\n                this.reverbEnvironment = Constants.DEFAULT_REVERB_ENVIRONMENT;\n            }\n        } else if (this.bufferFetcherService) {\n            return this.bufferFetcherService.getAudioBuffer(this.reverbEnvironment.url);\n        }\n\n        return;\n    }\n\n    get order(): number {\n        return 9;\n    }\n\n    get id(): string {\n        return Constants.FILTERS_NAMES.REVERB;\n    }\n\n    getAddingTime() {\n        const settings = this.getSettings();\n\n        if (settings && settings.reverbEnvironment) {\n            if (settings.reverbEnvironment.value != \"custom\") {\n                if (settings.reverbEnvironment.additionalData) {\n                    return settings.reverbEnvironment.additionalData.addDuration as number;\n                }\n            } else {\n                return this.reverbCustomEnvironmentAddTime;\n            }\n        }\n\n        return 0;\n    }\n\n    getSettings(): ReverbSettings {\n        if (!this.reverbEnvironment) {\n            return {\n                reverbCustomEnvironmentAddTime: this.reverbCustomEnvironmentAddTime\n            };\n        }\n\n        return {\n            reverbEnvironment: {\n                name: this.reverbEnvironment.name,\n                value: this.reverbEnvironment.url,\n                additionalData: {\n                    size: this.reverbEnvironment.size,\n                    link: this.reverbEnvironment.link,\n                    addDuration: this.reverbEnvironment.addDuration\n                }\n            },\n            downloadedBuffers: this.bufferFetcherService?.getDownloadedBuffersList(),\n            hasCustomEnvironment: this.customEnvironment ? true : false,\n            reverbCustomEnvironmentAddTime: this.reverbCustomEnvironmentAddTime\n        };\n    }\n\n    async setSetting(settingId: string, value: FilterSettingValue) {\n        if (settingId == \"reverbEnvironment\") {\n            const reverbEnvironment = value as GenericSettingValue;\n\n            if (reverbEnvironment) {\n                const url = reverbEnvironment.value;\n\n                try {\n                    if (url != \"custom\") {\n                        await this.bufferFetcherService?.fetchBuffer(url);\n                    }\n\n                    if (reverbEnvironment.additionalData) {\n                        this.reverbEnvironment = {\n                            name: reverbEnvironment.name,\n                            url,\n                            size: reverbEnvironment.additionalData.size as number,\n                            addDuration: reverbEnvironment.additionalData.addDuration as number,\n                            link: reverbEnvironment.additionalData.link as string\n                        };\n                    } else {\n                        this.reverbEnvironment = {\n                            name: reverbEnvironment.name,\n                            url,\n                            size: 0,\n                            addDuration: 0,\n                            link: \"\"\n                        };\n                    }\n                } catch (e) { /* empty */ }\n            }\n        } else if (settingId == \"reverbCustomEnvironmentAddTime\") {\n            if (utilFunctions.isSettingValueValid(value)) {\n                this.reverbCustomEnvironmentAddTime = parseInt(value as string);\n            }\n        } else if (settingId == \"reverbCustomEnvironmentFile\") {\n            if (this.bufferDecoderService && value) {\n                this.customEnvironment = await this.bufferDecoderService.decodeBufferFromFile(value as File);\n\n                if (!this.customEnvironment) {\n                    // Fallback to default environment\n                    this.reverbEnvironment = Constants.DEFAULT_REVERB_ENVIRONMENT;\n                }\n            }\n        }\n    }\n}\n","/*\n * SoundTouch JS v0.1.30 audio processing library\n * Copyright (c) Olli Parviainen\n * Copyright (c) Ryan Berdeen\n * Copyright (c) Jakub Fiala\n * Copyright (c) Steve 'Cutter' Blades\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\nclass FifoSampleBuffer {\n  constructor() {\n    this._vector = new Float32Array();\n    this._position = 0;\n    this._frameCount = 0;\n  }\n  get vector() {\n    return this._vector;\n  }\n  get position() {\n    return this._position;\n  }\n  get startIndex() {\n    return this._position * 2;\n  }\n  get frameCount() {\n    return this._frameCount;\n  }\n  get endIndex() {\n    return (this._position + this._frameCount) * 2;\n  }\n  clear() {\n    this.receive(this._frameCount);\n    this.rewind();\n  }\n  put(numFrames) {\n    this._frameCount += numFrames;\n  }\n  putSamples(samples, position, numFrames = 0) {\n    position = position || 0;\n    const sourceOffset = position * 2;\n    if (!(numFrames >= 0)) {\n      numFrames = (samples.length - sourceOffset) / 2;\n    }\n    const numSamples = numFrames * 2;\n    this.ensureCapacity(numFrames + this._frameCount);\n    const destOffset = this.endIndex;\n    this.vector.set(samples.subarray(sourceOffset, sourceOffset + numSamples), destOffset);\n    this._frameCount += numFrames;\n  }\n  putBuffer(buffer, position, numFrames = 0) {\n    position = position || 0;\n    if (!(numFrames >= 0)) {\n      numFrames = buffer.frameCount - position;\n    }\n    this.putSamples(buffer.vector, buffer.position + position, numFrames);\n  }\n  receive(numFrames) {\n    if (!(numFrames >= 0) || numFrames > this._frameCount) {\n      numFrames = this.frameCount;\n    }\n    this._frameCount -= numFrames;\n    this._position += numFrames;\n  }\n  receiveSamples(output, numFrames = 0) {\n    const numSamples = numFrames * 2;\n    const sourceOffset = this.startIndex;\n    output.set(this._vector.subarray(sourceOffset, sourceOffset + numSamples));\n    this.receive(numFrames);\n  }\n  extract(output, position = 0, numFrames = 0) {\n    const sourceOffset = this.startIndex + position * 2;\n    const numSamples = numFrames * 2;\n    output.set(this._vector.subarray(sourceOffset, sourceOffset + numSamples));\n  }\n  ensureCapacity(numFrames = 0) {\n    const minLength = parseInt(numFrames * 2);\n    if (this._vector.length < minLength) {\n      const newVector = new Float32Array(minLength);\n      newVector.set(this._vector.subarray(this.startIndex, this.endIndex));\n      this._vector = newVector;\n      this._position = 0;\n    } else {\n      this.rewind();\n    }\n  }\n  ensureAdditionalCapacity(numFrames = 0) {\n    this.ensureCapacity(this._frameCount + numFrames);\n  }\n  rewind() {\n    if (this._position > 0) {\n      this._vector.set(this._vector.subarray(this.startIndex, this.endIndex));\n      this._position = 0;\n    }\n  }\n}\n\nclass AbstractFifoSamplePipe {\n  constructor(createBuffers) {\n    if (createBuffers) {\n      this._inputBuffer = new FifoSampleBuffer();\n      this._outputBuffer = new FifoSampleBuffer();\n    } else {\n      this._inputBuffer = this._outputBuffer = null;\n    }\n  }\n  get inputBuffer() {\n    return this._inputBuffer;\n  }\n  set inputBuffer(inputBuffer) {\n    this._inputBuffer = inputBuffer;\n  }\n  get outputBuffer() {\n    return this._outputBuffer;\n  }\n  set outputBuffer(outputBuffer) {\n    this._outputBuffer = outputBuffer;\n  }\n  clear() {\n    this._inputBuffer.clear();\n    this._outputBuffer.clear();\n  }\n}\n\nclass RateTransposer extends AbstractFifoSamplePipe {\n  constructor(createBuffers) {\n    super(createBuffers);\n    this.reset();\n    this._rate = 1;\n  }\n  set rate(rate) {\n    this._rate = rate;\n  }\n  reset() {\n    this.slopeCount = 0;\n    this.prevSampleL = 0;\n    this.prevSampleR = 0;\n  }\n  clone() {\n    const result = new RateTransposer();\n    result.rate = this._rate;\n    return result;\n  }\n  process() {\n    const numFrames = this._inputBuffer.frameCount;\n    this._outputBuffer.ensureAdditionalCapacity(numFrames / this._rate + 1);\n    const numFramesOutput = this.transpose(numFrames);\n    this._inputBuffer.receive();\n    this._outputBuffer.put(numFramesOutput);\n  }\n  transpose(numFrames = 0) {\n    if (numFrames === 0) {\n      return 0;\n    }\n    const src = this._inputBuffer.vector;\n    const srcOffset = this._inputBuffer.startIndex;\n    const dest = this._outputBuffer.vector;\n    const destOffset = this._outputBuffer.endIndex;\n    let used = 0;\n    let i = 0;\n    while (this.slopeCount < 1.0) {\n      dest[destOffset + 2 * i] = (1.0 - this.slopeCount) * this.prevSampleL + this.slopeCount * src[srcOffset];\n      dest[destOffset + 2 * i + 1] = (1.0 - this.slopeCount) * this.prevSampleR + this.slopeCount * src[srcOffset + 1];\n      i = i + 1;\n      this.slopeCount += this._rate;\n    }\n    this.slopeCount -= 1.0;\n    if (numFrames !== 1) {\n      out: while (true) {\n        while (this.slopeCount > 1.0) {\n          this.slopeCount -= 1.0;\n          used = used + 1;\n          if (used >= numFrames - 1) {\n            break out;\n          }\n        }\n        const srcIndex = srcOffset + 2 * used;\n        dest[destOffset + 2 * i] = (1.0 - this.slopeCount) * src[srcIndex] + this.slopeCount * src[srcIndex + 2];\n        dest[destOffset + 2 * i + 1] = (1.0 - this.slopeCount) * src[srcIndex + 1] + this.slopeCount * src[srcIndex + 3];\n        i = i + 1;\n        this.slopeCount += this._rate;\n      }\n    }\n    this.prevSampleL = src[srcOffset + 2 * numFrames - 2];\n    this.prevSampleR = src[srcOffset + 2 * numFrames - 1];\n    return i;\n  }\n}\n\nclass FilterSupport {\n  constructor(pipe) {\n    this._pipe = pipe;\n  }\n  get pipe() {\n    return this._pipe;\n  }\n  get inputBuffer() {\n    return this._pipe.inputBuffer;\n  }\n  get outputBuffer() {\n    return this._pipe.outputBuffer;\n  }\n  fillInputBuffer() {\n    throw new Error('fillInputBuffer() not overridden');\n  }\n  fillOutputBuffer(numFrames = 0) {\n    while (this.outputBuffer.frameCount < numFrames) {\n      const numInputFrames = 8192 * 2 - this.inputBuffer.frameCount;\n      this.fillInputBuffer(numInputFrames);\n      if (this.inputBuffer.frameCount < 8192 * 2) {\n        break;\n      }\n      this._pipe.process();\n    }\n  }\n  clear() {\n    this._pipe.clear();\n  }\n}\n\nconst noop = function () {\n  return;\n};\n\nclass SimpleFilter extends FilterSupport {\n  constructor(sourceSound, pipe, callback = noop) {\n    super(pipe);\n    this.callback = callback;\n    this.sourceSound = sourceSound;\n    this.historyBufferSize = 22050;\n    this._sourcePosition = 0;\n    this.outputBufferPosition = 0;\n    this._position = 0;\n  }\n  get position() {\n    return this._position;\n  }\n  set position(position) {\n    if (position > this._position) {\n      throw new RangeError('New position may not be greater than current position');\n    }\n    const newOutputBufferPosition = this.outputBufferPosition - (this._position - position);\n    if (newOutputBufferPosition < 0) {\n      throw new RangeError('New position falls outside of history buffer');\n    }\n    this.outputBufferPosition = newOutputBufferPosition;\n    this._position = position;\n  }\n  get sourcePosition() {\n    return this._sourcePosition;\n  }\n  set sourcePosition(sourcePosition) {\n    this.clear();\n    this._sourcePosition = sourcePosition;\n  }\n  onEnd() {\n    this.callback();\n  }\n  fillInputBuffer(numFrames = 0) {\n    const samples = new Float32Array(numFrames * 2);\n    const numFramesExtracted = this.sourceSound.extract(samples, numFrames, this._sourcePosition);\n    this._sourcePosition += numFramesExtracted;\n    this.inputBuffer.putSamples(samples, 0, numFramesExtracted);\n  }\n  extract(target, numFrames = 0) {\n    this.fillOutputBuffer(this.outputBufferPosition + numFrames);\n    const numFramesExtracted = Math.min(numFrames, this.outputBuffer.frameCount - this.outputBufferPosition);\n    this.outputBuffer.extract(target, this.outputBufferPosition, numFramesExtracted);\n    const currentFrames = this.outputBufferPosition + numFramesExtracted;\n    this.outputBufferPosition = Math.min(this.historyBufferSize, currentFrames);\n    this.outputBuffer.receive(Math.max(currentFrames - this.historyBufferSize, 0));\n    this._position += numFramesExtracted;\n    return numFramesExtracted;\n  }\n  handleSampleData(event) {\n    this.extract(event.data, 4096);\n  }\n  clear() {\n    super.clear();\n    this.outputBufferPosition = 0;\n  }\n}\n\nconst USE_AUTO_SEQUENCE_LEN = 0;\nconst DEFAULT_SEQUENCE_MS = USE_AUTO_SEQUENCE_LEN;\nconst USE_AUTO_SEEKWINDOW_LEN = 0;\nconst DEFAULT_SEEKWINDOW_MS = USE_AUTO_SEEKWINDOW_LEN;\nconst DEFAULT_OVERLAP_MS = 8;\nconst _SCAN_OFFSETS = [[124, 186, 248, 310, 372, 434, 496, 558, 620, 682, 744, 806, 868, 930, 992, 1054, 1116, 1178, 1240, 1302, 1364, 1426, 1488, 0], [-100, -75, -50, -25, 25, 50, 75, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [-20, -15, -10, -5, 5, 10, 15, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [-4, -3, -2, -1, 1, 2, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]];\nconst AUTOSEQ_TEMPO_LOW = 0.5;\nconst AUTOSEQ_TEMPO_TOP = 2.0;\nconst AUTOSEQ_AT_MIN = 125.0;\nconst AUTOSEQ_AT_MAX = 50.0;\nconst AUTOSEQ_K = (AUTOSEQ_AT_MAX - AUTOSEQ_AT_MIN) / (AUTOSEQ_TEMPO_TOP - AUTOSEQ_TEMPO_LOW);\nconst AUTOSEQ_C = AUTOSEQ_AT_MIN - AUTOSEQ_K * AUTOSEQ_TEMPO_LOW;\nconst AUTOSEEK_AT_MIN = 25.0;\nconst AUTOSEEK_AT_MAX = 15.0;\nconst AUTOSEEK_K = (AUTOSEEK_AT_MAX - AUTOSEEK_AT_MIN) / (AUTOSEQ_TEMPO_TOP - AUTOSEQ_TEMPO_LOW);\nconst AUTOSEEK_C = AUTOSEEK_AT_MIN - AUTOSEEK_K * AUTOSEQ_TEMPO_LOW;\nclass Stretch extends AbstractFifoSamplePipe {\n  constructor(createBuffers) {\n    super(createBuffers);\n    this._quickSeek = true;\n    this.midBufferDirty = false;\n    this.midBuffer = null;\n    this.overlapLength = 0;\n    this.autoSeqSetting = true;\n    this.autoSeekSetting = true;\n    this._tempo = 1;\n    this.setParameters(44100, DEFAULT_SEQUENCE_MS, DEFAULT_SEEKWINDOW_MS, DEFAULT_OVERLAP_MS);\n  }\n  clear() {\n    super.clear();\n    this.clearMidBuffer();\n  }\n  clearMidBuffer() {\n    if (this.midBufferDirty) {\n      this.midBufferDirty = false;\n      this.midBuffer = null;\n    }\n  }\n  setParameters(sampleRate, sequenceMs, seekWindowMs, overlapMs) {\n    if (sampleRate > 0) {\n      this.sampleRate = sampleRate;\n    }\n    if (overlapMs > 0) {\n      this.overlapMs = overlapMs;\n    }\n    if (sequenceMs > 0) {\n      this.sequenceMs = sequenceMs;\n      this.autoSeqSetting = false;\n    } else {\n      this.autoSeqSetting = true;\n    }\n    if (seekWindowMs > 0) {\n      this.seekWindowMs = seekWindowMs;\n      this.autoSeekSetting = false;\n    } else {\n      this.autoSeekSetting = true;\n    }\n    this.calculateSequenceParameters();\n    this.calculateOverlapLength(this.overlapMs);\n    this.tempo = this._tempo;\n  }\n  set tempo(newTempo) {\n    let intskip;\n    this._tempo = newTempo;\n    this.calculateSequenceParameters();\n    this.nominalSkip = this._tempo * (this.seekWindowLength - this.overlapLength);\n    this.skipFract = 0;\n    intskip = Math.floor(this.nominalSkip + 0.5);\n    this.sampleReq = Math.max(intskip + this.overlapLength, this.seekWindowLength) + this.seekLength;\n  }\n  get tempo() {\n    return this._tempo;\n  }\n  get inputChunkSize() {\n    return this.sampleReq;\n  }\n  get outputChunkSize() {\n    return this.overlapLength + Math.max(0, this.seekWindowLength - 2 * this.overlapLength);\n  }\n  calculateOverlapLength(overlapInMsec = 0) {\n    let newOvl;\n    newOvl = this.sampleRate * overlapInMsec / 1000;\n    newOvl = newOvl < 16 ? 16 : newOvl;\n    newOvl -= newOvl % 8;\n    this.overlapLength = newOvl;\n    this.refMidBuffer = new Float32Array(this.overlapLength * 2);\n    this.midBuffer = new Float32Array(this.overlapLength * 2);\n  }\n  checkLimits(x, mi, ma) {\n    return x < mi ? mi : x > ma ? ma : x;\n  }\n  calculateSequenceParameters() {\n    let seq;\n    let seek;\n    if (this.autoSeqSetting) {\n      seq = AUTOSEQ_C + AUTOSEQ_K * this._tempo;\n      seq = this.checkLimits(seq, AUTOSEQ_AT_MAX, AUTOSEQ_AT_MIN);\n      this.sequenceMs = Math.floor(seq + 0.5);\n    }\n    if (this.autoSeekSetting) {\n      seek = AUTOSEEK_C + AUTOSEEK_K * this._tempo;\n      seek = this.checkLimits(seek, AUTOSEEK_AT_MAX, AUTOSEEK_AT_MIN);\n      this.seekWindowMs = Math.floor(seek + 0.5);\n    }\n    this.seekWindowLength = Math.floor(this.sampleRate * this.sequenceMs / 1000);\n    this.seekLength = Math.floor(this.sampleRate * this.seekWindowMs / 1000);\n  }\n  set quickSeek(enable) {\n    this._quickSeek = enable;\n  }\n  clone() {\n    const result = new Stretch();\n    result.tempo = this._tempo;\n    result.setParameters(this.sampleRate, this.sequenceMs, this.seekWindowMs, this.overlapMs);\n    return result;\n  }\n  seekBestOverlapPosition() {\n    return this._quickSeek ? this.seekBestOverlapPositionStereoQuick() : this.seekBestOverlapPositionStereo();\n  }\n  seekBestOverlapPositionStereo() {\n    let bestOffset;\n    let bestCorrelation;\n    let correlation;\n    let i = 0;\n    this.preCalculateCorrelationReferenceStereo();\n    bestOffset = 0;\n    bestCorrelation = Number.MIN_VALUE;\n    for (; i < this.seekLength; i = i + 1) {\n      correlation = this.calculateCrossCorrelationStereo(2 * i, this.refMidBuffer);\n      if (correlation > bestCorrelation) {\n        bestCorrelation = correlation;\n        bestOffset = i;\n      }\n    }\n    return bestOffset;\n  }\n  seekBestOverlapPositionStereoQuick() {\n    let bestOffset;\n    let bestCorrelation;\n    let correlation;\n    let scanCount = 0;\n    let correlationOffset;\n    let tempOffset;\n    this.preCalculateCorrelationReferenceStereo();\n    bestCorrelation = Number.MIN_VALUE;\n    bestOffset = 0;\n    correlationOffset = 0;\n    tempOffset = 0;\n    for (; scanCount < 4; scanCount = scanCount + 1) {\n      let j = 0;\n      while (_SCAN_OFFSETS[scanCount][j]) {\n        tempOffset = correlationOffset + _SCAN_OFFSETS[scanCount][j];\n        if (tempOffset >= this.seekLength) {\n          break;\n        }\n        correlation = this.calculateCrossCorrelationStereo(2 * tempOffset, this.refMidBuffer);\n        if (correlation > bestCorrelation) {\n          bestCorrelation = correlation;\n          bestOffset = tempOffset;\n        }\n        j = j + 1;\n      }\n      correlationOffset = bestOffset;\n    }\n    return bestOffset;\n  }\n  preCalculateCorrelationReferenceStereo() {\n    let i = 0;\n    let context;\n    let temp;\n    for (; i < this.overlapLength; i = i + 1) {\n      temp = i * (this.overlapLength - i);\n      context = i * 2;\n      this.refMidBuffer[context] = this.midBuffer[context] * temp;\n      this.refMidBuffer[context + 1] = this.midBuffer[context + 1] * temp;\n    }\n  }\n  calculateCrossCorrelationStereo(mixingPosition, compare) {\n    const mixing = this._inputBuffer.vector;\n    mixingPosition += this._inputBuffer.startIndex;\n    let correlation = 0;\n    let i = 2;\n    const calcLength = 2 * this.overlapLength;\n    let mixingOffset;\n    for (; i < calcLength; i = i + 2) {\n      mixingOffset = i + mixingPosition;\n      correlation += mixing[mixingOffset] * compare[i] + mixing[mixingOffset + 1] * compare[i + 1];\n    }\n    return correlation;\n  }\n  overlap(overlapPosition) {\n    this.overlapStereo(2 * overlapPosition);\n  }\n  overlapStereo(inputPosition) {\n    const input = this._inputBuffer.vector;\n    inputPosition += this._inputBuffer.startIndex;\n    const output = this._outputBuffer.vector;\n    const outputPosition = this._outputBuffer.endIndex;\n    let i = 0;\n    let context;\n    let tempFrame;\n    const frameScale = 1 / this.overlapLength;\n    let fi;\n    let inputOffset;\n    let outputOffset;\n    for (; i < this.overlapLength; i = i + 1) {\n      tempFrame = (this.overlapLength - i) * frameScale;\n      fi = i * frameScale;\n      context = 2 * i;\n      inputOffset = context + inputPosition;\n      outputOffset = context + outputPosition;\n      output[outputOffset + 0] = input[inputOffset + 0] * fi + this.midBuffer[context + 0] * tempFrame;\n      output[outputOffset + 1] = input[inputOffset + 1] * fi + this.midBuffer[context + 1] * tempFrame;\n    }\n  }\n  process() {\n    let offset;\n    let temp;\n    let overlapSkip;\n    if (this.midBuffer === null) {\n      if (this._inputBuffer.frameCount < this.overlapLength) {\n        return;\n      }\n      this.midBuffer = new Float32Array(this.overlapLength * 2);\n      this._inputBuffer.receiveSamples(this.midBuffer, this.overlapLength);\n    }\n    while (this._inputBuffer.frameCount >= this.sampleReq) {\n      offset = this.seekBestOverlapPosition();\n      this._outputBuffer.ensureAdditionalCapacity(this.overlapLength);\n      this.overlap(Math.floor(offset));\n      this._outputBuffer.put(this.overlapLength);\n      temp = this.seekWindowLength - 2 * this.overlapLength;\n      if (temp > 0) {\n        this._outputBuffer.putBuffer(this._inputBuffer, offset + this.overlapLength, temp);\n      }\n      const start = this._inputBuffer.startIndex + 2 * (offset + this.seekWindowLength - this.overlapLength);\n      this.midBuffer.set(this._inputBuffer.vector.subarray(start, start + 2 * this.overlapLength));\n      this.skipFract += this.nominalSkip;\n      overlapSkip = Math.floor(this.skipFract);\n      this.skipFract -= overlapSkip;\n      this._inputBuffer.receive(overlapSkip);\n    }\n  }\n}\n\nconst testFloatEqual = function (a, b) {\n  return (a > b ? a - b : b - a) > 1e-10;\n};\n\nclass SoundTouch {\n  constructor() {\n    this.transposer = new RateTransposer(false);\n    this.stretch = new Stretch(false);\n    this._inputBuffer = new FifoSampleBuffer();\n    this._intermediateBuffer = new FifoSampleBuffer();\n    this._outputBuffer = new FifoSampleBuffer();\n    this._rate = 0;\n    this._tempo = 0;\n    this.virtualPitch = 1.0;\n    this.virtualRate = 1.0;\n    this.virtualTempo = 1.0;\n    this.calculateEffectiveRateAndTempo();\n  }\n  clear() {\n    this.transposer.clear();\n    this.stretch.clear();\n  }\n  clone() {\n    const result = new SoundTouch();\n    result.rate = this.rate;\n    result.tempo = this.tempo;\n    return result;\n  }\n  get rate() {\n    return this._rate;\n  }\n  set rate(rate) {\n    this.virtualRate = rate;\n    this.calculateEffectiveRateAndTempo();\n  }\n  set rateChange(rateChange) {\n    this._rate = 1.0 + 0.01 * rateChange;\n  }\n  get tempo() {\n    return this._tempo;\n  }\n  set tempo(tempo) {\n    this.virtualTempo = tempo;\n    this.calculateEffectiveRateAndTempo();\n  }\n  set tempoChange(tempoChange) {\n    this.tempo = 1.0 + 0.01 * tempoChange;\n  }\n  set pitch(pitch) {\n    this.virtualPitch = pitch;\n    this.calculateEffectiveRateAndTempo();\n  }\n  set pitchOctaves(pitchOctaves) {\n    this.pitch = Math.exp(0.69314718056 * pitchOctaves);\n    this.calculateEffectiveRateAndTempo();\n  }\n  set pitchSemitones(pitchSemitones) {\n    this.pitchOctaves = pitchSemitones / 12.0;\n  }\n  get inputBuffer() {\n    return this._inputBuffer;\n  }\n  get outputBuffer() {\n    return this._outputBuffer;\n  }\n  calculateEffectiveRateAndTempo() {\n    const previousTempo = this._tempo;\n    const previousRate = this._rate;\n    this._tempo = this.virtualTempo / this.virtualPitch;\n    this._rate = this.virtualRate * this.virtualPitch;\n    if (testFloatEqual(this._tempo, previousTempo)) {\n      this.stretch.tempo = this._tempo;\n    }\n    if (testFloatEqual(this._rate, previousRate)) {\n      this.transposer.rate = this._rate;\n    }\n    if (this._rate > 1.0) {\n      if (this._outputBuffer != this.transposer.outputBuffer) {\n        this.stretch.inputBuffer = this._inputBuffer;\n        this.stretch.outputBuffer = this._intermediateBuffer;\n        this.transposer.inputBuffer = this._intermediateBuffer;\n        this.transposer.outputBuffer = this._outputBuffer;\n      }\n    } else {\n      if (this._outputBuffer != this.stretch.outputBuffer) {\n        this.transposer.inputBuffer = this._inputBuffer;\n        this.transposer.outputBuffer = this._intermediateBuffer;\n        this.stretch.inputBuffer = this._intermediateBuffer;\n        this.stretch.outputBuffer = this._outputBuffer;\n      }\n    }\n  }\n  process() {\n    if (this._rate > 1.0) {\n      this.stretch.process();\n      this.transposer.process();\n    } else {\n      this.transposer.process();\n      this.stretch.process();\n    }\n  }\n}\n\nclass WebAudioBufferSource {\n  constructor(buffer) {\n    this.buffer = buffer;\n    this._position = 0;\n  }\n  get dualChannel() {\n    return this.buffer.numberOfChannels > 1;\n  }\n  get position() {\n    return this._position;\n  }\n  set position(value) {\n    this._position = value;\n  }\n  extract(target, numFrames = 0, position = 0) {\n    this.position = position;\n    let left = this.buffer.getChannelData(0);\n    let right = this.dualChannel ? this.buffer.getChannelData(1) : this.buffer.getChannelData(0);\n    let i = 0;\n    for (; i < numFrames; i++) {\n      target[i * 2] = left[i + position];\n      target[i * 2 + 1] = right[i + position];\n    }\n    return Math.min(numFrames, left.length - position);\n  }\n}\n\nconst getWebAudioNode = function (context, filter, sourcePositionCallback = noop, bufferSize = 4096) {\n  const node = context.createScriptProcessor(bufferSize, 2, 2);\n  const samples = new Float32Array(bufferSize * 2);\n  node.onaudioprocess = event => {\n    let left = event.outputBuffer.getChannelData(0);\n    let right = event.outputBuffer.getChannelData(1);\n    let framesExtracted = filter.extract(samples, bufferSize);\n    sourcePositionCallback(filter.sourcePosition);\n    if (framesExtracted === 0) {\n      filter.onEnd();\n    }\n    let i = 0;\n    for (; i < framesExtracted; i++) {\n      left[i] = samples[i * 2];\n      right[i] = samples[i * 2 + 1];\n    }\n  };\n  return node;\n};\n\nconst pad = function (n, width, z) {\n  z = z || '0';\n  n = n + '';\n  return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n;\n};\nconst minsSecs = function (secs) {\n  const mins = Math.floor(secs / 60);\n  const seconds = secs - mins * 60;\n  return `${mins}:${pad(parseInt(seconds), 2)}`;\n};\n\nconst onUpdate = function (sourcePosition) {\n  const currentTimePlayed = this.timePlayed;\n  const sampleRate = this.sampleRate;\n  this.sourcePosition = sourcePosition;\n  this.timePlayed = sourcePosition / sampleRate;\n  if (currentTimePlayed !== this.timePlayed) {\n    const timePlayed = new CustomEvent('play', {\n      detail: {\n        timePlayed: this.timePlayed,\n        formattedTimePlayed: this.formattedTimePlayed,\n        percentagePlayed: this.percentagePlayed\n      }\n    });\n    this._node.dispatchEvent(timePlayed);\n  }\n};\nclass PitchShifter {\n  constructor(context, buffer, bufferSize, onEnd = noop) {\n    this._soundtouch = new SoundTouch();\n    const source = new WebAudioBufferSource(buffer);\n    this.timePlayed = 0;\n    this.sourcePosition = 0;\n    this._filter = new SimpleFilter(source, this._soundtouch, onEnd);\n    this._node = getWebAudioNode(context, this._filter, sourcePostion => onUpdate.call(this, sourcePostion), bufferSize);\n    this.tempo = 1;\n    this.rate = 1;\n    this.duration = buffer.duration;\n    this.sampleRate = context.sampleRate;\n    this.listeners = [];\n  }\n  get formattedDuration() {\n    return minsSecs(this.duration);\n  }\n  get formattedTimePlayed() {\n    return minsSecs(this.timePlayed);\n  }\n  get percentagePlayed() {\n    return 100 * this._filter.sourcePosition / (this.duration * this.sampleRate);\n  }\n  set percentagePlayed(perc) {\n    this._filter.sourcePosition = parseInt(perc * this.duration * this.sampleRate);\n    this.sourcePosition = this._filter.sourcePosition;\n    this.timePlayed = this.sourcePosition / this.sampleRate;\n  }\n  get node() {\n    return this._node;\n  }\n  set pitch(pitch) {\n    this._soundtouch.pitch = pitch;\n  }\n  set pitchSemitones(semitone) {\n    this._soundtouch.pitchSemitones = semitone;\n  }\n  set rate(rate) {\n    this._soundtouch.rate = rate;\n  }\n  set tempo(tempo) {\n    this._soundtouch.tempo = tempo;\n  }\n  connect(toNode) {\n    this._node.connect(toNode);\n  }\n  disconnect() {\n    this._node.disconnect();\n  }\n  on(eventName, cb) {\n    this.listeners.push({\n      name: eventName,\n      cb: cb\n    });\n    this._node.addEventListener(eventName, event => cb(event.detail));\n  }\n  off(eventName = null) {\n    let listeners = this.listeners;\n    if (eventName) {\n      listeners = listeners.filter(e => e.name === eventName);\n    }\n    listeners.forEach(e => {\n      this._node.removeEventListener(e.name, event => e.cb(event.detail));\n    });\n  }\n}\n\nexport { AbstractFifoSamplePipe, PitchShifter, RateTransposer, SimpleFilter, SoundTouch, Stretch, WebAudioBufferSource, getWebAudioNode };\n//# sourceMappingURL=soundtouch.js.map\n","import SoundtouchWorkletMessage from \"../../model/SoundtouchWorkletMessage\";\nimport { SoundtouchWorkletOptionsWrapper } from \"../../model/SoundtouchWorkletOptionsWrapper\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nlet soundtouchWrapperFilterWorkletNodeClass: any;\n\nif(typeof(window) !== \"undefined\" && typeof(window.AudioWorkletNode) !== \"undefined\") {\n    soundtouchWrapperFilterWorkletNodeClass = class SoundtouchWrapperFilterWorkletNode extends AudioWorkletNode {\n\n        name: string = \"\";\n        private running = false;\n        private _tempo = 1;\n        private _pitch = 1;\n\n        constructor(context: BaseAudioContext, workletName: string, options: SoundtouchWorkletOptionsWrapper) {\n            super(context, workletName, options);\n            this.name = this.constructor.name;\n            this.running = true;\n            this.updateInterval = options.processorOptions.updateInterval;\n        }\n\n        async setup(tempo: number, pitch: number): Promise<void> {\n            return new Promise(resolve => {\n                if(this.port) {\n                    this.port.onmessage = (ev: MessageEvent<SoundtouchWorkletMessage>) => {\n                        if(ev && ev.data && ev.data.status === \"OK\" && ev.data.args[0] === \"setup\") {\n                            this.port.onmessage = this.messageProcessor.bind(this);\n                            resolve();\n                        }\n                    };\n    \n                    this.port.postMessage({ command: \"setup\", args: [tempo, pitch] });\n\n                    this._tempo = tempo;\n                    this._pitch = pitch;\n                }\n            });\n        }\n\n        set updateInterval(value: number) {\n            this.port.postMessage({ command: \"updateInterval\", args: [value] });\n        }\n\n        get node() {\n            return this;\n        }\n\n        set tempo(value: number) {\n            this.port.postMessage({ command: \"setTempo\", args: [value] });\n        }\n\n        set pitch(value: number) {\n            this.port.postMessage({ command: \"setPitch\", args: [value] });\n        }\n\n        get tempo(): number {\n            this.port.postMessage({ command: \"getTempo\", args: [] });\n            return this._tempo;\n        }\n\n        get pitch(): number {\n            this.port.postMessage({ command: \"getPitch\", args: [] });\n            return this._pitch;\n        }\n\n        async stop() {\n            if (!this.running) return;\n\n            this.port.postMessage({ command: \"stop\", args: [] });\n            this.disconnect();\n\n            this.running = false;\n        }\n\n        messageProcessor(e: MessageEvent<SoundtouchWorkletMessage>) {\n            if (e.data.command) {\n                const { command } = e.data;\n                \n                switch (command) {\n                case \"End\":\n                    this.stop();\n                    break;\n                default:\n                    break;\n                }\n\n                if (e.data.status) {\n                    const value = e.data.args[1];\n\n                    switch (e.data.args[0]) {\n                    case \"getTempo\":\n                        this._tempo = value as number;\n                        break;\n                    case \"getPitch\":\n                        this._pitch = value as number;\n                        break;\n                    default:\n                        break;\n                    }\n                    return;\n                }\n            }\n        }\n    };\n}\n\nexport default soundtouchWrapperFilterWorkletNodeClass;\n","// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n//@ts-ignore\nimport { PitchShifter } from \"soundtouchjs\";\nimport Constants from \"../model/Constants\";\nimport AbstractAudioFilterWorklet from \"./interfaces/AbstractAudioFilterWorklet\";\nimport AudioFilterEntrypointInterface from \"./interfaces/AudioFilterEntrypointInterface\";\nimport { AudioFilterNodes } from \"../model/AudioNodes\";\nimport utils from \"../utils/Functions\";\nimport SoundtouchWrapperFilterWorkletNode from \"./worklets/SoundtouchWrapperFilterWorkletNode\";\nimport SimpleAudioWorkletProcessor from \"../workletPolyfill/SimpleAudioWorkletProcessor\";\nimport SoundtouchSettings from \"../model/filtersSettings/SoundtouchSettings\";\nimport { FilterSettingValue } from \"../model/filtersSettings/FilterSettings\";\nimport utilFunctions from \"../utils/Functions\";\n\nexport default class SoundtouchWrapperFilter extends AbstractAudioFilterWorklet<void> implements AudioFilterEntrypointInterface {\n\n    private speedAudio = 1;\n    private frequencyAudio = 1;\n    private currentSpeedAudio = 1;\n    private currentPitchShifterWorklet: typeof SoundtouchWrapperFilterWorkletNode;\n    private currentPitchShifter: PitchShifter;\n    private isOfflineMode = false;\n\n    constructor() {\n        super();\n        this.enable();\n        this.setDefaultEnabled(true);\n    }\n\n    async initializeWorklet(): Promise<void> {\n        // Do nothing\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    receiveEvent(message: MessageEvent<void>): void {\n        // Do nothing\n    }\n\n    get workletPath(): string {\n        return Constants.WORKLET_PATHS.SOUNDTOUCH;\n    }\n\n    constructAudioWorkletProcessor(): SimpleAudioWorkletProcessor {\n        throw new Error(\"Method not implemented.\");\n    }\n\n    get workletName(): string {\n        return Constants.WORKLET_NAMES.SOUNDTOUCH;\n    }\n\n    async getEntrypointNode(context: BaseAudioContext, buffer: AudioBuffer, offline: boolean): Promise<AudioFilterNodes> {\n        this.isOfflineMode = offline;\n\n        this.cleanUpOldNodes();\n\n        // In offline (compatibility) mode\n        if (offline) {\n            // If the settings are untouched, we don't use Soundtouch\n            if (!this.isEnabled() || (this.speedAudio == 1 && this.frequencyAudio == 1)) {\n                // Just return an audio buffer source node\n                const bufferSource = context.createBufferSource();\n                bufferSource.buffer = buffer;\n                bufferSource.start();\n\n                return {\n                    input: bufferSource,\n                    output: bufferSource\n                };\n            } else {\n                // If audio worklet is enabled for soundtouch, and if the speed of audio is untouched\n                // Soundtouch Audio Worklet don't support speed editing yet\n                if (this.isAudioWorkletEnabled() && utils.isAudioWorkletCompatible(context) && this.speedAudio == 1) {\n                    return this.renderWithWorklet(buffer, context);\n                } else {\n                    return this.renderWithScriptProcessorNode(buffer, context);\n                }\n            }\n        }\n\n        // Not in offline mode: get classic soundtouch script processor node\n        this.currentPitchShifter = this.getSoundtouchScriptProcessorNode(buffer, context);\n        this.updateState();\n\n        return {\n            input: this.currentPitchShifter,\n            output: this.currentPitchShifter\n        };\n    }\n\n    /** Cleanup old nodes (worklets, pitch shifter) */\n    private cleanUpOldNodes() {\n        // Stop current worklet\n        if (this.currentPitchShifterWorklet) {\n            this.currentPitchShifterWorklet.stop();\n            this.currentPitchShifterWorklet.disconnect();\n        }\n\n        if (this.currentPitchShifter) {\n            this.currentPitchShifter.disconnect();\n            this.currentPitchShifter._filter = null;\n        }\n    }\n\n    private getSoundtouchScriptProcessorNode(buffer: AudioBuffer, context: BaseAudioContext): AudioNode {\n        return new PitchShifter(context, buffer, Constants.SOUNDTOUCH_PITCH_SHIFTER_BUFFER_SIZE);\n    }\n\n    /**\n     * Use script processor node (deprecated) to render the audio buffer with Soundtouch, according to the current settings.\n     * Not working on Firefox\n     * @param buffer Audio buffer\n     * @param context Audio context\n     * @returns A promise resolving to audio nodes with the rendered audio as a buffer source\n     */\n    private async renderWithScriptProcessorNode(buffer: AudioBuffer, context: BaseAudioContext): Promise<AudioFilterNodes> {\n        const durationAudio = utils.calcAudioDuration(buffer, this.speedAudio);\n        const offlineContext = new OfflineAudioContext(2, context.sampleRate * durationAudio, context.sampleRate);\n\n        this.currentPitchShifter = this.getSoundtouchScriptProcessorNode(buffer, offlineContext);\n        this.updateState();\n\n        this.currentPitchShifter.connect(offlineContext.destination);\n\n        const renderedBuffer = await offlineContext.startRendering();\n\n        const bufferSourceRendered = context.createBufferSource();\n        bufferSourceRendered.buffer = renderedBuffer;\n        bufferSourceRendered.start();\n\n        this.cleanUpOldNodes();\n\n        return {\n            input: bufferSourceRendered,\n            output: bufferSourceRendered\n        };\n    }\n\n    /**\n     * EXPERIMENTAL - Use audio worklet to render the audio buffer with Soundtouch, according to the current settings.\n     * Working in Firefox and Chrome\n     * @param buffer Audio buffer\n     * @param context Audio context\n     * @returns A promise resolving to audio nodes with the rendered audio as a buffer source\n     */\n    private async renderWithWorklet(buffer: AudioBuffer, context: BaseAudioContext): Promise<AudioFilterNodes> {\n        const durationAudio = utils.calcAudioDuration(buffer, this.speedAudio);\n\n        try {\n            // Setup worklet JS module\n            await context.audioWorklet.addModule((this.configService ? this.configService.getWorkletBasePath() : \"\") + Constants.WORKLET_PATHS.SOUNDTOUCH);\n\n            // Setup an audio buffer source from the audio buffer\n            const bufferSource = context.createBufferSource();\n            bufferSource.buffer = buffer;\n            bufferSource.start();\n\n            // Create the worklet node\n            this.currentPitchShifterWorklet = new SoundtouchWrapperFilterWorkletNode(context, \"soundtouch-worklet\", {\n                processorOptions: {\n                    bypass: false,\n                    recording: false,\n                    nInputFrames: this.approximateNInputFrames(durationAudio, context),\n                    updateInterval: 10.0,\n                    sampleRate: buffer.sampleRate\n                },\n            });\n\n            // Connect the node for correct rendering\n            bufferSource.connect(this.currentPitchShifterWorklet.node);\n\n            // Setup pitch/speed of Soundtouch\n            if (this.isEnabled()) {\n                await this.currentPitchShifterWorklet.setup(this.speedAudio, this.frequencyAudio);\n            } else {\n                await this.currentPitchShifterWorklet.setup(1, 1);\n            }\n\n            return {\n                input: this.currentPitchShifterWorklet,\n                output: this.currentPitchShifterWorklet\n            };\n        } catch (e) {\n            // Fallback to script processor node\n            console.error(e);\n            return this.renderWithScriptProcessorNode(buffer, context);\n        }\n    }\n\n    private approximateNInputFrames(durationAudio: number, context: BaseAudioContext) {\n        // {frequencyAudio, multiplicator}: {{0.1, 10}, {0.2, 5}, {0.3, 3.33}, {0.4, 2.5}, {0.5, 2}, {0.6, 1.67}, {0.7, 1.43}, {0.8, 1.25}, {0.9, 1.11}, {1, 1}}\n        return durationAudio * context.sampleRate * (Math.round(14 * Math.exp(-4 * this.frequencyAudio)) + 1);\n    }\n\n    get order(): number {\n        return 2;\n    }\n\n    get id(): string {\n        return Constants.FILTERS_NAMES.SOUNDTOUCH;\n    }\n\n    getSettings(): SoundtouchSettings {\n        return {\n            speedAudio: this.speedAudio,\n            frequencyAudio: this.frequencyAudio\n        };\n    }\n\n    protected isAudioWorkletEnabled() {\n        if (this.configService) {\n            return this.configService.isSoundtouchAudioWorkletEnabled();\n        }\n\n        return Constants.ENABLE_SOUNDTOUCH_AUDIO_WORKLET;\n    }\n\n    private getCurrentPitchShifter() {\n        if (this.isOfflineMode) {\n            // If the settings are untouched, we don't use Soundtouch\n            if (this.speedAudio == 1 && this.frequencyAudio == 1) {\n                return null;\n            } else {\n                if (this.isAudioWorkletEnabled() && this.currentPitchShifterWorklet && this.speedAudio == 1) {\n                    return this.currentPitchShifterWorklet;\n                } else {\n                    return this.currentPitchShifter;\n                }\n            }\n        }\n\n        return this.currentPitchShifter;\n    }\n\n    updateState(): void {\n        const pitchShifter = this.getCurrentPitchShifter();\n\n        if (!this.isEnabled()) {\n            if (pitchShifter) {\n                pitchShifter.pitch = 1;\n                pitchShifter.tempo = 1;\n            }\n\n            this.currentSpeedAudio = 1;\n        } else {\n            if (pitchShifter) {\n                pitchShifter.pitch = this.frequencyAudio;\n                pitchShifter.tempo = this.speedAudio;\n            }\n\n            this.currentSpeedAudio = this.speedAudio;\n        }\n    }\n\n    async setSetting(settingId: string, value: FilterSettingValue) {\n        if (!utilFunctions.isSettingValueValid(value)) {\n            return;\n        }\n\n        const valueFloat = parseFloat(value as string);\n\n        switch (settingId) {\n        case \"speedAudio\":\n            this.speedAudio = valueFloat;\n            break;\n        case \"frequencyAudio\":\n            this.frequencyAudio = valueFloat;\n            break;\n        default:\n            break;\n        }\n\n        this.updateState();\n    }\n\n    setEnabled(state: boolean): void {\n        super.setEnabled(state);\n        this.updateState();\n    }\n\n    getSpeed(): number {\n        return this.currentSpeedAudio;\n    }\n}\n","import AbstractAudioFilter from \"./interfaces/AbstractAudioFilter\";\nimport Constants from \"../model/Constants\";\nimport { FilterSettingValue } from \"../model/filtersSettings/FilterSettings\";\n\nexport default class BitCrusherFilter extends AbstractAudioFilter {\n\n    getNode(context: BaseAudioContext) {\n        const lpf1 = context.createBiquadFilter();\n        lpf1.type = \"lowpass\";\n        lpf1.frequency.value = 2000.0;\n        const lpf2 = context.createBiquadFilter();\n        lpf2.type = \"lowpass\";\n        lpf2.frequency.value = 2000.0;\n        const hpf1 = context.createBiquadFilter();\n        hpf1.type = \"highpass\";\n        hpf1.frequency.value = 500.0;\n        const hpf2 = context.createBiquadFilter();\n        hpf2.type = \"highpass\";\n        hpf2.frequency.value = 500.0;\n        lpf1.connect(lpf2);\n        lpf2.connect(hpf1);\n        hpf1.connect(hpf2);\n    \n        return {\n            input: lpf1,\n            output: hpf2\n        };\n    }\n    \n    get order(): number {\n        return 7;\n    }\n\n    get id(): string {\n        return Constants.FILTERS_NAMES.TELEPHONIZER;\n    }\n\n    getSettings() {\n        return {};\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async setSetting(settingId: string, value: FilterSettingValue) { }\n}\n","/*\n * Copyright (c) 2012 The Chromium Authors. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *    * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *    * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *    * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n/*\n * Copyright (C) 2023 Eliastik (eliastiksofts.com)\n *\n * This file is part of \"Simple Voice Changer\".\n *\n * \"Simple Voice Changer\" is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * \"Simple Voice Changer\" is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with \"Simple Voice Changer\".  If not, see <http://www.gnu.org/licenses/>.\n */\ninterface VocoderBand {\n    frequency: number;\n}\n\nexport default class Vocoder {\n\n    private FILTER_QUALITY = 6;  // The Q value for the carrier and modulator filters\n    private FOURIER_SIZE = 4096;\n    private WAVETABLEBOOST = 40.0;\n    private SAWTOOTHBOOST = 0.40;\n    private oscillatorType = 4;   // CUSTOM\n    private oscillatorDetuneValue = 0;\n\n    private audioContext: BaseAudioContext | null = null;\n    private modulatorBuffer: AudioBuffer | undefined;\n    private carrierBuffer: AudioBuffer | null = null;\n    private modulatorNode: AudioBufferSourceNode | null = null;\n    private vocoding = false;\n\n    // These are \"placeholder\" gain nodes - because the modulator and carrier will get swapped in\n    // as they are loaded, it's easier to connect these nodes to all the bands, and the \"real\"\n    // modulator & carrier AudioBufferSourceNodes connect to these.\n    private modulatorInput: GainNode | null = null;\n    private carrierInput: GainNode | null = null;\n\n    private modulatorGain: GainNode | null = null;\n    private modulatorGainValue = 1.0;\n\n    // noise node added to the carrier signal\n    private noiseBuffer: AudioBuffer | null = null;\n    private noiseNode: AudioBufferSourceNode | null = null;\n    private noiseGain: GainNode | null = null;\n    private noiseGainValue = 0.2;\n\n    // Carrier sample gain\n    private carrierSampleNode: AudioBufferSourceNode | null = null;\n    private carrierSampleGain: GainNode | null = null;\n    private carrierSampleGainValue = 0.0;\n\n    // Carrier Synth oscillator stuff\n    private oscillatorNode: OscillatorNode | null = null;\n    private oscillatorGain: GainNode | null = null;\n    private oscillatorGainValue = 1.0;\n    private wavetable: PeriodicWave | null = null;\n    private wavetableSignalGain: GainNode | null = null;\n\n    // These are the arrays of nodes - the \"columns\" across the frequency band \"rows\"\n    private modFilterBands: BiquadFilterNode[] | null = null;    // tuned bandpass filters\n    private modFilterPostGains: GainNode[] | null = null;  // post-filter gains.\n    private heterodynes: GainNode[] | null = null;   // gain nodes used to multiply bandpass X sine\n    private powers: number[] | null = null;      // gain nodes used to multiply prev out by itself\n    private lpFilters: BiquadFilterNode[] | null = null;   // tuned LP filters to remove doubled copy of product\n    private lpFilterPostGains: GainNode[] | null = null;   // gain nodes for tuning input to waveshapers\n    private carrierBands: BiquadFilterNode[] | null = null;  // tuned bandpass filters, same as modFilterBands but in carrier chain\n    private carrierFilterPostGains: GainNode[] | null = null;  // post-bandpass gain adjustment\n    private carrierBandGains: GainNode[] | null = null;  // these are the \"control gains\" driven by the lpFilters\n\n    private vocoderBands: VocoderBand[] | null = null;\n    private numVocoderBands: number = 0;\n\n    private hpFilterGain: GainNode | null = null;\n    private outputGain: GainNode | null = null;\n\n    // Initialization function for the page.\n    constructor(ctx: BaseAudioContext, carrierB: AudioBuffer, modulatorB?: AudioBuffer) {\n        this.audioContext = ctx;\n        this.carrierBuffer = carrierB;\n        this.modulatorBuffer = modulatorB;\n    }\n\n    init() {\n        this.generateVocoderBands(55, 7040, 28);\n        // Set up the vocoder chains\n        this.setupVocoderGraph();\n        this.vocode();\n    }\n\n    getNodes() {\n        return {\n            modulatorNode: this.modulatorNode,\n            modulatorGain: this.modulatorGain,\n            synthLevel: this.oscillatorGain,\n            noiseNode: this.noiseGain,\n            oscillatorNode: this.oscillatorNode,\n            hpFilterGain: this.hpFilterGain,\n            outputGain: this.outputGain\n        };\n    }\n\n    private shutOffCarrier() {\n        if (this.oscillatorNode && this.noiseNode && this.carrierSampleNode) {\n            this.oscillatorNode.stop(0);\n            this.oscillatorNode = null;\n            this.noiseNode.stop(0);\n            this.noiseNode = null;\n            this.carrierSampleNode.stop(0);\n            this.carrierSampleNode = null;\n        }\n    }\n\n    selectSawtooth() {\n        if (this.wavetableSignalGain)\n            this.wavetableSignalGain.gain.value = this.SAWTOOTHBOOST;\n        if (this.oscillatorNode)\n            this.oscillatorNode.type = \"sawtooth\";\n    }\n\n    selectWavetable() {\n        if (this.wavetableSignalGain)\n            this.wavetableSignalGain.gain.value = this.WAVETABLEBOOST;\n        if (this.oscillatorNode && this.wavetable)\n            this.oscillatorNode.setPeriodicWave(this.wavetable);\n        if (this.wavetableSignalGain)\n            this.wavetableSignalGain.gain.value = this.WAVETABLEBOOST;\n    }\n\n    updateModGain(value: number) {\n        this.modulatorGainValue = value;\n        if (this.modulatorGain)\n            this.modulatorGain.gain.value = value;\n    }\n\n    // sample-based carrier\n    updateSampleLevel(value: number) {\n        this.carrierSampleGainValue = value;\n        if (this.carrierSampleGain)\n            this.carrierSampleGain.gain.value = value;\n    }\n\n    // noise in carrier\n    updateSynthLevel(value: number) {\n        this.oscillatorGainValue = value;\n        if (this.oscillatorGain)\n            this.oscillatorGain.gain.value = value;\n    }\n\n    // noise in carrier\n    updateNoiseLevel(value: number) {\n        this.noiseGainValue = value;\n        if (this.noiseGain)\n            this.noiseGain.gain.value = value;\n    }\n\n    updateDetuneValue(value: number) {\n        this.oscillatorDetuneValue = value;\n        if (this.oscillatorNode)\n            this.oscillatorNode.detune.value = value;\n    }\n\n    // this will algorithmically re-calculate vocoder bands, distributing evenly\n    // from startFreq to endFreq, splitting evenly (logarhythmically) into a given numBands.\n    // The function places this info into the global vocoderBands and numVocoderBands letiables.\n    private generateVocoderBands(startFreq: number, endFreq: number, numBands: number) {\n        // Remember: 1200 cents in octave, 100 cents per semitone\n\n        const totalRangeInCents = 1200 * Math.log(endFreq / startFreq) / Math.LN2;\n        const centsPerBand = totalRangeInCents / numBands;\n        const scale = Math.pow(2, centsPerBand / 1200);  // This is the scaling for successive bands\n\n        this.vocoderBands = [];\n        let currentFreq = startFreq;\n\n        for (let i = 0; i < numBands; i++) {\n            this.vocoderBands[i] = { frequency: currentFreq };\n            //console.log( \"Band \" + i + \" centered at \" + currentFreq + \"Hz\" );\n            currentFreq = currentFreq * scale;\n        }\n\n        this.numVocoderBands = numBands;\n    }\n\n    private loadNoiseBuffer() {  // create a 5-second buffer of noise\n        if (!this.audioContext) return;\n\n        const lengthInSamples = 5 * this.audioContext.sampleRate;\n        this.noiseBuffer = this.audioContext.createBuffer(1, lengthInSamples, this.audioContext.sampleRate);\n        const bufferData = this.noiseBuffer.getChannelData(0);\n\n        for (let i = 0; i < lengthInSamples; ++i) {\n            bufferData[i] = (2 * Math.random() - 1);  // -1 to +1\n        }\n    }\n\n    private initBandpassFilters() {\n        if (!this.audioContext) return;\n\n        // When this function is called, the carrierNode and modulatorAnalyser\n        // may not already be created.  Create placeholder nodes for them.\n        this.modulatorInput = this.audioContext.createGain();\n        this.carrierInput = this.audioContext.createGain();\n\n        if (this.modFilterBands == null)\n            this.modFilterBands = [];\n\n        if (this.modFilterPostGains == null)\n            this.modFilterPostGains = [];\n\n        if (this.heterodynes == null)\n            this.heterodynes = [];\n\n        if (this.powers == null)\n            this.powers = [];\n\n        if (this.lpFilters == null)\n            this.lpFilters = [];\n\n        if (this.lpFilterPostGains == null)\n            this.lpFilterPostGains = [];\n\n        if (this.carrierBands == null)\n            this.carrierBands = [];\n\n        if (this.carrierFilterPostGains == null)\n            this.carrierFilterPostGains = [];\n\n        if (this.carrierBandGains == null)\n            this.carrierBandGains = [];\n\n        const waveShaperCurve = new Float32Array(65536);\n        // Populate with a \"curve\" that does an abs()\n        const n = 65536;\n        const n2 = n / 2;\n        let x;\n\n        for (let i = 0; i < n2; ++i) {\n            x = i / n2;\n\n            waveShaperCurve[n2 + i] = x;\n            waveShaperCurve[n2 - i - 1] = x;\n        }\n\n        // Set up a high-pass filter to add back in the fricatives, etc.\n        // (this isn't used by default in the \"production\" version, as I hid the slider)\n        const hpFilter = this.audioContext.createBiquadFilter();\n        hpFilter.type = \"highpass\";\n        hpFilter.frequency.value = 8000; // or use vocoderBands[numVocoderBands-1].frequency;\n        hpFilter.Q.value = 1; //  no peaking\n        this.modulatorInput.connect(hpFilter);\n\n        this.hpFilterGain = this.audioContext.createGain();\n        this.hpFilterGain.gain.value = 0.0;\n\n        hpFilter.connect(this.hpFilterGain);\n\n        if(this.modulatorBuffer) {\n            this.hpFilterGain.connect(this.audioContext.destination);\n        }\n\n        //clear the arrays\n        this.modFilterBands.length = 0;\n        this.modFilterPostGains.length = 0;\n        this.heterodynes.length = 0;\n        this.powers.length = 0;\n        this.lpFilters.length = 0;\n        this.lpFilterPostGains.length = 0;\n        this.carrierBands.length = 0;\n        this.carrierFilterPostGains.length = 0;\n        this.carrierBandGains.length = 0;\n\n        this.outputGain = this.audioContext.createGain();\n\n        if(this.modulatorBuffer) {\n            this.outputGain.connect(this.audioContext.destination);\n        }\n\n        const rectifierCurve = new Float32Array(65536);\n        for (let i = -32768; i < 32768; i++)\n            rectifierCurve[i + 32768] = ((i > 0) ? i : -i) / 32768;\n\n        for (let i = 0; i < this.numVocoderBands; i++) {\n            // CREATE THE MODULATOR CHAIN\n            // create the bandpass filter in the modulator chain\n            const modulatorFilter = this.audioContext.createBiquadFilter();\n            modulatorFilter.type = \"bandpass\";  // Bandpass filter\n            if (this.vocoderBands)\n                modulatorFilter.frequency.value = this.vocoderBands[i].frequency;\n            modulatorFilter.Q.value = this.FILTER_QUALITY; //  initial quality\n            this.modulatorInput.connect(modulatorFilter);\n            this.modFilterBands.push(modulatorFilter);\n\n            // Now, create a second bandpass filter tuned to the same frequency -\n            // this turns our second-order filter into a 4th-order filter,\n            // which has a steeper rolloff/octave\n            const secondModulatorFilter = this.audioContext.createBiquadFilter();\n            secondModulatorFilter.type = \"bandpass\";  // Bandpass filter\n            if (this.vocoderBands)\n                secondModulatorFilter.frequency.value = this.vocoderBands[i].frequency;\n            secondModulatorFilter.Q.value = this.FILTER_QUALITY; //  initial quality\n            //modulatorFilter.chainedFilter = secondModulatorFilter;\n            modulatorFilter.connect(secondModulatorFilter);\n\n            // create a post-filtering gain to bump the levels up.\n            const modulatorFilterPostGain = this.audioContext.createGain();\n            modulatorFilterPostGain.gain.value = 6;\n            secondModulatorFilter.connect(modulatorFilterPostGain);\n            this.modFilterPostGains.push(modulatorFilterPostGain);\n\n            // Create the sine oscillator for the heterodyne\n            const heterodyneOscillator = this.audioContext.createOscillator();\n            if (this.vocoderBands)\n                heterodyneOscillator.frequency.value = this.vocoderBands[i].frequency;\n\n            heterodyneOscillator.start(0);\n\n            // Create the node to multiply the sine by the modulator\n            const heterodyne = this.audioContext.createGain();\n            modulatorFilterPostGain.connect(heterodyne);\n            heterodyne.gain.value = 0.0;  // audio-rate inputs are summed with initial intrinsic value\n            heterodyneOscillator.connect(heterodyne.gain);\n\n            const heterodynePostGain = this.audioContext.createGain();\n            heterodynePostGain.gain.value = 2.0;    // GUESS:  boost\n            heterodyne.connect(heterodynePostGain);\n            this.heterodynes.push(heterodynePostGain);\n\n\n            // Create the rectifier node\n            const rectifier = this.audioContext.createWaveShaper();\n            rectifier.curve = rectifierCurve;\n            heterodynePostGain.connect(rectifier);\n\n            // Create the lowpass filter to mask off the difference (near zero)\n            const lpFilter = this.audioContext.createBiquadFilter();\n            lpFilter.type = \"lowpass\";  // Lowpass filter\n            lpFilter.frequency.value = 5.0; // Guesstimate!  Mask off 20Hz and above.\n            lpFilter.Q.value = 1; // don't need a peak\n            this.lpFilters.push(lpFilter);\n            rectifier.connect(lpFilter);\n\n            const lpFilterPostGain = this.audioContext.createGain();\n            lpFilterPostGain.gain.value = 1.0;\n            lpFilter.connect(lpFilterPostGain);\n            this.lpFilterPostGains.push(lpFilterPostGain);\n\n            const waveshaper = this.audioContext.createWaveShaper();\n            waveshaper.curve = waveShaperCurve;\n            lpFilterPostGain.connect(waveshaper);\n\n\n            // Create the bandpass filter in the carrier chain\n            const carrierFilter = this.audioContext.createBiquadFilter();\n            carrierFilter.type = \"bandpass\";\n            if (this.vocoderBands)\n                carrierFilter.frequency.value = this.vocoderBands[i].frequency;\n            carrierFilter.Q.value = this.FILTER_QUALITY;\n            this.carrierBands.push(carrierFilter);\n            this.carrierInput.connect(carrierFilter);\n\n            // We want our carrier filters to be 4th-order filter too.\n            const secondCarrierFilter = this.audioContext.createBiquadFilter();\n            secondCarrierFilter.type = \"bandpass\";  // Bandpass filter\n            if (this.vocoderBands)\n                secondCarrierFilter.frequency.value = this.vocoderBands[i].frequency;\n            secondCarrierFilter.Q.value = this.FILTER_QUALITY; //  initial quality\n            //carrierFilter.chainedFilter = secondCarrierFilter;\n            carrierFilter.connect(secondCarrierFilter);\n\n            const carrierFilterPostGain = this.audioContext.createGain();\n            carrierFilterPostGain.gain.value = 10.0;\n            secondCarrierFilter.connect(carrierFilterPostGain);\n            this.carrierFilterPostGains.push(carrierFilterPostGain);\n\n            // Create the carrier band gain node\n            const bandGain = this.audioContext.createGain();\n            this.carrierBandGains.push(bandGain);\n            carrierFilterPostGain.connect(bandGain);\n            bandGain.gain.value = 0.0;  // audio-rate inputs are summed with initial intrinsic value\n            waveshaper.connect(bandGain.gain);  // connect the lp controller\n\n            bandGain.connect(this.outputGain);\n        }\n\n\n        // Now set up our wavetable stuff.\n        const real = new Float32Array(this.FOURIER_SIZE);\n        const imag = new Float32Array(this.FOURIER_SIZE);\n        real[0] = 0.0;\n        imag[0] = 0.0;\n        for (let i = 1; i < this.FOURIER_SIZE; i++) {\n            real[i] = 1.0;\n            imag[i] = 1.0;\n        }\n\n        this.wavetable = this.audioContext.createPeriodicWave(real, imag);\n        this.loadNoiseBuffer();\n    }\n\n    private setupVocoderGraph() {\n        this.initBandpassFilters();\n    }\n\n    private createCarriersAndPlay(output: GainNode | null) {\n        if(!this.audioContext || !output) return;\n\n        this.carrierSampleNode = this.audioContext.createBufferSource();\n        this.carrierSampleNode.buffer = this.carrierBuffer;\n        this.carrierSampleNode.loop = true;\n\n        this.carrierSampleGain = this.audioContext.createGain();\n        this.carrierSampleGain.gain.value = this.carrierSampleGainValue;\n        this.carrierSampleNode.connect(this.carrierSampleGain);\n        this.carrierSampleGain.connect(output);\n\n        // The wavetable signal needs a boost.\n        this.wavetableSignalGain = this.audioContext.createGain();\n\n        this.oscillatorNode = this.audioContext.createOscillator();\n        if (this.oscillatorType == 4 && this.wavetable) { // wavetable\n            this.oscillatorNode.setPeriodicWave(this.wavetable);\n            this.wavetableSignalGain.gain.value = this.WAVETABLEBOOST;\n        } else {\n            //oscillatorNode.type = oscillatorType;\n            this.wavetableSignalGain.gain.value = this.SAWTOOTHBOOST;\n        }\n        this.oscillatorNode.frequency.value = 110;\n        this.oscillatorNode.detune.value = this.oscillatorDetuneValue;\n        this.oscillatorNode.connect(this.wavetableSignalGain);\n\n        this.oscillatorGain = this.audioContext.createGain();\n        this.oscillatorGain.gain.value = this.oscillatorGainValue;\n\n        this.wavetableSignalGain.connect(this.oscillatorGain);\n        this.oscillatorGain.connect(output);\n\n        this.noiseNode = this.audioContext.createBufferSource();\n        this.noiseNode.buffer = this.noiseBuffer;\n        this.noiseNode.loop = true;\n        this.noiseGain = this.audioContext.createGain();\n        this.noiseGain.gain.value = this.noiseGainValue;\n        this.noiseNode.connect(this.noiseGain);\n\n        this.noiseGain.connect(output);\n        this.oscillatorNode.start(0);\n        this.noiseNode.start(0);\n        this.carrierSampleNode.start(0);\n\n    }\n\n    private vocode() {\n        if(!this.audioContext) return;\n\n        if (this.vocoding) {\n            if (this.modulatorNode) {\n                this.modulatorNode.stop(0);\n            }\n            this.shutOffCarrier();\n            this.vocoding = false;\n            return;\n        }\n\n        this.createCarriersAndPlay(this.carrierInput);\n\n        this.vocoding = true;\n\n        this.modulatorGain = this.audioContext.createGain();\n        this.modulatorGain.gain.value = this.modulatorGainValue;\n\n        if(this.modulatorBuffer) {\n            this.modulatorNode = this.audioContext.createBufferSource();\n            this.modulatorNode.buffer = this.modulatorBuffer;\n            this.modulatorNode.connect(this.modulatorGain);\n            this.modulatorNode.start(0);\n        }\n\n        if (this.modulatorInput)\n            this.modulatorGain.connect(this.modulatorInput);\n    }\n}\n","import AbstractAudioFilter from \"./interfaces/AbstractAudioFilter\";\nimport { AudioFilterNodes } from \"../model/AudioNodes\";\nimport Constants from \"../model/Constants\";\nimport Vocoder from \"../utils/Vocoder\";\nimport VocoderSettings from \"../model/filtersSettings/VocoderSettings\";\nimport utilFunctions from \"../utils/Functions\";\nimport { FilterSettingValue } from \"../model/filtersSettings/FilterSettings\";\n\nexport default class VocoderFilter extends AbstractAudioFilter {\n\n    private currentVocoder: Vocoder | null = null;\n    private modulatorGainValue = 1.0;\n    private carrierSampleGainValue = 0;\n    private oscillatorGainValue = 1.0;\n    private noiseGainValue = 0.2;\n    private oscillatorDetuneValue = 0;\n\n    getNode(context: BaseAudioContext): AudioFilterNodes {\n        const modulatorBuffer = this.bufferFetcherService?.getAudioBuffer(Constants.VOCODER_MODULATOR);\n\n        this.currentVocoder = new Vocoder(context, modulatorBuffer!);\n        this.currentVocoder.init();\n        this.applyCurrentSettingsToVocoder();\n\n        const { modulatorGain, outputGain } = this.currentVocoder.getNodes();\n\n        return {\n            input: modulatorGain!,\n            output: outputGain!\n        };\n    }\n\n    getSettings(): VocoderSettings {\n        return {\n            modulatorGainValue: this.modulatorGainValue,\n            carrierSampleGainValue: this.carrierSampleGainValue,\n            oscillatorGainValue: this.oscillatorGainValue,\n            noiseGainValue: this.noiseGainValue,\n            oscillatorDetuneValue: this.oscillatorDetuneValue\n        };\n    }\n\n    async setSetting(settingId: string, value: FilterSettingValue) {\n        if(!utilFunctions.isSettingValueValid(value)) {\n            return;\n        }\n        \n        switch (settingId) {\n        case \"modulatorGainValue\":\n            this.modulatorGainValue = parseFloat(value as string);\n            break;\n        case \"carrierSampleGainValue\":\n            this.carrierSampleGainValue = parseFloat(value as string);\n            break;\n        case \"oscillatorGainValue\":\n            this.oscillatorGainValue = parseFloat(value as string);\n            break;\n        case \"noiseGainValue\":\n            this.noiseGainValue = parseFloat(value as string);\n            break;\n        case \"oscillatorDetuneValue\":\n            this.oscillatorDetuneValue = parseFloat(value as string);\n            break;\n        }\n\n        this.applyCurrentSettingsToVocoder();\n    }\n\n    private applyCurrentSettingsToVocoder() {\n        if(this.currentVocoder) {\n            this.currentVocoder.updateModGain(this.modulatorGainValue);\n            this.currentVocoder.updateSampleLevel(this.carrierSampleGainValue);\n            this.currentVocoder.updateSynthLevel(this.oscillatorGainValue);\n            this.currentVocoder.updateNoiseLevel(this.noiseGainValue);\n            this.currentVocoder.updateDetuneValue(this.oscillatorDetuneValue);\n        }\n    }\n    \n    get order(): number {\n        return 1;\n    }\n\n    get id(): string {\n        return Constants.FILTERS_NAMES.VOCODER;\n    }\n}\n","import Constants from \"../../model/Constants\";\n\nclass PassthroughWorkletProcessor extends AudioWorkletProcessor {\n\n    stopped = false;\n    samplesCount = 0;\n\n    constructor() {\n        super();\n        this.port.onmessage = (event) => {\n            if (event.data == \"stop\") {\n                this.stop();\n            }\n        };\n    }\n\n    static get parameterDescriptors() {\n        return [];\n    }\n\n    get defaultParameterDescriptors() {\n        return PassthroughWorkletProcessor.parameterDescriptors;\n    }\n\n    process(inputs: Float32Array[][], outputs: Float32Array[][]): boolean {\n        if (this.stopped) return false;\n\n        const input = inputs[0];\n        const output = outputs[0];\n\n        if (input && input[0]) {\n            this.samplesCount += input[0].length;\n        }\n\n        if (output) {\n            for(let channel = 0; channel < output.length; channel++) {\n                const inp = input[channel];\n                const out = output[channel];\n\n                if (inp) {\n                    for (let sample = 0; sample < inp.length; sample++) {\n                        out[sample] = inp[sample];\n                    }\n                }\n            }\n\n            this.port.postMessage({ command: \"update\", samplesCount: this.samplesCount });\n        }\n\n        return true;\n    }\n\n    stop() {\n        this.stopped = true;\n    }\n}\n\nregisterProcessor(Constants.WORKLET_NAMES.PASSTHROUGH, PassthroughWorkletProcessor);\n","import AbstractAudioFilterWorklet from \"./interfaces/AbstractAudioFilterWorklet\";\nimport Constants from \"../model/Constants\";\nimport \"./worklets/Passthrough.worklet\";\nimport { FilterSettingValue } from \"../model/filtersSettings/FilterSettings\";\nimport PassThroughWorkletEvent from \"@/model/PassThroughWorkletEvent\";\nimport { EventType } from \"@/model/EventTypeEnum\";\n\nexport default class PassThroughFilter extends AbstractAudioFilterWorklet<PassThroughWorkletEvent> {\n    \n    private _totalSamples = 0;\n    private currentTime = 0;\n    private lastSampleCount = 0;\n    private samplePerSecond = 0;\n    private currentTimeSamplesPerSecond = 0;\n\n    receiveEvent(message: MessageEvent<PassThroughWorkletEvent>): void {\n        const currentTime = performance.now();\n        const samplesProcessed = message.data.samplesCount;\n\n        if (message.data.command === \"update\") {\n            this.calculatePercentageProcessed(currentTime, samplesProcessed);\n        }\n\n        this.calculateRemainingTimeProcessing(currentTime, samplesProcessed);\n    }\n\n    /**\n     * Calculate percentage processed\n     * @param currentTime Current time (ms)\n     * @param samplesProcessed Samples count processed\n     */\n    private calculatePercentageProcessed(currentTime: number, samplesProcessed: number) {\n        if (this.currentTime === 0) {\n            this.currentTime = currentTime;\n        }\n\n        const timeDifference = currentTime - this.currentTime;\n        const percentageProcessed = (samplesProcessed / this._totalSamples);\n\n        if (this.eventEmitter && timeDifference >= Constants.TREATMENT_TIME_COUNTING_THROTTLE_INTERVAL) {\n            this.eventEmitter.emit(EventType.UPDATE_AUDIO_TREATMENT_PERCENT, percentageProcessed * 100);\n            this.currentTime = currentTime;\n        }\n    }\n\n    /**\n     * Calculate remaining time to process the audio\n     * @param currentTime Current time (ms)\n     * @param samplesProcessed Samples count processed\n     */\n    private calculateRemainingTimeProcessing(currentTime: number, samplesProcessed: number) {\n        if (this.currentTimeSamplesPerSecond === 0) {\n            this.currentTimeSamplesPerSecond = currentTime;\n        }\n\n        const timeDifferenceSamplePerSecond = currentTime - this.currentTimeSamplesPerSecond;\n        const remainingSamples = this._totalSamples - samplesProcessed;\n\n        if (this.eventEmitter && remainingSamples <= 0) {\n            this.eventEmitter.emit(EventType.UPDATE_REMAINING_TIME_ESTIMATED, 0);\n            return;\n        }\n\n        if (this.eventEmitter && timeDifferenceSamplePerSecond >= 1000) {\n            this.calculateSmoothedSamplePerSecond(timeDifferenceSamplePerSecond, samplesProcessed);\n\n            const remainingTimeSeconds = remainingSamples / this.samplePerSecond;\n            \n            this.currentTimeSamplesPerSecond = currentTime;\n            this.lastSampleCount = samplesProcessed;\n\n            if (isNaN(remainingTimeSeconds) || !isFinite(remainingTimeSeconds)) {\n                this.eventEmitter.emit(EventType.UPDATE_REMAINING_TIME_ESTIMATED, -1);\n            } else {\n                this.eventEmitter.emit(EventType.UPDATE_REMAINING_TIME_ESTIMATED, remainingTimeSeconds);\n            }\n        }\n    }\n\n    /**\n     * Calculate smoothed samples per second\n     * @param timeDifferenceSamplePerSecond Time difference \n     * @param samplesProcessed Samples count processed\n     * @returns Smoothed samples per second\n     */\n    private calculateSmoothedSamplePerSecond(timeDifferenceSamplePerSecond: number, samplesProcessed: number): void {\n        if (timeDifferenceSamplePerSecond > 0) {\n            const currentSampleRate = (samplesProcessed - this.lastSampleCount) / (timeDifferenceSamplePerSecond / 1000);\n            this.samplePerSecond = (Constants.TREATMENT_TIME_COUNTING_SMOOTHING_FACTOR * currentSampleRate) + ((1 - Constants.TREATMENT_TIME_COUNTING_SMOOTHING_FACTOR) * this.samplePerSecond);\n        }\n    }\n\n    get workletName(): string {\n        return Constants.WORKLET_NAMES.PASSTHROUGH;\n    }\n\n    get workletPath(): string {\n        return Constants.WORKLET_PATHS.PASSTHROUGH;\n    }\n\n    get order(): number {\n        return 10;\n    }\n\n    get id(): string {\n        return Constants.FILTERS_NAMES.PASSTHROUGH;\n    }\n\n    set totalSamples(value: number) {\n        this._totalSamples = value;\n        this.currentTime = 0;\n        this.currentTimeSamplesPerSecond = 0;\n        this.samplePerSecond = 0;\n        this.lastSampleCount = 0;\n    }\n\n    getSettings() {\n        return {};\n    }\n\n    isEnabled(): boolean {\n        return true;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async setSetting(settingId: string, value: FilterSettingValue) {}\n}\n","import AbstractAudioElement from \"@/filters/interfaces/AbstractAudioElement\";\nimport BassBoosterFilter from \"../filters/BassBoosterFilter\";\nimport BitCrusherFilter from \"../filters/BitCrusherFilter\";\nimport EchoFilter from \"../filters/EchoFilter\";\nimport HighPassFilter from \"../filters/HighPassFilter\";\nimport LimiterFilter from \"../filters/LimiterFilter\";\nimport LowPassFilter from \"../filters/LowPassFilter\";\nimport ReturnAudioRenderer from \"../filters/ReturnAudioRenderer\";\nimport ReverbFilter from \"../filters/ReverbFilter\";\nimport SoundtouchWrapperFilter from \"../filters/SountouchWrapperFilter\";\nimport TelephonizerFilter from \"../filters/TelephonizerFilter\";\nimport VocoderFilter from \"../filters/VocoderFilter\";\nimport PassThroughFilter from \"../filters/PassThroughFilter\";\nimport AbstractAudioFilter from \"@/filters/interfaces/AbstractAudioFilter\";\nimport AudioFilterEntrypointInterface from \"@/filters/interfaces/AudioFilterEntrypointInterface\";\nimport AbstractAudioRenderer from \"@/filters/interfaces/AbstractAudioRenderer\";\nimport { AudioFilterNodes } from \"@/model/AudioNodes\";\nimport AbstractAudioFilterWorklet from \"@/filters/interfaces/AbstractAudioFilterWorklet\";\nimport EventEmitter from \"@/utils/EventEmitter\";\nimport BufferPlayer from \"@/BufferPlayer\";\nimport { FilterState } from \"@/model/FilterState\";\nimport { FilterSettings } from \"@/model/filtersSettings/FilterSettings\";\nimport Constants from \"@/model/Constants\";\nimport BufferFetcherService from \"@/services/BufferFetcherService\";\nimport BufferDecoderService from \"@/services/BufferDecoderService\";\nimport { ConfigService } from \"@/services/ConfigService\";\nimport GenericConfigService from \"@/utils/GenericConfigService\";\n\nexport default class FilterManager extends AbstractAudioElement {\n\n    /** A list of filters */\n    private filters: AbstractAudioFilter[] = [];\n    /** A list of renderers */\n    private renderers: AbstractAudioRenderer[] = [];\n    /** The entrypoint filter */\n    private _entryPointFilter: (AbstractAudioFilter & AudioFilterEntrypointInterface) | null = null;\n    /** The current connected nodes */\n    private _currentNodes: AudioFilterNodes | null = null;\n    /** The current event emitter */\n    private eventEmitter: EventEmitter | undefined;\n\n    constructor(eventEmitter: EventEmitter | null, bufferFetcherService: BufferFetcherService, bufferDecoderService: BufferDecoderService, configService: ConfigService) {\n        super();\n        this.eventEmitter = eventEmitter || new EventEmitter();\n        this.configService = configService || new GenericConfigService();\n        this.bufferFetcherService = bufferFetcherService;\n        this.bufferDecoderService = bufferDecoderService;\n\n        this.setupDefaultFilters();\n        this.setupDefaultRenderers();\n    }\n\n    /**\n     * Add a new custom filter for this audio editor\n     * @param filters One or more AbstractAudioFilter\n     */\n    addFilters(...filters: AbstractAudioFilter[]) {\n        for (const filter of filters) {\n            filter.initializeDefaultSettings();\n            filter.bufferFetcherService = this.bufferFetcherService;\n            filter.bufferDecoderService = this.bufferDecoderService;\n            filter.configService = this.configService;\n            filter.eventEmitter = this.eventEmitter;\n        }\n\n        this.filters.push(...filters);\n    }\n\n    /**\n     * Add a new custom renderer for this audio editor\n     * @param renderers One or more AbstractAudioRenderer\n     */\n    addRenderers(...renderers: AbstractAudioRenderer[]) {\n        for (const renderer of renderers) {\n            renderer.bufferFetcherService = this.bufferFetcherService;\n            renderer.bufferDecoderService = this.bufferDecoderService;\n            renderer.configService = this.configService;\n        }\n\n        this.renderers.push(...renderers);\n    }\n\n    /** Setup all audio filters */\n    private setupDefaultFilters() {\n        const bassBooster = new BassBoosterFilter(200, 15, 200, -2);\n        const bitCrusher = new BitCrusherFilter(16, 0.9);\n        const echo = new EchoFilter(0.2, 0.75);\n        const highPass = new HighPassFilter(3500);\n        const lowPass = new LowPassFilter(3500);\n        const reverb = new ReverbFilter();\n        const soundtouchWrapper = new SoundtouchWrapperFilter();\n        const limiterFilter = new LimiterFilter(0, 0, 0, 3, -0.05, 0.1);\n        const telephonizerFilter = new TelephonizerFilter();\n        const vocoder = new VocoderFilter();\n        const passthrough = new PassThroughFilter();\n\n        this._entryPointFilter = soundtouchWrapper;\n        this.addFilters(bassBooster, bitCrusher, echo, highPass, lowPass, reverb, limiterFilter, telephonizerFilter, soundtouchWrapper, vocoder, passthrough);\n    }\n\n    /** Setup the renderers */\n    private setupDefaultRenderers() {\n        const returnAudio = new ReturnAudioRenderer();\n        this.addRenderers(returnAudio);\n    }\n\n    /**\n     * Get enabled/disabled state of all filters/renderers\n     * @returns The filters state (enabled/disabled)\n     */\n    getFiltersState(): FilterState {\n        const state: FilterState = {};\n\n        [...this.filters, ...this.renderers].forEach(filter => {\n            state[filter.id] = filter.isEnabled();\n        });\n\n        return state;\n    }\n\n    /**\n     * Get the settings of all filters/renderers\n     * @returns \n     */\n    getFiltersSettings(): Map<string, FilterSettings> {\n        const settings = new Map<string, FilterSettings>();\n\n        for (const filter of this.filters) {\n            settings.set(filter.id, filter.getSettings());\n        }\n\n        return settings;\n    }\n\n    /**\n     * Toggle enabled/disabled state for a filter/renderer\n     * @param filterId The filter/renderer ID\n     */\n    toggleFilter(filterId: string) {\n        const filter = this.filters.find(f => f.id === filterId);\n        const renderer = this.renderers.find(f => f.id === filterId);\n\n        if (filter) {\n            filter.toggle();\n        }\n\n        if (renderer) {\n            renderer.toggle();\n        }\n    }\n\n    /**\n     * Change a filter/renderer setting\n     * @param filterId Filter ID\n     * @param settings Filter setting (key/value)\n     */\n    async changeFilterSettings(filterId: string, settings: FilterSettings) {\n        const filter = this.filters.find(f => f.id === filterId);\n\n        if (filter) {\n            for (const key of Object.keys(settings)) {\n                await filter.setSetting(key, settings[key]);\n            }\n        }\n    }\n\n    /**\n     * Reset the settings of a filter/renderer\n     * @param filterId Id of the filter/renderer\n     */\n    async resetFilterSettings(filterId: string) {\n        const filter = this.filters.find(f => f.id === filterId);\n\n        if (filter) {\n            await filter.resetSettings();\n        }\n    }\n\n    /**\n     * Reset all filters/renderers state (enabled/disabled) based on their default states\n     */\n    resetAllFiltersState() {\n        [...this.filters, ...this.renderers].forEach(element => {\n            if (element.isDefaultEnabled()) {\n                element.enable();\n            } else {\n                element.disable();\n            }\n        });\n    }\n\n    /**\n     * Connect the Audio API nodes of the enabled filters\n     * @param context The Audio Context\n     * @param buffer  The Audio Buffer\n     * @param keepCurrentInputOutput Keep current first input/output nodes?\n     */\n    async connectNodes(context: BaseAudioContext, buffer: AudioBuffer, keepCurrentInputOutput: boolean, isCompatibilityMode: boolean) {\n        if (!this._entryPointFilter) {\n            return;\n        }\n\n        let entrypointNode: AudioNode | null = null;\n\n        if (keepCurrentInputOutput && this._currentNodes) {\n            entrypointNode = this._currentNodes.input;\n        } else {\n            const entrypointNodes = await this._entryPointFilter.getEntrypointNode(context, buffer, !isCompatibilityMode);\n            entrypointNode = entrypointNodes.input;\n        }\n\n        const intermediateNodes: AudioFilterNodes[] = [];\n        let previousNode: AudioNode | undefined = entrypointNode;\n\n        this.disconnectOldNodes(keepCurrentInputOutput);\n\n        // Sort by filter order, then remove the disabled filter (but always keep the last/output filter)\n        const filters = this.filters\n            .sort((a, b) => a.order - b.order)\n            .filter((filter, index) => filter !== this._entryPointFilter && (filter.isEnabled() || index >= this.filters.length - 1));\n\n        for (const filter of filters) {\n            const node = filter.getNode(context);\n\n            if (previousNode) {\n                previousNode.connect(node.input);\n            }\n\n            previousNode = node.output;\n            intermediateNodes.push(node);\n        }\n\n        if (this._entryPointFilter) {\n            this._entryPointFilter.updateState();\n        }\n\n        this._currentNodes = {\n            input: entrypointNode!,\n            output: previousNode!,\n            intermediateNodes: intermediateNodes\n                .filter(n => n.input != previousNode && n.output != previousNode &&\n                    n.input != entrypointNode && n.output != entrypointNode)\n        };\n    }\n\n    /**\n     * Disconnect old audio nodes\n     * @param keepCurrentOutput Keeps current output nodes?\n     */\n    disconnectOldNodes(keepCurrentOutput: boolean) {\n        if (this._currentNodes) {\n            this._currentNodes.input.disconnect();\n\n            if (!keepCurrentOutput) {\n                this._currentNodes.output.disconnect();\n            }\n\n            if (this._currentNodes.intermediateNodes) {\n                for (const intermediate of this._currentNodes.intermediateNodes) {\n                    intermediate.input.disconnect();\n                    intermediate.output.disconnect();\n                }\n            }\n        }\n    }\n\n    /** Initialize worklets filters */\n    async initializeWorklets(context: BaseAudioContext) {\n        for (const filter of this.filters) {\n            if (filter.isWorklet()) {\n                await (filter as AbstractAudioFilterWorklet<object>).initializeWorklet(context);\n            }\n        }\n    }\n    \n    /**\n     * Execute audio renderers then returns audio buffer rendered\n     * @param buffer The buffer to process\n     * @param outputContext The output context\n     * @returns Audio buffer rendered\n     */\n    async executeAudioRenderers(buffer: AudioBuffer, outputContext: AudioContext | OfflineAudioContext) {\n        let currentBuffer = buffer;\n\n        for (const renderer of this.renderers.sort((a, b) => a.order - b.order)) {\n            if (renderer.isEnabled()) {\n                currentBuffer = await renderer.renderAudio(outputContext, currentBuffer);\n            }\n        }\n        return currentBuffer;\n    }\n\n    setupPlayerSpeed(bufferPlayer: BufferPlayer) {\n        if (this._entryPointFilter) {\n            const speedAudio = this._entryPointFilter.getSpeed();\n            bufferPlayer.speedAudio = speedAudio;\n        }\n    }\n\n    getAddingTime() {\n        let duration = 0;\n        \n        for (const filter of this.filters) {\n            if (filter.isEnabled()) {\n                duration += filter.getAddingTime();\n            }\n        }\n\n        return duration;\n    }\n\n    /**\n     * Setup the passthrough filter to count audio rendering progress\n     * @param durationAudio Audio duration - number\n     */\n    setupPasstroughFilter(durationAudio: number, currentContext: AudioContext | null) {\n        const passthroughFilter = this.filters.find(f => f.id === Constants.FILTERS_NAMES.PASSTHROUGH);\n\n        if (passthroughFilter && currentContext) {\n            (passthroughFilter as PassThroughFilter).totalSamples = durationAudio * currentContext.sampleRate;\n        }\n    }\n\n    get entrypointFilter() {\n        return this._entryPointFilter;\n    }\n\n    get currentNodes() {\n        return this._currentNodes;\n    }\n\n    get order(): number {\n        return -1;\n    }\n\n    get id(): string {\n        return \"FilterManager\";\n    }\n}\n","import { EventType } from \"@/model/EventTypeEnum\";\nimport { ConfigService } from \"@/services/ConfigService\";\nimport AbstractAudioElement from \"@/filters/interfaces/AbstractAudioElement\";\nimport Constants from \"@/model/Constants\";\nimport EventEmitter from \"@/utils/EventEmitter\";\n\nexport default class AudioContextManager extends AbstractAudioElement {\n\n    /** The current event emitter */\n    private eventEmitter: EventEmitter | undefined;\n    /** The current audio context */\n    private _currentContext: AudioContext | null | undefined;\n    /** The old audio context */\n    private oldAudioContext: AudioContext | null | undefined;\n    /** The previous sample rate setting */\n    private previousSampleRate = Constants.DEFAULT_SAMPLE_RATE;\n\n    constructor(context: AudioContext | undefined | null, configService: ConfigService | null, eventEmitter: EventEmitter | null) {\n        super();\n\n        this._currentContext = context;\n        this.eventEmitter = eventEmitter || new EventEmitter();\n        this.configService = configService;\n\n        this.setup();\n    }\n\n    private setup() {\n        if (this.configService) {\n            this.previousSampleRate = this.configService.getSampleRate();\n\n            if (this.eventEmitter) {\n                this.eventEmitter.emit(EventType.SAMPLE_RATE_CHANGED, this.previousSampleRate);\n            }\n        }\n\n        if (!this.currentContext) {\n            this.createNewContext(this.previousSampleRate);\n        }\n    }\n\n    /**\n     * Create new context if needed, for example if sample rate setting have changed\n     * @param principalBuffer The audio buffer\n     * @returns true if a new context was created, false otherwise\n     */\n    createNewContextIfNeeded(principalBuffer: AudioBuffer | null) {\n        const isCompatibilityModeEnabled = this.configService && this.configService.isCompatibilityModeEnabled();\n\n        if (isCompatibilityModeEnabled && principalBuffer) {\n            // If compatibility mode is enabled, we use the sample rate of the input audio buffer\n            if (this.currentSampleRate != principalBuffer.sampleRate) {\n                this.createNewContext(principalBuffer.sampleRate);\n                this.previousSampleRate = principalBuffer.sampleRate;\n\n                return true;\n            }\n        } else {\n            // Otherwise we change the context if the sample rate has changed\n            let currentSampleRate = Constants.DEFAULT_SAMPLE_RATE;\n\n            if (this.configService) {\n                currentSampleRate = this.configService.getSampleRate();\n            }\n\n            // If sample rate setting has changed, create a new audio context\n            if (currentSampleRate != this.previousSampleRate) {\n                this.createNewContext(currentSampleRate);\n                this.previousSampleRate = currentSampleRate;\n\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /** \n     * Stop previous audio context and create a new one\n     * @param sampleRate New sample rate\n     */\n    private createNewContext(sampleRate: number) {\n        if (this._currentContext) {\n            this.oldAudioContext = this._currentContext;\n            this.destroyOldContext();\n        }\n\n        const options: AudioContextOptions = {\n            latencyHint: \"interactive\"\n        };\n\n        if (sampleRate != 0) {\n            options.sampleRate = sampleRate;\n        }\n\n        this._currentContext = new AudioContext(options);\n\n        if (this.eventEmitter) {\n            this.eventEmitter.emit(EventType.SAMPLE_RATE_CHANGED, this.currentSampleRate);\n        }\n    }\n\n    /**\n     * Destroy previous AudioContext\n     */\n    private destroyOldContext() {\n        if (this.oldAudioContext) {\n            this.oldAudioContext.close();\n            this.oldAudioContext = null;\n        }\n    }\n\n    /**\n     * Get the current sample rate used\n     */\n    get currentSampleRate(): number {\n        if (this.currentContext) {\n            return this.currentContext.sampleRate;\n        }\n\n        return 0;\n    }\n\n    get currentContext() {\n        return this._currentContext;\n    }\n\n    get order(): number {\n        return -1;\n    }\n\n    get id(): string {\n        return \"ContextManager\";\n    }\n}\n","export default function getRecorderWorker(workerBasePath?: string): Worker {\n    return new Worker((workerBasePath ? workerBasePath : \"\") + \"RecorderWorker.js\");\n};\n","import Constants from \"../model/Constants\";\nimport { RecorderCallback, RecorderCallbacks } from \"../model/RecorderCallback\";\nimport RecorderConfig from \"../model/RecorderConfig\";\nimport RecorderWorkerMessage from \"../model/RecorderWorkerMessage\";\nimport RecorderWorkletMessage from \"../model/RecorderWorkletMessage\";\nimport utilFunctions from \"../utils/Functions\";\nimport getRecorderWorker from \"./getRecorderWorker\";\n\nexport class Recorder {\n\n    // Inline Worker\n    private worker: Worker | null = null;\n    private node: ScriptProcessorNode | AudioWorkletNode | null = null;\n    private context: BaseAudioContext | null = null;\n\n    private config: RecorderConfig = {\n        bufferLen: 4096,\n        sampleRate: 44100,\n        numChannels: 2,\n        mimeType: \"audio/wav\",\n        workletBasePath: \"worklets/\",\n        workerBasePath: \"workers/\",\n        bitrate: Constants.DEFAULT_MP3_BITRATE,\n        callback: () => { }\n    };\n\n    private callbacks: RecorderCallbacks = {\n        getBuffer: [],\n        exportWAV: [],\n        exportMP3: []\n    };\n\n    recording = false;\n\n    constructor(cfg: RecorderConfig) {\n        Object.assign(this.config, cfg);\n    }\n\n    async setup(source: AudioNode) {\n        if (this.node) { // Disconnect previous node\n            if (this.node instanceof AudioWorkletNode) {\n                this.node.port.postMessage(\"stop\");\n            }\n\n            this.node.disconnect();\n        }\n\n        if (source) {\n            this.context = source.context;\n\n            await this.createRecorderNode();\n\n            if (this.node && this.context) {\n                source.connect(this.node);\n                this.node.connect(this.context.destination);    //this should not be necessary\n            }\n        }\n\n        if (this.context && !this.worker) {\n            this.worker = getRecorderWorker(this.config.workerBasePath);\n\n            if (this.worker) {\n                this.worker.postMessage({\n                    command: \"init\",\n                    config: {\n                        sampleRate: this.context.sampleRate,\n                        numChannels: this.config.numChannels,\n                        bitrate: this.config.bitrate\n                    }\n                });\n\n                this.worker.onmessage = (e: RecorderWorkerMessage) => {\n                    let callbacks = null;\n\n                    switch (e.data.command) {\n                    case \"getBuffer\":\n                        callbacks = this.callbacks.getBuffer;\n                        break;\n                    case Constants.EXPORT_WAV_COMMAND:\n                        callbacks = this.callbacks.exportWAV;\n                        break;\n                    case Constants.EXPORT_MP3_COMMAND:\n                        callbacks = this.callbacks.exportMP3;\n                        break;\n                    }\n\n                    if (callbacks) {\n                        const cb = callbacks.pop();\n                        if (typeof cb == \"function\") {\n                            (cb as RecorderCallback<Blob | Float32Array[]>)(e.data.data);\n                        }\n                    }\n                };\n            }\n        }\n    }\n\n\n    private async createRecorderNode() {\n        if (this.context) {\n            if (utilFunctions.isAudioWorkletCompatible(this.context) && Constants.ENABLE_RECORDER_AUDIO_WORKLET) {\n                try {\n                    await this.createRecorderWorklet();\n                } catch(e) {\n                    this.createRecorderScriptProcessorNode();\n                }\n            } else {\n                this.createRecorderScriptProcessorNode();\n            }\n        }\n    }\n\n    private async createRecorderWorklet() {\n        if (this.context) {\n            await this.context.audioWorklet.addModule(this.config.workletBasePath + Constants.WORKLET_PATHS.RECORDER_WORKLET);\n\n            this.node = new AudioWorkletNode(this.context, Constants.WORKLET_NAMES.RECORDER_WORKLET);\n\n            if (this.node && this.node.port) {\n                const numChannelParameter = this.node.parameters.get(\"numChannels\");\n\n                if(numChannelParameter) {\n                    numChannelParameter.value = this.config.numChannels;\n                    numChannelParameter.setValueAtTime(this.config.numChannels, 0);\n                }\n\n                this.node.port.onmessage = (e: MessageEvent<RecorderWorkletMessage>) => {\n                    if (this.worker && e.data.command == \"record\" && e.data.buffer.length > 0) {\n                        this.worker.postMessage({\n                            command: \"record\",\n                            buffer: e.data.buffer\n                        });\n                    }\n                };\n            }\n        }\n    }\n\n    private createRecorderScriptProcessorNode() {\n        if (this.context) {\n            this.node = (this.context.createScriptProcessor).call(this.context,\n                this.config.bufferLen, this.config.numChannels, this.config.numChannels);\n\n            this.node.onaudioprocess = (e) => {\n                if (!this.recording) return;\n\n                const buffer = [];\n                for (let channel = 0; channel < this.config.numChannels; channel++) {\n                    buffer.push(e.inputBuffer.getChannelData(channel));\n                }\n\n                if (this.worker) {\n                    this.worker.postMessage({\n                        command: \"record\",\n                        buffer: buffer\n                    });\n                }\n            };\n        }\n    }\n\n    record() {\n        this.recording = true;\n\n        if (this.node instanceof AudioWorkletNode) {\n            this.node.port.postMessage(\"record\");\n        }\n    }\n\n    stop() {\n        this.recording = false;\n\n        if (this.node instanceof AudioWorkletNode) {\n            this.node.port.postMessage(\"stop\");\n        }\n    }\n\n    clear() {\n        if (this.worker) {\n            this.worker.postMessage({ command: \"clear\" });\n        }\n    }\n\n    kill() {\n        this.clear();\n        this.stop();\n\n        if (this.worker) {\n            this.worker.terminate();\n        }\n    }\n\n    getBuffer(cb: RecorderCallback<Float32Array[]>) {\n        cb = cb || this.config.callback;\n        if (!cb) throw new Error(\"Callback not set\");\n\n        this.callbacks.getBuffer.push(cb);\n\n        if (this.worker) {\n            this.worker.postMessage({ command: \"getBuffer\" });\n        }\n    }\n\n    exportWAV(cb: RecorderCallback<Blob>, mimeType?: string) {\n        mimeType = mimeType || this.config.mimeType;\n        cb = cb || this.config.callback;\n        if (!cb) throw new Error(\"Callback not set\");\n\n        this.callbacks.exportWAV.push(cb);\n\n        if (this.worker) {\n            this.worker.postMessage({\n                command: Constants.EXPORT_WAV_COMMAND,\n                type: mimeType\n            });\n        }\n    }\n\n    exportMP3(cb: RecorderCallback<Blob>, mimeType?: string) {\n        mimeType = mimeType || this.config.mimeType;\n        cb = cb || this.config.callback;\n        if (!cb) throw new Error(\"Callback not set\");\n\n        this.callbacks.exportMP3.push(cb);\n\n        if (this.worker) {\n            this.worker.postMessage({\n                command: Constants.EXPORT_MP3_COMMAND,\n                type: mimeType\n            });\n        }\n    }\n\n    static forceDownload(blob: Blob, filename: string) {\n        const link = window.document.createElement(\"a\");\n        const url = (window.URL || window.webkitURL).createObjectURL(blob);\n        window.document.body.appendChild(link);\n        link.href = url;\n        link.download = filename || \"output.wav\";\n        link.click();\n        window.URL.revokeObjectURL(url);\n    }\n};\n\nexport default Recorder;\n","\nimport { Recorder } from \"../recorder/Recorder\";\nimport { EventType } from \"@/model/EventTypeEnum\";\nimport { ConfigService } from \"@/services/ConfigService\";\nimport BufferPlayer from \"@/BufferPlayer\";\nimport AbstractAudioElement from \"@/filters/interfaces/AbstractAudioElement\";\nimport SaveBufferOptions from \"@/model/SaveBufferOptions\";\nimport EventEmitter from \"@/utils/EventEmitter\";\nimport AudioContextManager from \"./AudioContextManager\";\nimport Constants from \"@/model/Constants\";\nimport FilterManager from \"./FilterManager\";\nimport RecorderWorkerMessage from \"../model/RecorderWorkerMessage\";\nimport getRecorderWorker from \"../recorder/getRecorderWorker\";\n\nexport default class SaveBufferManager extends AbstractAudioElement {\n    \n    /** The filter manager */\n    private filterManager: FilterManager | undefined;\n    /** The context manager */\n    private contextManager: AudioContextManager | undefined;\n    /** The current event emitter */\n    private eventEmitter: EventEmitter | undefined;\n    /** The audio player */\n    private bufferPlayer: BufferPlayer | undefined;\n\n    /** If we are currently processing and downloading the buffer */\n    private savingBuffer = false;\n    /** Callback used when saving audio */\n    private playingStoppedCallback: (() => void) | null = null;\n\n    constructor(contextManager: AudioContextManager | undefined, configService: ConfigService | null, eventEmitter: EventEmitter | null, bufferPlayer: BufferPlayer) {\n        super();\n\n        this.contextManager = contextManager;\n        this.eventEmitter = eventEmitter || new EventEmitter();\n        this.bufferPlayer = bufferPlayer;\n        this.configService = configService;\n\n        // Callback called just before starting audio player\n        this.setup();\n    }\n\n    private setup() {\n        if (this.bufferPlayer) {\n            // Callback called when playing is finished\n            this.bufferPlayer.on(EventType.PLAYING_FINISHED, () => {\n                if (this.savingBuffer && this.playingStoppedCallback && this.eventEmitter) {\n                    this.eventEmitter.off(EventType.PLAYING_STOPPED, this.playingStoppedCallback);\n                }\n            });\n        }\n    }\n\n    /**\n     * Save the rendered audio to a buffer\n     * @param options The save options\n     * @returns A promise resolved when the audio buffer is downloaded to the user\n     */\n    async saveBuffer(renderedBuffer: AudioBuffer | null, options?: SaveBufferOptions): Promise<boolean> {\n        if (this.savingBuffer) {\n            throw new Error(\"The buffer is currently saving\");\n        }\n\n        if (!this.bufferPlayer) {\n            throw new Error(\"No buffer player was found\");\n        }\n\n        this.savingBuffer = true;\n\n        let savingResult = false;\n\n        if (!this.bufferPlayer.compatibilityMode) {\n            savingResult = await this.saveBufferDirect(renderedBuffer, options);\n        } else {\n            savingResult = await this.saveBufferCompatibilityMode(options);\n        }\n\n        this.savingBuffer = false;\n\n        return savingResult;\n    }\n\n    /**\n     * Save the rendered audio to a buffer, when compatibility mode is disabled\n     * @param options The save options\n     * @returns A promise resolved when the audio buffer is downloaded to the user\n     */\n    private saveBufferDirect(renderedBuffer: AudioBuffer | null, options?: SaveBufferOptions): Promise<boolean> {\n        return new Promise((resolve, reject) => {\n            if (!renderedBuffer || (this.contextManager && !this.contextManager.currentContext)) {\n                return reject(\"No rendered buffer or AudioContext not initialized\");\n            }\n\n            const worker = getRecorderWorker(this.configService?.getWorkerBasePath());\n\n            if (worker) {\n                const buffer: Float32Array[] = [];\n\n                for (let i = 0; i < renderedBuffer.numberOfChannels; i++) {\n                    buffer.push(renderedBuffer.getChannelData(i));\n                }\n\n                worker.onmessage = (e: RecorderWorkerMessage) => {\n                    if (e.data.command == Constants.EXPORT_WAV_COMMAND || e.data.command == Constants.EXPORT_MP3_COMMAND) {\n                        this.downloadAudioBlob(e.data.data, options);\n                    }\n\n                    worker.terminate();\n                    this.savingBuffer = false;\n                    resolve(true);\n                };\n\n                worker.postMessage({\n                    command: Constants.INIT_COMMAND,\n                    config: {\n                        sampleRate: renderedBuffer.sampleRate,\n                        numChannels: 2,\n                        bitrate: options?.bitrate || Constants.DEFAULT_MP3_BITRATE\n                    }\n                });\n\n                worker.postMessage({\n                    command: Constants.RECORD_COMMAND,\n                    buffer\n                });\n\n                worker.postMessage({\n                    command: options?.format === \"mp3\" || Constants.DEFAULT_SAVE_FORMAT === \"mp3\" ? Constants.EXPORT_MP3_COMMAND : Constants.EXPORT_WAV_COMMAND,\n                    type: Constants.AUDIO_WAV\n                });\n            }\n        });\n    }\n\n    /**\n     * Save the rendered audio to a buffer, when compatibility mode is enabled\n     * @param options The save options\n     * @returns A promise resolved when the audio buffer is downloaded to the user\n     */\n    private saveBufferCompatibilityMode(options?: SaveBufferOptions): Promise<boolean> {\n        return new Promise((resolve, reject) => {\n            if (!this.bufferPlayer) {\n                return reject(\"No buffer player found\");\n            }\n\n            this.bufferPlayer.start().then(() => {\n                if (!this.configService) {\n                    return reject(\"No config service found\");\n                }\n\n                if (!this.filterManager) {\n                    return reject(\"No filter manager found\");\n                }\n\n                const rec = new Recorder({\n                    bufferLen: this.configService.getBufferSize(),\n                    sampleRate: this.configService.getSampleRate(),\n                    numChannels: 2,\n                    workletBasePath: this.configService.getWorkletBasePath(),\n                    workerBasePath: this.configService.getWorkerBasePath(),\n                    mimeType: options?.format == \"mp3\" ? Constants.AUDIO_MP3 : Constants.AUDIO_WAV,\n                    bitrate: options?.bitrate || Constants.DEFAULT_MP3_BITRATE\n                });\n\n                rec.setup(this.filterManager.currentNodes!.output).then(() => {\n                    rec.record();\n\n                    this.playingStoppedCallback = () => {\n                        rec.kill();\n\n                        this.savingBuffer = false;\n\n                        if (this.eventEmitter) {\n                            this.eventEmitter.off(EventType.PLAYING_FINISHED, finishedCallback);\n    \n                            if (this.playingStoppedCallback) {\n                                this.eventEmitter.off(EventType.PLAYING_STOPPED, this.playingStoppedCallback);\n                            }\n                        }\n\n                        resolve(true);\n                    };\n\n                    const finishedCallback = () => {\n                        if (this.playingStoppedCallback && this.eventEmitter) {\n                            this.eventEmitter.off(EventType.PLAYING_STOPPED, this.playingStoppedCallback);\n                        }\n\n                        rec.stop();\n\n                        const downloadBlobCallback = (blob: Blob) => {\n                            this.downloadAudioBlob(blob, options);\n\n                            this.savingBuffer = false;\n\n                            if (this.eventEmitter) {\n                                this.eventEmitter.off(EventType.PLAYING_FINISHED, finishedCallback);\n                            }\n                            \n                            rec.kill();\n\n                            resolve(true);\n                        };\n\n                        if (options?.format === \"mp3\" || Constants.DEFAULT_SAVE_FORMAT === \"mp3\") {\n                            rec.exportMP3(downloadBlobCallback);\n                        } else {\n                            rec.exportWAV(downloadBlobCallback);\n                        }\n                    };\n\n                    if (this.eventEmitter) {\n                        this.eventEmitter.on(EventType.PLAYING_FINISHED, finishedCallback);\n                        this.eventEmitter.on(EventType.PLAYING_STOPPED, this.playingStoppedCallback);\n                    }\n                });\n            });\n        });\n    }\n\n    /**\n     * Download an audio Blob\n     * @param blob The blob\n     * @param options The save options\n     */\n    private downloadAudioBlob(blob: Blob, options?: SaveBufferOptions) {\n        Recorder.forceDownload(blob, \"audio-\" + new Date().toISOString() + \".\" + (options?.format || Constants.DEFAULT_SAVE_FORMAT));\n    }\n\n    get order(): number {\n        return -1;\n    }\n\n    get id(): string {\n        return \"SaveBufferManager\";\n    }\n}\n","import BufferPlayer from \"@/BufferPlayer\";\nimport EventEmitter from \"@/utils/EventEmitter\";\nimport AudioContextManager from \"./AudioContextManager\";\nimport AbstractAudioElement from \"@/filters/interfaces/AbstractAudioElement\";\nimport FilterManager from \"./FilterManager\";\nimport { ConfigService } from \"@/services/ConfigService\";\nimport { EventType } from \"@/model/EventTypeEnum\";\nimport utils from \"../utils/Functions\";\nimport Constants from \"@/model/Constants\";\nimport BufferManager from \"./BufferManager\";\n\nexport default class AudioProcessor extends AbstractAudioElement {\n    \n    /** The filter manager */\n    private filterManager: FilterManager | undefined;\n    /** The context manager */\n    private contextManager: AudioContextManager | undefined;\n    /** The current event emitter */\n    private eventEmitter: EventEmitter | undefined;\n    /** The audio player */\n    private bufferPlayer: BufferPlayer | undefined;\n    /** The save buffer manager */\n    private bufferManager: BufferManager | undefined;\n\n    /** The current offline context */\n    private currentOfflineContext: OfflineAudioContext | null | undefined;\n    /** The resulting audio buffer */\n    private _renderedBuffer: AudioBuffer | null = null;\n    /** true if the user wanted to cancel audio rendering */\n    private audioRenderingLastCanceled = false;\n\n    /** true if initial rendering for the current buffer was done */\n    initialRenderingDone = false;\n    /** The sum of all the samples of the principal buffer,\n     * used to detect the need to enable the compatibility mode */\n    sumPrincipalBuffer: number = 0;\n\n    constructor(contextManager: AudioContextManager | undefined, configService: ConfigService | null, eventEmitter: EventEmitter | null, bufferPlayer: BufferPlayer, filterManager: FilterManager, bufferManager: BufferManager) {\n        super();\n\n        this.contextManager = contextManager;\n        this.eventEmitter = eventEmitter || new EventEmitter();\n        this.bufferPlayer = bufferPlayer;\n        this.configService = configService;\n        this.filterManager = filterManager;\n        this.bufferManager = bufferManager;\n    }\n\n    /** Prepare the AudioContext before use */\n    async prepareContext(principalBuffer: AudioBuffer | null) {\n        if (this.contextManager) {\n            const changed = this.contextManager.createNewContextIfNeeded(principalBuffer);\n\n            if (changed && this.bufferManager) {\n                await this.bufferManager.resetBufferFetcher();\n            }\n    \n            if (this.contextManager.currentContext) {\n                this.contextManager.currentContext.resume();\n            }\n        }\n    }\n\n    /**\n     * Render the audio to a buffer\n     * @returns A promise resolved when the audio processing is finished.\n     * The promise return false if the audio processing was cancelled or if an error occurred.\n     * The resulting audio buffer can then be obtained by using the \"getOutputBuffer\" method.\n     */\n    async renderAudio(principalBuffer: AudioBuffer | null): Promise<boolean> {\n        await this.prepareContext(principalBuffer);\n\n        if (!this.contextManager || !this.contextManager.currentContext) {\n            throw new Error(\"AudioContext is not yet available\");\n        }\n\n        if(!this.filterManager) {\n            throw new Error(\"Filter manager is not available\");\n        }\n\n        if (!this.filterManager.entrypointFilter) {\n            throw new Error(\"Entrypoint filter is not available\");\n        }\n\n        if (!principalBuffer) {\n            throw new Error(\"No principal buffer available\");\n        }\n\n        // If initial rendering is disabled and compatibility mode is disabled, we stop here\n        if (!this.initialRenderingDone && this.configService && this.configService.isInitialRenderingDisabled() && !this.configService.isCompatibilityModeEnabled()) {\n            this.loadInitialBuffer(principalBuffer);\n            this.initialRenderingDone = true;\n            return true;\n        }\n\n        // If switching from compatiblity mode to normal mode, we stop the audio player\n        if (this.configService && this.bufferPlayer && !this.configService.isCompatibilityModeEnabled() && this.bufferPlayer.compatibilityMode) {\n            this.bufferPlayer.stop();\n        }\n\n        const speedAudio = this.filterManager.entrypointFilter.getSpeed();\n        const durationAudio = utils.calculateAudioDuration(principalBuffer, this.filterManager, speedAudio);\n        const offlineContext = new OfflineAudioContext(2, this.contextManager.currentContext.sampleRate * durationAudio, this.contextManager.currentContext.sampleRate);\n        const outputContext = this.configService && this.configService.isCompatibilityModeEnabled() ? this.contextManager.currentContext : offlineContext;\n\n        this._renderedBuffer = await this.filterManager.executeAudioRenderers(principalBuffer, outputContext);\n        this.currentOfflineContext = null;\n        this.audioRenderingLastCanceled = false;\n\n\n        utils.resetAudioRenderingProgress(this.eventEmitter);\n        this.filterManager.setupPasstroughFilter(durationAudio, this.contextManager.currentContext);\n\n        return await this.setupOutput(principalBuffer, outputContext, durationAudio, offlineContext);\n    }\n    \n    /**\n     * Setup output buffers/nodes, then process the audio\n     * @param outputContext Output audio context\n     * @param durationAudio Duration of the audio buffer\n     * @param offlineContext An offline context to do the rendering (can be omited, in this case the rendering is done in real time - \"compatibility mode\")\n     * @returns A promise resolved when the audio processing is done. The promise returns false if the audio processing was cancelled, or if an error occurred.\n     */\n    async setupOutput(principalBuffer: AudioBuffer | null, outputContext: BaseAudioContext, durationAudio?: number, offlineContext?: OfflineAudioContext): Promise<boolean> {\n        if (this._renderedBuffer && this.configService && this.eventEmitter && this.bufferPlayer && this.filterManager) {\n            // Initialize worklets then connect the filter nodes\n            await this.filterManager.initializeWorklets(outputContext);\n            await this.filterManager.connectNodes(outputContext, this._renderedBuffer, false, this.configService.isCompatibilityModeEnabled());\n\n            this.filterManager.setupPlayerSpeed(this.bufferPlayer);\n\n            // Standard mode\n            if (!this.configService.isCompatibilityModeEnabled() && offlineContext && this.filterManager.currentNodes) {\n                this.currentOfflineContext = offlineContext;\n                this.filterManager.currentNodes.output.connect(outputContext.destination);\n\n                const renderedBuffer = await offlineContext.startRendering();\n\n                if (this.contextManager && !this.loadRenderedAudio(principalBuffer, renderedBuffer)) {\n                    return await this.setupOutput(principalBuffer, this.contextManager.currentContext!, durationAudio);\n                }\n\n                if (this.audioRenderingLastCanceled) {\n                    return false;\n                }\n\n                this.eventEmitter.emit(EventType.OFFLINE_AUDIO_RENDERING_FINISHED);\n            } else { // Compatibility mode\n                this.bufferPlayer.setCompatibilityMode(this.filterManager.currentNodes!.output, durationAudio);\n                this.initialRenderingDone = true;\n            }\n\n            this.eventEmitter.emit(EventType.AUDIO_RENDERING_FINISHED);\n\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Load rendered audio buffer into audio player\n     * @param renderedBuffer Rendered audio buffer - AudioBuffer\n     * @returns false if the rendred audio buffer is invalid, true otherwise\n     */\n    private loadRenderedAudio(principalBuffer: AudioBuffer | null, renderedBuffer: AudioBuffer): boolean {\n        if (this.eventEmitter && this.bufferPlayer) {\n            if (!this.audioRenderingLastCanceled) {\n                const sumRenderedAudio = utils.sumAudioBuffer(renderedBuffer);\n\n                if (sumRenderedAudio == 0 && this.sumPrincipalBuffer !== 0) {\n                    if (this.configService && !this.configService.isCompatibilityModeChecked()) {\n                        this.setCompatibilityModeChecked(true);\n                        this.configService.enableCompatibilityMode();\n                        this.eventEmitter.emit(EventType.COMPATIBILITY_MODE_AUTO_ENABLED);\n\n                        return false;\n                    }\n\n                    this.eventEmitter.emit(EventType.RENDERING_AUDIO_PROBLEM_DETECTED);\n                }\n\n                this._renderedBuffer = renderedBuffer;\n                this.bufferPlayer.loadBuffer(this._renderedBuffer);\n            } else if (!this.initialRenderingDone) {\n                this.loadInitialBuffer(principalBuffer);\n                this.eventEmitter.emit(EventType.CANCELLED_AND_LOADED_INITIAL_AUDIO);\n            }\n\n            this.initialRenderingDone = true;\n        }\n\n        return true;\n    }\n\n    /**\n     * Load the initial audio buffer to the buffer player\n     */\n    private loadInitialBuffer(principalBuffer: AudioBuffer | null) {\n        if (this.bufferPlayer) {\n            this._renderedBuffer = principalBuffer;\n            this.bufferPlayer.loadBuffer(principalBuffer!);\n        }\n    }\n\n    /**\n     * Cancel the audio rendering\n     */\n    public cancelAudioRendering() {\n        if (this.currentOfflineContext && !this.audioRenderingLastCanceled && this.filterManager) {\n            this.audioRenderingLastCanceled = true;\n            this.filterManager.disconnectOldNodes(false);\n\n            if (this.eventEmitter) {\n                this.eventEmitter.emit(EventType.CANCELLING_AUDIO_PROCESSING);\n            }\n        }\n    }\n\n    /**\n     * Set compatibility/direct audio rendering mode already checked for auto enabling (if an error occurs rendering in offline context)\n     * @param checked boolean\n     */\n    private setCompatibilityModeChecked(checked: boolean) {\n        if (this.configService) {\n            this.configService.setConfig(Constants.PREFERENCES_KEYS.COMPATIBILITY_MODE_CHECKED, \"\" + checked);\n        }\n    }\n\n    get renderedBuffer() {\n        return this._renderedBuffer;\n    }\n\n    get order(): number {\n        return -1;\n    }\n\n    get id(): string {\n        return \"FilterManager\";\n    }\n}\n","import AbstractAudioElement from \"@/filters/interfaces/AbstractAudioElement\";\nimport Constants from \"@/model/Constants\";\nimport { EventType } from \"@/model/EventTypeEnum\";\nimport ReverbSettings from \"@/model/filtersSettings/ReverbSettings\";\nimport EventEmitter from \"@/utils/EventEmitter\";\nimport FilterManager from \"./FilterManager\";\nimport BufferFetcherService from \"@/services/BufferFetcherService\";\n\nexport default class BufferManager extends AbstractAudioElement {\n    \n    /** The filter manager */\n    private filterManager: FilterManager | undefined;\n    /** The current event emitter */\n    private eventEmitter: EventEmitter | undefined;\n    /** True if we are downloading initial buffer data */\n    downloadingInitialData = false;\n    /** List of audio buffers to fetch */\n    private audioBuffersToFetch: string[] = [];\n\n    constructor(bufferFetcherService: BufferFetcherService, filterManager: FilterManager, eventEmitter: EventEmitter | null, audioBuffersToFetch: string[]) {\n        super();\n\n        this.bufferFetcherService = bufferFetcherService;\n        this.eventEmitter = eventEmitter || new EventEmitter();\n        this.filterManager = filterManager;\n        this.filterManager = filterManager;\n        this.audioBuffersToFetch = audioBuffersToFetch;\n\n        this.setup();\n    }\n\n    private setup() {\n        if (this.audioBuffersToFetch.length > 0) {\n            this.fetchBuffers(false);\n        }\n    }\n\n    /**\n     * Fetch default buffers from network\n     * @param refetch true if we need to refetch the buffers\n     */\n    private async fetchBuffers(refetch: boolean) {\n        if (this.downloadingInitialData || !this.bufferFetcherService) {\n            return;\n        }\n\n        this.downloadingInitialData = true;\n\n        if (this.eventEmitter && !refetch) {\n            this.eventEmitter.emit(EventType.LOADING_BUFFERS);\n        }\n\n        try {\n            await this.bufferFetcherService.fetchAllBuffers(this.audioBuffersToFetch);\n            this.downloadingInitialData = false;\n\n            if (this.eventEmitter && !refetch) {\n                this.eventEmitter.emit(EventType.LOADED_BUFFERS);\n            }\n        } catch (e) {\n            if (this.eventEmitter && !refetch) {\n                this.eventEmitter.emit(EventType.LOADING_BUFFERS_ERROR);\n            }\n        }\n    }\n\n    /**\n     * Reset the buffer fetcher and redownload the buffers. Used when changing sample rate.\n     */\n    async resetBufferFetcher() {\n        if (this.bufferFetcherService) {\n            this.bufferFetcherService.reset();\n            await this.fetchBuffers(true);\n            // Fetch the current select environment for the reverb filter\n            await this.resetReverbFilterBuffer();\n        }\n    }\n\n    private async resetReverbFilterBuffer() {\n        if (this.filterManager) {\n            const filterSettings = this.filterManager.getFiltersSettings();\n            const reverbSettings = filterSettings.get(Constants.FILTERS_NAMES.REVERB);\n    \n            if (reverbSettings) {\n                const reverbUrl = (reverbSettings as ReverbSettings).reverbEnvironment?.value;\n    \n                if (reverbUrl && reverbUrl !== \"custom\" && this.bufferFetcherService) {\n                    await this.bufferFetcherService.fetchBuffer(reverbUrl);\n                }\n            }\n        }\n    }\n\n    get order(): number {\n        return -1;\n    }\n\n    get id(): string {\n        return \"BufferManager\";\n    }\n}\n","/*\n * Copyright (C) 2019-2023 Eliastik (eliastiksofts.com)\n *\n * This file is part of \"Simple Voice Changer\".\n *\n * \"Simple Voice Changer\" is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * \"Simple Voice Changer\" is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with \"Simple Voice Changer\".  If not, see <http://www.gnu.org/licenses/>.\n */\nexport default class TimerSaveTime {\n    seconds = 0;\n    initialSeconds = 0;\n    interval: number | null = null;\n    incr = 1;\n\n    private countCallback: () => void = () => {};\n\n    constructor(seconds: number, incr: number) {\n        this.seconds = seconds;\n        this.initialSeconds = seconds;\n        this.interval;\n        this.incr = incr;\n    }\n\n    start() {\n        this.interval = window.setInterval(() => this.count(), 1000);\n    }\n\n    stop() {\n        clearInterval(this.interval!);\n    }\n\n    count() {\n        this.seconds += this.incr;\n\n        if(this.seconds <= 0) {\n            this.stop();\n        }\n\n        if(this.countCallback) {\n            this.countCallback();\n        }\n    }\n\n    onCount(callback: () => void) {\n        this.countCallback = callback;\n    }\n}","import AbstractAudioElement from \"../filters/interfaces/AbstractAudioElement\";\nimport AbstractAudioFilter from \"../filters/interfaces/AbstractAudioFilter\";\nimport AbstractAudioRenderer from \"../filters/interfaces/AbstractAudioRenderer\";\nimport utils from \"../utils/Functions\";\nimport BufferPlayer from \"../BufferPlayer\";\nimport BufferFetcherService from \"../services/BufferFetcherService\";\nimport EventEmitter from \"../utils/EventEmitter\";\nimport { EventType } from \"../model/EventTypeEnum\";\nimport Constants from \"../model/Constants\";\nimport { ConfigService } from \"../services/ConfigService\";\nimport utilFunctions from \"../utils/Functions\";\nimport { FilterSettings } from \"../model/filtersSettings/FilterSettings\";\nimport { EventEmitterCallback } from \"../model/EventEmitterCallback\";\nimport { FilterState } from \"../model/FilterState\";\nimport GenericConfigService from \"../utils/GenericConfigService\";\nimport BufferDecoderService from \"../services/BufferDecoderService\";\nimport SaveBufferOptions from \"../model/SaveBufferOptions\";\nimport FilterManager from \"./FilterManager\";\nimport AudioContextManager from \"./AudioContextManager\";\nimport SaveBufferManager from \"./SaveBufferManager\";\nimport AudioProcessor from \"./AudioProcessor\";\nimport BufferManager from \"./BufferManager\";\n\nexport default class AudioEditor extends AbstractAudioElement {\n\n    /** The filter manager */\n    private filterManager: FilterManager | undefined;\n    /** The context manager */\n    private contextManager: AudioContextManager | undefined;\n    /** The save buffer manager */\n    private saveBufferManager: SaveBufferManager | undefined;\n    /** The save buffer manager */\n    private audioProcessor: AudioProcessor | undefined;\n    /** The save buffer manager */\n    private bufferManager: BufferManager | undefined;\n\n    /** The audio buffer to be processed */\n    private principalBuffer: AudioBuffer | null = null;\n    /** The audio player */\n    private bufferPlayer: BufferPlayer | undefined;\n    /** The event emitter */\n    private eventEmitter: EventEmitter | undefined;\n\n    constructor(context?: AudioContext | null, player?: BufferPlayer, eventEmitter?: EventEmitter, configService?: ConfigService, audioBuffersToFetch?: string[]) {\n        super();\n\n        this.eventEmitter = eventEmitter || new EventEmitter();\n        this.configService = configService || new GenericConfigService();\n\n        this.contextManager = new AudioContextManager(context, this.configService, this.eventEmitter);\n\n        this.bufferPlayer = player || new BufferPlayer(this.contextManager, this.eventEmitter);\n        this.bufferFetcherService = new BufferFetcherService(this.contextManager, this.configService, this.eventEmitter);\n        this.bufferDecoderService = new BufferDecoderService(this.contextManager, this.eventEmitter);\n\n        this.filterManager = new FilterManager(this.eventEmitter, this.bufferFetcherService, this.bufferDecoderService, this.configService);\n        this.saveBufferManager = new SaveBufferManager(this.contextManager, this.configService, this.eventEmitter, this.bufferPlayer);\n        this.bufferManager = new BufferManager(this.bufferFetcherService, this.filterManager, this.eventEmitter, audioBuffersToFetch || []);\n        this.audioProcessor = new AudioProcessor(this.contextManager, this.configService, this.eventEmitter, this.bufferPlayer, this.filterManager, this.bufferManager);\n\n        // Callback called just before starting audio player\n        this.setup();\n    }\n\n    private setup() {\n        if (this.bufferPlayer) {\n            // Callback called just before starting playing audio, when compatibility mode is enabled\n            this.bufferPlayer.onBeforePlaying(async () => {\n                if (this.bufferPlayer && this.bufferPlayer.compatibilityMode\n                    && this.contextManager && this.contextManager.currentContext && this.audioProcessor) {\n                    await this.audioProcessor.setupOutput(this.principalBuffer, this.contextManager.currentContext);\n                }\n            });\n\n            // Callback called when playing is finished\n            this.bufferPlayer.on(EventType.PLAYING_FINISHED, () => {\n                if (this.bufferPlayer && this.bufferPlayer.loop) {\n                    this.bufferPlayer.start();\n                }\n            });\n\n            this.bufferPlayer.contextManager = this.contextManager;\n        }\n    }\n\n    /**\n     * Add a new custom filter for this audio editor\n     * @param filters One or more AbstractAudioFilter\n     */\n    addFilters(...filters: AbstractAudioFilter[]) {\n        if (this.filterManager) {\n            this.filterManager.addFilters(...filters);\n        }\n    }\n\n    /**\n     * Add a new custom renderer for this audio editor\n     * @param renderers One or more AbstractAudioRenderer\n     */\n    addRenderers(...renderers: AbstractAudioRenderer[]) {\n        if (this.filterManager) {\n            this.filterManager.addRenderers(...renderers);\n        }\n    }\n\n    /**\n     * Get the current sample rate used\n     */\n    get currentSampleRate(): number {\n        if (this.contextManager) {\n            return this.contextManager.currentSampleRate;\n        }\n\n        return 0;\n    }\n\n    /**\n     * Get the default device sample rate\n     */\n    get defaultDeviceSampleRate(): number {\n        const tempContext = new AudioContext();\n        let sampleRate = 0;\n\n        if (tempContext) {\n            sampleRate = tempContext.sampleRate;\n            tempContext.close();\n        }\n\n        return sampleRate;\n    }\n\n    /** Decode and load an audio buffer from an audio file */\n    async loadBufferFromFile(file: File) {\n        this.principalBuffer = null;\n\n        if (this.audioProcessor) {\n            await this.audioProcessor.prepareContext(this.principalBuffer);\n        }\n\n        if (this.contextManager && this.contextManager.currentContext && this.bufferDecoderService && this.audioProcessor) {\n            this.principalBuffer = await this.bufferDecoderService.decodeBufferFromFile(file);\n            this.audioProcessor.initialRenderingDone = false;\n\n            if (this.principalBuffer) {\n                this.audioProcessor.sumPrincipalBuffer = utils.sumAudioBuffer(this.principalBuffer);\n            } else {\n                throw new Error(\"Error decoding audio file\");\n            }\n\n            utilFunctions.resetAudioRenderingProgress(this.eventEmitter);\n        } else {\n            throw new Error(\"Audio Context is not ready!\");\n        }\n    }\n\n    /** Change the principal audio buffer of this editor */\n    loadBuffer(audioBuffer: AudioBuffer) {\n        this.principalBuffer = audioBuffer;\n\n        if (this.audioProcessor) {\n            this.audioProcessor.sumPrincipalBuffer = utils.sumAudioBuffer(this.principalBuffer);\n            this.audioProcessor.initialRenderingDone = false;\n        }\n    }\n\n    /**\n     * Get the rendered audio buffer\n     * @returns The AudioBuffer\n     */\n    getOutputBuffer() {\n        if (this.audioProcessor) {\n            return this.audioProcessor.renderedBuffer;\n        }\n\n        return null;\n    }\n\n    /**\n     * Render the audio to a buffer\n     * @returns A promise resolved when the audio processing is finished.\n     * The promise return false if the audio processing was cancelled or if an error occurred.\n     * The resulting audio buffer can then be obtained by using the \"getOutputBuffer\" method.\n     */\n    async renderAudio(): Promise<boolean> {\n        if (this.audioProcessor) {\n            return await this.audioProcessor.renderAudio(this.principalBuffer);\n        }\n\n        return false;\n    }\n\n    /**\n     * Check if AudioWorklet are available\n     * @returns boolean\n     */\n    isAudioWorkletAvailable(): boolean {\n        if (this.contextManager && this.contextManager.currentContext) {\n            return utilFunctions.isAudioWorkletCompatible(this.contextManager.currentContext);\n        }\n\n        return false;\n    }\n\n    /** Filters settings */\n\n    /**\n     * Get enabled/disabled state of all filters/renderers\n     * @returns The filters state (enabled/disabled)\n     */\n    getFiltersState(): FilterState {\n        if (this.filterManager) {\n            return this.filterManager.getFiltersState();\n        }\n\n        return {};\n    }\n\n    /**\n     * Get the settings of all filters/renderers\n     * @returns \n     */\n    getFiltersSettings(): Map<string, FilterSettings> {\n        if (this.filterManager) {\n            return this.filterManager.getFiltersSettings();\n        }\n\n        return new Map();\n    }\n\n    /** Reconnect the nodes if the compatibility/direct mode is enabled */\n    async reconnectNodesIfNeeded() {\n        if (this.contextManager && this.bufferPlayer && this.bufferPlayer.compatibilityMode &&\n            this.contextManager.currentContext && this.principalBuffer &&\n            this.filterManager && this.filterManager.entrypointFilter) {\n            await this.filterManager.connectNodes(this.contextManager.currentContext, this.principalBuffer, true, this.bufferPlayer.compatibilityMode);\n\n            const speedAudio = this.filterManager.entrypointFilter.getSpeed();\n            this.bufferPlayer.speedAudio = speedAudio;\n            this.bufferPlayer.duration = utilFunctions.calculateAudioDuration(this.principalBuffer, this.filterManager, speedAudio) * speedAudio;\n        }\n    }\n\n    /**\n     * Toggle enabled/disabled state for a filter/renderer\n     * @param filterId The filter/renderer ID\n     */\n    toggleFilter(filterId: string) {\n        if (this.filterManager && this.contextManager && this.contextManager.currentContext && this.principalBuffer) {\n            this.filterManager.toggleFilter(filterId);\n            this.reconnectNodesIfNeeded();\n        }\n    }\n\n    /**\n     * Change a filter/renderer setting\n     * @param filterId Filter ID\n     * @param settings Filter setting (key/value)\n     */\n    async changeFilterSettings(filterId: string, settings: FilterSettings) {\n        if (this.filterManager && this.contextManager && this.contextManager.currentContext && this.principalBuffer) {\n            await this.filterManager.changeFilterSettings(filterId, settings);\n            await this.reconnectNodesIfNeeded();\n        }\n    }\n\n    /**\n     * Reset the settings of a filter/renderer\n     * @param filterId Id of the filter/renderer\n     */\n    async resetFilterSettings(filterId: string) {\n        if (this.filterManager && this.contextManager && this.contextManager.currentContext && this.principalBuffer) {\n            await this.filterManager.resetFilterSettings(filterId);\n            await this.reconnectNodesIfNeeded();\n        }\n    }\n\n    /**\n     * Reset all filters/renderers state (enabled/disabled) based on their default states\n     */\n    resetAllFiltersState() {\n        if (this.filterManager && this.contextManager && this.contextManager.currentContext && this.principalBuffer) {\n            this.filterManager.resetAllFiltersState();\n            this.reconnectNodesIfNeeded();\n        }\n    }\n\n    /** Events and exit */\n\n    /**\n     * Exit/reset the audio editor basic state\n     */\n    exit() {\n        if (this.bufferPlayer) {\n            this.bufferPlayer.stop();\n            this.bufferPlayer.reset();\n        }\n        \n        this.cancelAudioRendering();\n        this.principalBuffer = null;\n    }\n    \n    /**\n     * Cancel the audio rendering\n     */\n    cancelAudioRendering() {\n        if (this.audioProcessor) {\n            this.audioProcessor.cancelAudioRendering();\n        }\n    }\n\n    /**\n     * Subscribe to an event\n     * @param event The event ID\n     * @param callback The callback function\n     */\n    on(event: string, callback: EventEmitterCallback) {\n        if (this.eventEmitter) {\n            this.eventEmitter.on(event, callback);\n        }\n    }\n\n    /**\n     * Unsubscribe to an event\n     * @param event The event ID\n     * @param callback The callback function\n     */\n    off(event: string, callback: EventEmitterCallback) {\n        if (this.eventEmitter) {\n            this.eventEmitter.off(event, callback);\n        }\n    }\n\n    /**\n     * Save the rendered audio to a buffer\n     * @param options The save options\n     * @returns A promise resolved when the audio buffer is downloaded to the user\n     */\n    async saveBuffer(options?: SaveBufferOptions): Promise<boolean> {\n        if (this.saveBufferManager && this.audioProcessor) {\n            return await this.saveBufferManager?.saveBuffer(this.audioProcessor.renderedBuffer, options);\n        }\n\n        return false;\n    }\n\n    get order(): number {\n        return -1;\n    }\n\n    get id(): string {\n        return Constants.AUDIO_EDITOR;\n    }\n\n    set downloadingInitialData(state: boolean) {\n        if (this.bufferManager) {\n            this.bufferManager.downloadingInitialData = state;\n        }\n    }\n\n    get downloadingInitialData(): boolean {\n        if (this.bufferManager) {\n            return this.bufferManager.downloadingInitialData;\n        }\n\n        return false;\n    }\n\n    isEnabled(): boolean {\n        return true;\n    }\n}\n","\n/*\n * Copyright (C) 2019-2023 Eliastik (eliastiksofts.com)\n *\n * This file is part of \"Simple Voice Changer\".\n *\n * \"Simple Voice Changer\" is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * \"Simple Voice Changer\" is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with \"Simple Voice Changer\".  If not, see <http://www.gnu.org/licenses/>.\n */\n// The Voice Recorder class\n// Used to record a sound (voice, etc.) with the user microphone\n// Offer control with play/pause and audio feedback\nimport TimerSaveTime from \"./utils/TimerSaveTime\";\nimport EventEmitter from \"./utils/EventEmitter\";\nimport { EventType } from \"./model/EventTypeEnum\";\nimport AudioConstraintWrapper from \"./model/AudioConstraintWrapper\";\nimport { RecorderSettings } from \"./model/RecorderSettings\";\nimport { ConfigService } from \"./services/ConfigService\";\nimport AbstractAudioElement from \"./filters/interfaces/AbstractAudioElement\";\nimport Constants from \"./model/Constants\";\nimport { EventEmitterCallback } from \"./model/EventEmitterCallback\";\nimport { AudioConstraint } from \"./model/AudioConstraint\";\nimport Recorder from \"./recorder/Recorder\";\n\nexport default class VoiceRecorder extends AbstractAudioElement {\n\n    private context: AudioContext | null | undefined;\n    private input: MediaStreamAudioSourceNode | null = null;\n    private stream: MediaStream | null = null;\n    private recorder: Recorder | null = null;\n    private alreadyInit = false;\n    private timer: TimerSaveTime | null = null;\n    private enableAudioFeedback = false;\n    private recording = false;\n    private deviceList: MediaDeviceInfo[] = [];\n    private constraints: AudioConstraintWrapper = {\n        audio: {\n            noiseSuppression: true,\n            echoCancellation: true,\n            autoGainControl: true,\n            sampleRate: { ideal: 44100 }\n        }\n    };\n    private eventEmitter: EventEmitter | null = null;\n    private previousSampleRate = Constants.DEFAULT_SAMPLE_RATE;\n    private sampleRateConfigNotSupported = false;\n\n    constructor(context?: AudioContext | null, eventEmitter?: EventEmitter, configService?: ConfigService) {\n        super();\n        this.context = context;\n        this.eventEmitter = eventEmitter || new EventEmitter();\n        this.configService = configService || null;\n\n        if (this.configService) {\n            this.previousSampleRate = this.configService.getSampleRate();\n        }\n    }\n\n    /** Initialize this voice recorder */\n    async init() {\n        if (!this.isRecordingAvailable()) {\n            return;\n        }\n\n        // Specific case: Firefox doesn't support changing sample-rate for MediaDevice API\n        // In this case we disable sample-rate config feature for this VoiceRecorder\n        this.sampleRateConfigNotSupported = !navigator.mediaDevices.getSupportedConstraints().sampleRate;\n\n        if (!this.context) {\n            await this.createNewContext(this.previousSampleRate);\n        } else {\n            await this.createNewContextIfNeeded();\n        }\n\n        this.eventEmitter?.emit(EventType.RECORDER_INIT);\n\n        try {\n            const stream = await navigator.mediaDevices.getUserMedia(this.constraints);\n\n            if (this.context) {\n                this.context.resume();\n            }\n\n            await this.setup(stream, false, false);\n\n            this.alreadyInit = true;\n            this.timer = new TimerSaveTime(0, 1);\n\n            this.timer.onCount(() => {\n                this.eventEmitter?.emit(EventType.RECORDER_COUNT_UPDATE);\n            });\n\n            this.successCallback();\n        } catch (e) {\n            console.error(e);\n\n            const exception = e as DOMException;\n\n            if (exception) {\n                switch (exception.name) {\n                case \"SecurityError\":\n                case \"NotAllowedError\":\n                    this.errorCallback();\n                    break;\n                case \"NotFoundError\":\n                    this.notFoundErrorCallback();\n                    break;\n                // Disable sample rate configuration\n                case \"NotSupportedError\":\n                    if (!this.sampleRateConfigNotSupported) {\n                        this.previousSampleRate = 0;\n                        this.sampleRateConfigNotSupported = true;\n                        this.init();\n                    }\n                    break;\n                default:\n                    this.unknownErrorCallback();\n                    break;\n                }\n            }\n        }\n\n        navigator.mediaDevices.ondevicechange = () => this.updateInputList();\n    }\n\n    /**\n     * Create new context if needed, for example if sample rate setting have changed\n     */\n    private async createNewContextIfNeeded() {\n        let currentSampleRate = Constants.DEFAULT_SAMPLE_RATE;\n\n        if (this.configService) {\n            currentSampleRate = this.configService.getSampleRate();\n        }\n\n        // If sample rate setting has changed, create a new audio context\n        if (currentSampleRate != this.previousSampleRate) {\n            await this.createNewContext(currentSampleRate);\n            this.previousSampleRate = currentSampleRate;\n        }\n    }\n\n    /** \n     * Stop previous audio context and create a new one\n     */\n    private async createNewContext(sampleRate: number) {\n        if (this.context) {\n            await this.context.close();\n        }\n\n        const options: AudioContextOptions = {\n            latencyHint: \"balanced\"\n        };\n\n        if (sampleRate != 0 && !this.sampleRateConfigNotSupported) {\n            options.sampleRate = sampleRate;\n        }\n\n        this.context = new AudioContext(options);\n        this.constraints.audio.sampleRate = { ideal: this.context.sampleRate };\n    }\n\n    private successCallback() {\n        this.eventEmitter?.emit(EventType.RECORDER_SUCCESS);\n    }\n\n    private errorCallback() {\n        this.eventEmitter?.emit(EventType.RECORDER_ERROR);\n    }\n\n    private notFoundErrorCallback() {\n        this.eventEmitter?.emit(EventType.RECORDER_NOT_FOUND_ERROR);\n    }\n\n    private unknownErrorCallback() {\n        this.eventEmitter?.emit(EventType.RECORDER_UNKNOWN_ERROR);\n    }\n\n    /**\n     * Enable or disable audio feedback\n     * @param enable boolean\n     */\n    audioFeedback(enable: boolean) {\n        if (this.context) {\n            if (enable) {\n                this.input && this.input.connect(this.context.destination);\n                this.enableAudioFeedback = true;\n            } else {\n                this.input && this.input.connect(this.context.destination) && this.input.disconnect(this.context.destination);\n                this.enableAudioFeedback = false;\n            }\n\n            this.eventEmitter?.emit(EventType.RECORDER_UPDATE_CONSTRAINTS);\n        }\n    }\n\n    /**\n     * Get current constraints/settings\n     * @returns MediaTrackSettings\n     */\n    private getConstraints() {\n        if (this.stream) {\n            const tracks = this.stream.getTracks();\n\n            if (tracks && tracks.length > 0) {\n                return tracks[0].getSettings();\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Update the current constraints\n     */\n    private updateConstraints() {\n        const constraints = this.getConstraints();\n\n        if (constraints) {\n            this.constraints.audio = Object.assign(this.constraints.audio, constraints);\n            this.eventEmitter?.emit(EventType.RECORDER_UPDATE_CONSTRAINTS);\n        }\n    }\n\n    /**\n     * Reset the current constraints\n     * @param newConstraint AudioConstraintWrapper\n     */\n    private async resetConstraints(newConstraint?: AudioConstraintWrapper) {\n        if (this.stream) {\n            const precAudioFeedback = this.enableAudioFeedback;\n            const precRecording = this.recording;\n            const tracks = this.stream.getTracks();\n\n            if (newConstraint) {\n                this.updateConstraints();\n                this.constraints.audio = Object.assign(this.constraints.audio, newConstraint.audio);\n            }\n\n            if (tracks && tracks.length > 0) {\n                try {\n                    await tracks[0].applyConstraints(this.constraints.audio);\n\n                    const newConstraints = this.getConstraints();\n                    const newConstraintName = newConstraint ? Object.keys(newConstraint.audio)[0] : \"\";\n\n                    this.audioFeedback(false);\n                    this.pause();\n\n                    if (!newConstraint ||\n                        (newConstraints && (newConstraints as AudioConstraint)[newConstraintName] != newConstraint.audio[newConstraintName])) {\n                        this.stopStream();\n\n                        const stream = await navigator.mediaDevices.getUserMedia(this.constraints);\n\n                        await this.setup(stream, precRecording, precAudioFeedback);\n                    } else {\n                        await this.setup(null, precRecording, precAudioFeedback);\n                    }\n                } catch (e) {\n                    this.errorCallback();\n                }\n            }\n        }\n    }\n\n    /**\n     * Setup this voice recorder\n     * @param stream MediaStream\n     * @param precRecording Was recording?\n     * @param precAudioFeedback Has audio feedback?\n     */\n    private async setup(stream: MediaStream | null, precRecording: boolean, precAudioFeedback: boolean) {\n        if (stream && this.context) {\n            this.input = this.context.createMediaStreamSource(stream);\n            this.stream = stream;\n        }\n\n        if (this.recorder && this.input) {\n            await this.recorder.setup(this.input);\n\n            if (precRecording) {\n                await this.record();\n            }\n        }\n\n        this.audioFeedback(precAudioFeedback);\n        this.updateConstraints();\n        await this.updateInputList();\n    }\n\n    /**\n     * Enable/disable noise suppression\n     * @param enable boolean\n     */\n    setNoiseSuppression(enable: boolean) {\n        this.resetConstraints({\n            audio: {\n                noiseSuppression: enable\n            }\n        });\n    }\n\n    /**\n     * Enable/disable auto gain\n     * @param enable boolean\n     */\n    setAutoGain(enable: boolean) {\n        this.resetConstraints({\n            audio: {\n                autoGainControl: enable\n            }\n        });\n    }\n\n    /**\n     * Enable/disable echo cancellation\n     * @param enable boolean\n     */\n    setEchoCancellation(enable: boolean) {\n        this.resetConstraints({\n            audio: {\n                echoCancellation: enable\n            }\n        });\n    }\n\n    /**\n     * Update current audio input list\n     */\n    private async updateInputList() {\n        if (this.deviceList) {\n            const devices = await navigator.mediaDevices.enumerateDevices();\n            this.deviceList = [];\n\n            devices.forEach(device => {\n                if (device.kind == \"audioinput\") {\n                    this.deviceList.push(device);\n                }\n            });\n        }\n    }\n\n    /**\n     * Change audio input\n     * @param deviceId Device ID\n     * @param groupId Group ID (optional)\n     */\n    changeInput(deviceId: string, groupId: string | undefined) {\n        if (groupId) {\n            this.constraints.audio.deviceId = deviceId;\n            this.constraints.audio.groupId = groupId;\n            this.resetConstraints();\n        }\n    }\n\n    /**\n     * Start audio recording\n     */\n    async record() {\n        if (this.alreadyInit && this.configService && this.input) {\n            if (!this.recorder) {\n                this.recorder = new Recorder({\n                    bufferLen: this.configService.getBufferSize(),\n                    sampleRate: this.configService.getSampleRate(),\n                    numChannels: 2,\n                    workletBasePath: this.configService.getWorkletBasePath(),\n                    workerBasePath: this.configService.getWorkerBasePath(),\n                    mimeType: \"audio/wav\"\n                });\n\n                await this.recorder.setup(this.input);\n            }\n\n            if (this.recorder) {\n                this.recorder.record();\n            }\n\n            this.timer && this.timer.start();\n            this.recording = true;\n\n            if (this.eventEmitter) {\n                this.eventEmitter.emit(EventType.RECORDER_RECORDING);\n            }\n        }\n    }\n\n    /**\n     * Stop audio recording\n     */\n    async stop() {\n        if (this.alreadyInit && this.recorder) {\n            this.recorder.stop();\n            this.timer && this.timer.stop();\n            this.recording = false;\n\n            this.recorder.getBuffer((buffer: Float32Array[]) => {\n                if (this.context) {\n                    this.context.resume();\n\n                    const newBuffer = this.context.createBuffer(2, buffer[0].length, this.context.sampleRate);\n                    newBuffer.getChannelData(0).set(buffer[0]);\n                    newBuffer.getChannelData(1).set(buffer[1]);\n\n                    this.eventEmitter?.emit(EventType.RECORDER_STOPPED, newBuffer);\n                    this.reset();\n                }\n            });\n        }\n    }\n\n    /**\n     * Pause audio recording\n     */\n    pause() {\n        if (this.alreadyInit) {\n            this.recorder && this.recorder.stop();\n            this.timer && this.timer.stop();\n            this.recording = false;\n            this.eventEmitter?.emit(EventType.RECORDER_PAUSED);\n        }\n    }\n\n    /**\n     * Stop stream\n     */\n    private stopStream() {\n        if (this.stream) {\n            const tracks = this.stream.getTracks();\n\n            for (let i = 0, l = tracks.length; i < l; i++) {\n                tracks[i].stop();\n            }\n        }\n    }\n\n    /**\n     * Reset this voice recorder\n     */\n    reset() {\n        this.recorder && this.recorder.kill();\n        this.timer && this.timer.stop();\n        this.audioFeedback(false);\n\n        this.stopStream();\n\n        this.input = null;\n        this.recorder = null;\n        this.stream = null;\n        this.alreadyInit = false;\n        this.timer = null;\n\n        this.eventEmitter?.emit(EventType.RECORDER_RESETED);\n    }\n\n    /**\n     * Get current recording time in text format\n     */\n    get currentTimeDisplay() {\n        return this.timer?.seconds ? (\"0\" + Math.trunc(this.timer?.seconds / 60)).slice(-2) + \":\" + (\"0\" + Math.trunc(this.timer?.seconds % 60)).slice(-2) : \"00:00\";\n    }\n\n    /**\n     * Get current recording time in seconds\n     */\n    get currentTime() {\n        return this.timer ? this.timer.seconds : 0;\n    }\n\n    /**\n     * Get the current settings for this voice recorder\n     * @returns RecorderSettings\n     */\n    getSettings(): RecorderSettings {\n        return {\n            deviceList: this.deviceList,\n            audioFeedback: this.enableAudioFeedback,\n            constraints: this.constraints.audio\n        };\n    }\n\n    /**\n     * Observe an event\n     * @param event The event name\n     * @param callback Callback called when an event of this type occurs\n     */\n    on(event: string, callback: EventEmitterCallback) {\n        this.eventEmitter?.on(event, callback);\n    }\n\n    /**\n     * Check if browser is compatible with audio recording\n     * @returns boolean\n     */\n    isRecordingAvailable() {\n        return typeof (navigator.mediaDevices) !== \"undefined\" && typeof (navigator.mediaDevices.getUserMedia) !== \"undefined\";\n    }\n\n    get order(): number {\n        return -1;\n    }\n\n    get id(): string {\n        throw Constants.VOICE_RECORDER;\n    }\n}\n"],"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","SuppressedError","AbstractAudioElement","constructor","this","enabled","defaultEnabled","bufferFetcherService","bufferDecoderService","configService","isEnabled","isDefaultEnabled","setDefaultEnabled","state","setEnabled","enable","disable","toggle","EventType","utilFunctions","calcAudioDuration","audio","speed","duration","loadAudioBuffer","context","file","arrayBuffer","readAsArrayBufferPromisified","audioBuffer","decodeAudioData","decodeBuffer","reader","FileReader","onload","ev","_a","target","ArrayBuffer","readAsArrayBuffer","buffer","numberOfChannels","resume","sampleRate","newBuffer","createBuffer","sourceChannelData","getChannelData","channel0Data","channel1Data","i","length","convertAudioBufferToFloat32Array","array","channel","push","convertAudioParamToFloat32Array","param","Float32Array","set","sumAudioBufferChannel","reduce","a","b","sumAudioBuffer","sum","isAudioWorkletCompatible","audioContext","isSettingValueValid","isNaN","Number","trim","calculateAudioDuration","filterManager","speedAudio","getAddingTime","resetAudioRenderingProgress","eventEmitter","emit","UPDATE_AUDIO_TREATMENT_PERCENT","UPDATE_REMAINING_TIME_ESTIMATED","EventEmitter","listeners","on","event","callback","data","forEach","off","filter","cb","Constants","AUDIO_EDITOR","VOICE_RECORDER","BUFFER_PLAYER","EXPORT_WAV_COMMAND","EXPORT_MP3_COMMAND","AUDIO_WAV","AUDIO_MP3","RECORD_COMMAND","INIT_COMMAND","FILTERS_NAMES","REVERB","ECHO","BASS_BOOST","BITCRUSHER","HIGH_PASS","LIMITER","LOW_PASS","PASSTHROUGH","RETURN_AUDIO","SOUNDTOUCH","TELEPHONIZER","VOCODER","WORKLET_PATHS","RECORDER_WORKLET","WORKLET_NAMES","PREFERENCES_KEYS","COMPATIBILITY_MODE_ENABLED","COMPATIBILITY_MODE_CHECKED","ENABLE_AUDIO_WORKLET","ENABLE_SOUNDTOUCH_AUDIO_WORKLET","BUFFER_SIZE","SAMPLE_RATE","DISABLE_INITIAL_RENDERING","BITRATE_MP3","ENABLE_RECORDER_AUDIO_WORKLET","SOUNDTOUCH_PITCH_SHIFTER_BUFFER_SIZE","DEFAULT_REVERB_ENVIRONMENT","name","url","size","addDuration","link","VOCODER_MODULATOR","DEFAULT_BUFFER_SIZE","VALID_BUFFER_SIZE","VALID_MP3_BITRATES","DEFAULT_SAMPLE_RATE","VALID_SAMPLE_RATES","TREATMENT_TIME_COUNTING_THROTTLE_INTERVAL","TREATMENT_TIME_COUNTING_SMOOTHING_FACTOR","DEFAULT_SAVE_FORMAT","DEFAULT_MP3_BITRATE","BufferPlayer","contextManager","super","source","currentTime","displayTime","intervals","playing","loop","onBeforePlayingCallback","compatibilityMode","currentNode","_contextManager","init","direct","currentContext","disconnect","createBufferSource","connect","destination","updateInfos","loadBuffer","reset","setCompatibilityMode","clearIntervals","stop","undefined","PLAYING_STOPPED","interval","clearInterval","start","PLAYING_STARTED","startTime","performance","now","window","setInterval","timeNow","nextTime","PLAYING_FINISHED","_b","playDirect","pause","PLAYING_UPDATE","setTimePercent","percent","Math","round","setTime","time","onBeforePlaying","toggleLoop","currentTimeDisplay","trunc","slice","maxTimeDisplay","remainingTimeDisplay","order","id","BufferFetcherService","buffers","Map","bufferErrors","fetchBuffer","bufferURI","force","realBufferURI","getSoundBasePath","get","getKeyFromLocation","FETCHING_BUFFERS","response","fetch","ok","FETCHING_BUFFERS_ERROR","_c","FINISHED_FETCHING_BUFFERS","_d","fetchAllBuffers","bufferURIs","uri","getAudioBuffer","filename","getOrFetchAudioBuffer","getDownloadedBuffersList","Array","from","keys","location","substring","lastIndexOf","clear","GenericConfigService","mapConfig","getConfig","key","setConfig","isCompatibilityModeEnabled","isCompatibilityModeChecked","isAudioWorkletEnabled","setting","isSoundtouchAudioWorkletEnabled","getBufferSize","parseInt","getSampleRate","getBitrateMP3","enableCompatibilityMode","disableCompatibilityMode","getWorkletBasePath","getWorkerBasePath","isInitialRenderingDisabled","BufferDecoderService","decodeBufferFromFile","DECODING_AUDIO_FILE","DECODED_AUDIO_FILE","console","error","ERROR_DECODING_AUDIO_FILE","AbstractAudioFilter","defaultSettings","initializeDefaultSettings","getSettings","getDefaultSettings","resetSettings","setSetting","isWorklet","BassBoosterFilter","frequencyBooster","dbBooster","frequencyReduce","dbReduce","getNode","bassBoostFilter","createBiquadFilter","type","frequency","gain","bassBoostFilterHighFreq","input","output","settingId","AudioParamPolyfill","defaultValue","_value","_minValue","_maxValue","MAX_SAFE_INTEGER","_defaultValue","automationRate","newValue","max","min","minValue","maxValue","setValueAtTime","warn","linearRampToValueAtTime","endTime","exponentialRampToValueAtTime","cancelAndHoldAtTime","cancelTime","Error","cancelScheduledValues","setTargetAtTime","timeConstant","setValueCurveAtTime","values","WorkletScriptProcessorNodeAdapter","node","bufferSize","_parameters","_port","workletProcessor","_scriptProcessorNode","createScriptProcessor","setupPort","setupProcessor","setupWorkletScope","messageChannel","MessageChannel","port1","onmessage","port2","postMessage","onaudioprocess","inputArray","Functions","inputBuffer","ouputArray","outputBuffer","records","entries","recordsMap","Object","fromEntries","process","descriptors","defaultParameterDescriptors","descriptor","port","parameters","RegisterProcessorPolyfill","registerProcessor","processorName","processorClass","processorsMap","getProcessor","processor","SimpleAudioWorkletProcessor","inputs","outputs","parameterDescriptors","AudioWorkletProcessor","global","AbstractAudioFilterWorklet","currentWorkletNode","fallbackToScriptProcessor","keepCurrentNodeIfPossible","initializeWorklet","workletPath","audioWorklet","addModule","catch","initializeNode","workletName","AudioWorkletNode","message","receiveEvent","applyCurrentSettingsToWorklet","currentSettings","settingKey","settingFromWorklet","BitCrusherProcessor","stopped","phaser","last","pow","bits","currentNormFreq","normFreq","fill","blockSize","inp","out","floor","parseFloat","EchoFilter","delay","delayNode","createDelay","delayTime","gainNode","createGain","HighPassFilter","highFrequency","highPassFilter","DelayBuffer","n","_array","readPointer","writePointer","read","v","LimiterProcessor","delayBuffer","envelopeSample","disabled","getEnvelope","attackTime","releaseTime","attackGain","exp","releaseGain","envelope","envIn","abs","getMaxEnvelope","channels","index","ampToDB","log10","dBToAmp","db","envelopeData","postGainAmp","postGain","preGainAmp","preGain","lookAheadTime","k","slope","gainDB","threshold","LimiterFilter","LowPassFilter","lowFrequency","lowPassFilter","AbstractAudioRenderer","ReturnAudioRenderer","renderAudio","numChannels","totalFrames","bufferReturned","nowBuffering","ReverbFilter","reverbEnvironment","reverbCustomEnvironmentAddTime","customEnvironment","convolver","createConvolver","getReverbBuffer","settings","additionalData","downloadedBuffers","hasCustomEnvironment","FifoSampleBuffer","_vector","_position","_frameCount","vector","position","startIndex","frameCount","endIndex","receive","rewind","put","numFrames","putSamples","samples","sourceOffset","numSamples","ensureCapacity","destOffset","subarray","putBuffer","receiveSamples","extract","minLength","newVector","ensureAdditionalCapacity","AbstractFifoSamplePipe","createBuffers","_inputBuffer","_outputBuffer","RateTransposer","_rate","rate","slopeCount","prevSampleL","prevSampleR","clone","numFramesOutput","transpose","src","srcOffset","dest","used","srcIndex","FilterSupport","pipe","_pipe","fillInputBuffer","fillOutputBuffer","numInputFrames","noop","SimpleFilter","sourceSound","historyBufferSize","_sourcePosition","outputBufferPosition","RangeError","newOutputBufferPosition","sourcePosition","onEnd","numFramesExtracted","currentFrames","handleSampleData","_SCAN_OFFSETS","AUTOSEEK_K","Stretch","_quickSeek","midBufferDirty","midBuffer","overlapLength","autoSeqSetting","autoSeekSetting","_tempo","setParameters","clearMidBuffer","sequenceMs","seekWindowMs","overlapMs","calculateSequenceParameters","calculateOverlapLength","tempo","newTempo","intskip","nominalSkip","seekWindowLength","skipFract","sampleReq","seekLength","inputChunkSize","outputChunkSize","overlapInMsec","newOvl","refMidBuffer","checkLimits","x","mi","ma","seq","seek","AUTOSEQ_AT_MIN","AUTOSEEK_AT_MIN","quickSeek","seekBestOverlapPosition","seekBestOverlapPositionStereoQuick","seekBestOverlapPositionStereo","bestOffset","bestCorrelation","correlation","preCalculateCorrelationReferenceStereo","MIN_VALUE","calculateCrossCorrelationStereo","correlationOffset","tempOffset","scanCount","j","temp","mixingPosition","compare","mixing","calcLength","mixingOffset","overlap","overlapPosition","overlapStereo","inputPosition","outputPosition","tempFrame","frameScale","fi","inputOffset","outputOffset","offset","overlapSkip","testFloatEqual","SoundTouch","transposer","stretch","_intermediateBuffer","virtualPitch","virtualRate","virtualTempo","calculateEffectiveRateAndTempo","rateChange","tempoChange","pitch","pitchOctaves","pitchSemitones","previousTempo","previousRate","WebAudioBufferSource","dualChannel","left","right","minsSecs","secs","mins","width","z","join","onUpdate","currentTimePlayed","timePlayed","CustomEvent","detail","formattedTimePlayed","percentagePlayed","_node","dispatchEvent","PitchShifter","_soundtouch","_filter","sourcePositionCallback","framesExtracted","getWebAudioNode","sourcePostion","call","formattedDuration","perc","semitone","toNode","eventName","addEventListener","removeEventListener","soundtouchWrapperFilterWorkletNodeClass","options","running","_pitch","updateInterval","processorOptions","setup","status","args","messageProcessor","bind","command","SoundtouchWrapperFilterWorkletNode","SoundtouchWrapperFilter","frequencyAudio","currentSpeedAudio","isOfflineMode","constructAudioWorkletProcessor","getEntrypointNode","offline","cleanUpOldNodes","bufferSource","utils","renderWithWorklet","renderWithScriptProcessorNode","currentPitchShifter","getSoundtouchScriptProcessorNode","updateState","currentPitchShifterWorklet","durationAudio","offlineContext","OfflineAudioContext","renderedBuffer","startRendering","bufferSourceRendered","bypass","recording","nInputFrames","approximateNInputFrames","getCurrentPitchShifter","pitchShifter","valueFloat","getSpeed","BitCrusherFilter","lpf1","lpf2","hpf1","hpf2","Vocoder","ctx","carrierB","modulatorB","FILTER_QUALITY","FOURIER_SIZE","WAVETABLEBOOST","SAWTOOTHBOOST","oscillatorType","oscillatorDetuneValue","carrierBuffer","modulatorNode","vocoding","modulatorInput","carrierInput","modulatorGain","modulatorGainValue","noiseBuffer","noiseNode","noiseGain","noiseGainValue","carrierSampleNode","carrierSampleGain","carrierSampleGainValue","oscillatorNode","oscillatorGain","oscillatorGainValue","wavetable","wavetableSignalGain","modFilterBands","modFilterPostGains","heterodynes","powers","lpFilters","lpFilterPostGains","carrierBands","carrierFilterPostGains","carrierBandGains","vocoderBands","numVocoderBands","hpFilterGain","outputGain","modulatorBuffer","generateVocoderBands","setupVocoderGraph","vocode","getNodes","synthLevel","shutOffCarrier","selectSawtooth","selectWavetable","setPeriodicWave","updateModGain","updateSampleLevel","updateSynthLevel","updateNoiseLevel","updateDetuneValue","detune","startFreq","endFreq","numBands","centsPerBand","log","LN2","scale","currentFreq","loadNoiseBuffer","lengthInSamples","bufferData","random","initBandpassFilters","waveShaperCurve","n2","hpFilter","Q","rectifierCurve","modulatorFilter","secondModulatorFilter","modulatorFilterPostGain","heterodyneOscillator","createOscillator","heterodyne","heterodynePostGain","rectifier","createWaveShaper","curve","lpFilter","lpFilterPostGain","waveshaper","carrierFilter","secondCarrierFilter","carrierFilterPostGain","bandGain","real","imag","createPeriodicWave","createCarriersAndPlay","VocoderFilter","currentVocoder","applyCurrentSettingsToVocoder","PassthroughWorkletProcessor","samplesCount","sample","PassThroughFilter","_totalSamples","lastSampleCount","samplePerSecond","currentTimeSamplesPerSecond","samplesProcessed","calculatePercentageProcessed","calculateRemainingTimeProcessing","timeDifference","percentageProcessed","timeDifferenceSamplePerSecond","remainingSamples","calculateSmoothedSamplePerSecond","remainingTimeSeconds","isFinite","currentSampleRate","totalSamples","FilterManager","filters","renderers","_entryPointFilter","_currentNodes","setupDefaultFilters","setupDefaultRenderers","addFilters","addRenderers","renderer","bassBooster","bitCrusher","echo","highPass","lowPass","reverb","soundtouchWrapper","limiterFilter","telephonizerFilter","TelephonizerFilter","vocoder","passthrough","returnAudio","getFiltersState","getFiltersSettings","toggleFilter","filterId","find","f","changeFilterSettings","resetFilterSettings","resetAllFiltersState","element","connectNodes","keepCurrentInputOutput","isCompatibilityMode","entrypointNode","entrypointNodes","intermediateNodes","previousNode","disconnectOldNodes","sort","keepCurrentOutput","intermediate","initializeWorklets","executeAudioRenderers","outputContext","currentBuffer","setupPlayerSpeed","bufferPlayer","setupPasstroughFilter","passthroughFilter","entrypointFilter","currentNodes","AudioContextManager","previousSampleRate","_currentContext","SAMPLE_RATE_CHANGED","createNewContext","createNewContextIfNeeded","principalBuffer","oldAudioContext","destroyOldContext","latencyHint","AudioContext","close","getRecorderWorker","workerBasePath","Worker","Recorder","cfg","worker","config","bufferLen","mimeType","workletBasePath","bitrate","callbacks","getBuffer","exportWAV","exportMP3","assign","createRecorderNode","pop","createRecorderWorklet","createRecorderScriptProcessorNode","numChannelParameter","record","kill","terminate","forceDownload","blob","document","createElement","URL","webkitURL","createObjectURL","body","appendChild","href","download","click","revokeObjectURL","SaveBufferManager","savingBuffer","playingStoppedCallback","saveBuffer","savingResult","saveBufferCompatibilityMode","saveBufferDirect","downloadAudioBlob","format","rec","finishedCallback","downloadBlobCallback","Date","toISOString","AudioProcessor","bufferManager","_renderedBuffer","audioRenderingLastCanceled","initialRenderingDone","sumPrincipalBuffer","prepareContext","resetBufferFetcher","loadInitialBuffer","currentOfflineContext","setupOutput","loadRenderedAudio","OFFLINE_AUDIO_RENDERING_FINISHED","AUDIO_RENDERING_FINISHED","CANCELLED_AND_LOADED_INITIAL_AUDIO","setCompatibilityModeChecked","COMPATIBILITY_MODE_AUTO_ENABLED","RENDERING_AUDIO_PROBLEM_DETECTED","cancelAudioRendering","CANCELLING_AUDIO_PROCESSING","checked","BufferManager","audioBuffersToFetch","downloadingInitialData","fetchBuffers","refetch","LOADING_BUFFERS","LOADED_BUFFERS","LOADING_BUFFERS_ERROR","resetReverbFilterBuffer","reverbSettings","reverbUrl","TimerSaveTime","seconds","incr","initialSeconds","countCallback","count","onCount","player","saveBufferManager","audioProcessor","defaultDeviceSampleRate","tempContext","loadBufferFromFile","getOutputBuffer","isAudioWorkletAvailable","reconnectNodesIfNeeded","exit","stream","recorder","alreadyInit","timer","enableAudioFeedback","deviceList","constraints","noiseSuppression","echoCancellation","autoGainControl","ideal","sampleRateConfigNotSupported","isRecordingAvailable","navigator","mediaDevices","getSupportedConstraints","RECORDER_INIT","getUserMedia","RECORDER_COUNT_UPDATE","successCallback","errorCallback","notFoundErrorCallback","unknownErrorCallback","ondevicechange","updateInputList","RECORDER_SUCCESS","RECORDER_ERROR","RECORDER_NOT_FOUND_ERROR","RECORDER_UNKNOWN_ERROR","audioFeedback","RECORDER_UPDATE_CONSTRAINTS","getConstraints","tracks","getTracks","updateConstraints","resetConstraints","newConstraint","precAudioFeedback","precRecording","applyConstraints","newConstraints","newConstraintName","stopStream","createMediaStreamSource","setNoiseSuppression","setAutoGain","setEchoCancellation","devices","enumerateDevices","device","kind","changeInput","deviceId","groupId","RECORDER_RECORDING","RECORDER_STOPPED","RECORDER_PAUSED","l","RECORDER_RESETED"],"mappings":"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","x_google_ignoreList":[0,29]}